{"version":3,"sources":["webpack://Matic/webpack/bootstrap","webpack://Matic/./node_modules/async/dist/async.js","webpack://Matic/./node_modules/ethereumjs-block/from-rpc.js","webpack://Matic/./node_modules/ethereumjs-block/header-from-rpc.js","webpack://Matic/./node_modules/ethereumjs-block/header.js","webpack://Matic/./node_modules/ethereumjs-block/index.js","webpack://Matic/./node_modules/ethereumjs-common/dist/chains/index.js","webpack://Matic/./node_modules/ethereumjs-common/dist/hardforks/index.js","webpack://Matic/./node_modules/ethereumjs-common/dist/index.js","webpack://Matic/./node_modules/safe-buffer/index.js","webpack://Matic/(webpack)/buildin/module.js","webpack://Matic/./src/abstracts/base_big_number.ts","webpack://Matic/./src/abstracts/base_contract.ts","webpack://Matic/./src/abstracts/base_web3_client.ts","webpack://Matic/./src/abstracts/contract_method.ts","webpack://Matic/./src/abstracts/index.ts","webpack://Matic/./src/config.ts","webpack://Matic/./src/constant.ts","webpack://Matic/./src/default.ts","webpack://Matic/./src/enums/error_type.ts","webpack://Matic/./src/enums/index.ts","webpack://Matic/./src/enums/log_event_signature.ts","webpack://Matic/./src/implementation/bn.ts","webpack://Matic/./src/implementation/index.ts","webpack://Matic/./src/index.ts","webpack://Matic/./src/interfaces/index.ts","webpack://Matic/./src/pos/erc1155.ts","webpack://Matic/./src/pos/erc20.ts","webpack://Matic/./src/pos/erc721.ts","webpack://Matic/./src/pos/exit_util.ts","webpack://Matic/./src/pos/index.ts","webpack://Matic/./src/pos/pos_token.ts","webpack://Matic/./src/pos/root_chain.ts","webpack://Matic/./src/pos/root_chain_manager.ts","webpack://Matic/./src/services/abi_service.ts","webpack://Matic/./src/services/index.ts","webpack://Matic/./src/services/network_service.ts","webpack://Matic/./src/types/index.ts","webpack://Matic/./src/utils/abi_manager.ts","webpack://Matic/./src/utils/base_token.ts","webpack://Matic/./src/utils/bridge_client.ts","webpack://Matic/./src/utils/converter.ts","webpack://Matic/./src/utils/error_helper.ts","webpack://Matic/./src/utils/event_bus.ts","webpack://Matic/./src/utils/http_request.ts","webpack://Matic/./src/utils/index.ts","webpack://Matic/./src/utils/logger.ts","webpack://Matic/./src/utils/map_promise.ts","webpack://Matic/./src/utils/merge.ts","webpack://Matic/./src/utils/merkle_tree.ts","webpack://Matic/./src/utils/not_implemented.ts","webpack://Matic/./src/utils/promise_resolve.ts","webpack://Matic/./src/utils/proof_util.ts","webpack://Matic/./src/utils/resolve.ts","webpack://Matic/./src/utils/set_proof_api_url.ts","webpack://Matic/./src/utils/use.ts","webpack://Matic/./src/utils/web3_side_chain_client.ts","webpack://Matic/external \"buffer\"","webpack://Matic/external \"ethereumjs-tx\"","webpack://Matic/external \"ethereumjs-util\"","webpack://Matic/external \"merkle-patricia-tree\"","webpack://Matic/external \"node-fetch\""],"names":[],"mappings":";;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA,EAAE,KAA4D;AAC9D,EAAE,SAC8C;AAChD,CAAC,4BAA4B;;AAE7B;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,KAAK;AAChB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,8BAA8B,oBAAoB;AAClD,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA,6BAA6B,kBAAkB,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA,8CAA8C,kBAAkB,EAAE;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,UAAU,gBAAgB;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB,wBAAwB,oBAAoB;AAC7E;AACA,WAAW,KAAK;AAChB;AACA,WAAW,SAAS;AACpB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,WAAW,sBAAsB,wBAAwB,oBAAoB;AAC7E;AACA,WAAW,KAAK;AAChB;AACA,WAAW,SAAS;AACpB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,IAAI,oBAAoB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,mDAAmD,oBAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,SAAS;AACpB;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,2BAA2B,sDAAsD;AACjF,QAAQ;AACR,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,EAAE;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,qDAAqD,8BAA8B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8BAA8B;AACtE;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,WAAW,OAAO,oDAAoD,oBAAoB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,2BAA2B,8CAA8C;AACzE;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,2BAA2B,8CAA8C;AACzE,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C,OAAO;AACpD;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD,+BAA+B;AACpF,aAAa,OAAO;AACpB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,OAAO;AACrB;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,OAAO;AAClB,gDAAgD;AAChD;AACA,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,eAAe,YAAY;AAC3B;AACA,IAAI;AACJ,eAAe,YAAY;AAC3B;AACA,IAAI;AACJ,eAAe,YAAY;AAC3B;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,EAAE;AACb,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,iCAAiC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,WAAW,iBAAiB;AAC5B,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,8BAA8B,wCAAwC;AACtE,YAAY;AACZ,8BAA8B,kDAAkD;AAChF;AACA,QAAQ;AACR,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD,mCAAmC;AACtF,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,sCAAsC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,wCAAwC,gCAAgC;AACxE;AACA;AACA,kCAAkC,kCAAkC;AACpE;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,cAAc;AACzB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,wCAAwC,gCAAgC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,kCAAkC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,QAAQ;AACR,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA,yBAAyB,+BAA+B;AACxD;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,+BAA+B;AACxD;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,kCAAkC,uBAAuB;AACzD;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,SAAS;AACpB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,SAAS;AACpB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD,SAAS;AACT,KAAK;AACL;AACA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA,gBAAgB;AAChB,IAAI;AACJ;AACA;;AAEA;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,SAAS;AACpB;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,WAAW,SAAS;AACpB;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2BAA2B;AACxD;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,qBAAqB,oBAAoB;AACzC;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA,IAAI;AACJ,qCAAqC;AACrC,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,WAAW,sBAAsB;AACjC,qBAAqB,oBAAoB;AACzC;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,OAAO;AACrB;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA;AACA,mBAAmB,uCAAuC;AAC1D;AACA,eAAe,eAAe,IAAI;AAClC,cAAc,SAAS;AACvB;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,OAAO;AACrB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA,IAAI;AACJ,WAAW,YAAY;AACvB;AACA,IAAI;AACJ;AACA;AACA,YAAY,YAAY,EAAE,YAAY,EAAE,YAAY;AACpD;AACA,IAAI;AACJ;AACA;AACA,cAAc,YAAY;AAC1B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,6BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM,+CAA+C;AAChE;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;;AAEA;AACA,sBAAsB,gCAAgC;AACtD;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,WAAW,MAAM;AACjB,WAAW,EAAE;AACb,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,uCAAuC,eAAe;AACtD;AACA,SAAS;;AAET;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,WAAW,sBAAsB;AACjC,qBAAqB,oBAAoB;AACzC,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,WAAW,sBAAsB;AACjC,WAAW,SAAS;AACpB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,WAAW,sBAAsB;AACjC,WAAW,SAAS;AACpB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,SAAS;AACtB;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA,WAAW,SAAS,GAAG,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,WAAW,cAAc,UAAU,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA,iCAAiC,+BAA+B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,WAAW,cAAc,UAAU,sBAAsB;AACzD;AACA,WAAW,cAAc;AACzB;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,qBAAqB,oBAAoB;AACzC;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA,YAAY;AACZ;AACA,IAAI;AACJ,oCAAoC;AACpC,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA,4BAA4B;AAC5B,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA,WAAW,SAAS,4BAA4B,6BAA6B;AAC7E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA,WAAW,SAAS,iBAAiB,6BAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA,WAAW,SAAS,iBAAiB,6BAA6B;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,EAAE;AACb;AACA,WAAW,cAAc;AACzB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ,8BAA8B;AAC9B,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,WAAW,cAAc;AACzB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB,EAAE;AACvC;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,WAAW,SAAS;AACpB;AACA,WAAW,cAAc;AACzB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM,uCAAuC;AACxD;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kGAAkG;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,4BAA4B;AAC5E;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,cAAc;;AAE5D,CAAC;;;;;;;;;;;;;;ACx+KW;AACZ,oBAAoB,mBAAO,CAAC,oCAAe;AAC3C,gBAAgB,mBAAO,CAAC,wCAAiB;AACzC,cAAc,mBAAO,CAAC,oDAAI;AAC1B,2BAA2B,mBAAO,CAAC,6EAAmB;;AAEtD;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,2BAA2B;AAC3B;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;;;;;;;;;;;;;ACnDY;AACZ,oBAAoB,mBAAO,CAAC,2DAAU;AACtC,gBAAgB,mBAAO,CAAC,wCAAiB;;AAEzC;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACnCA,eAAe,mBAAO,CAAC,yEAAmB;AAC1C,cAAc,mBAAO,CAAC,wCAAiB;AACvC;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpSA,eAAe,mBAAO,CAAC,yEAAmB;AAC1C,gBAAgB,mBAAO,CAAC,wCAAiB;AACzC,WAAW,mBAAO,CAAC,oCAAe;AAClC,aAAa,mBAAO,CAAC,kDAAsB;AAC3C;AACA;AACA,cAAc,mBAAO,CAAC,iDAAO;AAC7B,oBAAoB,mBAAO,CAAC,2DAAU;;AAEtC;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,MAAM;AACjB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,UAAU,OAAO;AACjB,UAAU,eAAe;AACzB,UAAU,eAAe;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;;AAEA;AACA,aAAa,4BAA4B;AACzC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AClUa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa,mBAAO,CAAC,iFAAgB;AACrC,aAAa,mBAAO,CAAC,iFAAgB;AACrC,aAAa,mBAAO,CAAC,iFAAgB;AACrC,WAAW,mBAAO,CAAC,6EAAc;AACjC,YAAY,mBAAO,CAAC,+EAAe;AACnC;AACA,iC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,mBAAmB,mBAAO,CAAC,0FAAmB;AAC9C,kBAAkB,mBAAO,CAAC,wFAAkB;AAC5C,YAAY,mBAAO,CAAC,4EAAY;AAChC,yBAAyB,mBAAO,CAAC,sGAAyB;AAC1D,uBAAuB,mBAAO,CAAC,kGAAuB;AACtD,kBAAkB,mBAAO,CAAC,wFAAkB;AAC5C,uBAAuB,mBAAO,CAAC,kGAAuB;AACtD,mBAAmB,mBAAO,CAAC,0FAAmB;AAC9C,iBAAiB,mBAAO,CAAC,sFAAiB;AAC1C,oBAAoB,mBAAO,CAAC,4FAAoB;AAChD;AACA,iC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfa;AACb;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,uEAAU;AACjC,kBAAkB,mBAAO,CAAC,6EAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,wBAAwB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,+BAA+B;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,+BAA+B;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yBAAyB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,iC;;;;;;;;;;;ACrZA;AACA;AACA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAyC;AAEzC;IAAA;IAkBA,CAAC;IAjBU,kBAAI,GAAX,UAAY,KAAK;QACb,OAAO,6DAAmB,EAAW,CAAC;IAC1C,CAAC;IAeL,oBAAC;AAAD,CAAC;;;;;;;;;;;;;;ACjBD;AAAA;AAAA;IAEI,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","file":"matic.node.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.async = global.async || {})));\n}(this, (function (exports) { 'use strict';\n\nfunction slice(arrayLike, start) {\n    start = start|0;\n    var newLen = Math.max(arrayLike.length - start, 0);\n    var newArr = Array(newLen);\n    for(var idx = 0; idx < newLen; idx++)  {\n        newArr[idx] = arrayLike[start + idx];\n    }\n    return newArr;\n}\n\n/**\n * Creates a continuation function with some arguments already applied.\n *\n * Useful as a shorthand when combined with other control flow functions. Any\n * arguments passed to the returned function are added to the arguments\n * originally passed to apply.\n *\n * @name apply\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} fn - The function you want to eventually apply all\n * arguments to. Invokes with (arguments...).\n * @param {...*} arguments... - Any number of arguments to automatically apply\n * when the continuation is called.\n * @returns {Function} the partially-applied function\n * @example\n *\n * // using apply\n * async.parallel([\n *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n *     async.apply(fs.writeFile, 'testfile2', 'test2')\n * ]);\n *\n *\n * // the same process without using apply\n * async.parallel([\n *     function(callback) {\n *         fs.writeFile('testfile1', 'test1', callback);\n *     },\n *     function(callback) {\n *         fs.writeFile('testfile2', 'test2', callback);\n *     }\n * ]);\n *\n * // It's possible to pass any number of additional arguments when calling the\n * // continuation:\n *\n * node> var fn = async.apply(sys.puts, 'one');\n * node> fn('two', 'three');\n * one\n * two\n * three\n */\nvar apply = function(fn/*, ...args*/) {\n    var args = slice(arguments, 1);\n    return function(/*callArgs*/) {\n        var callArgs = slice(arguments);\n        return fn.apply(null, args.concat(callArgs));\n    };\n};\n\nvar initialParams = function (fn) {\n    return function (/*...args, callback*/) {\n        var args = slice(arguments);\n        var callback = args.pop();\n        fn.call(this, args, callback);\n    };\n};\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nvar hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return function (fn/*, ...args*/) {\n        var args = slice(arguments, 1);\n        defer(function () {\n            fn.apply(null, args);\n        });\n    };\n}\n\nvar _defer;\n\nif (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nvar setImmediate$1 = wrap(_defer);\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    return initialParams(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (isObject(result) && typeof result.then === 'function') {\n            result.then(function(value) {\n                invokeCallback(callback, null, value);\n            }, function(err) {\n                invokeCallback(callback, err.message ? err : new Error(err));\n            });\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nfunction invokeCallback(callback, error, value) {\n    try {\n        callback(error, value);\n    } catch (e) {\n        setImmediate$1(rethrow, e);\n    }\n}\n\nfunction rethrow(error) {\n    throw error;\n}\n\nvar supportsSymbol = typeof Symbol === 'function';\n\nfunction isAsync(fn) {\n    return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction wrapAsync(asyncFn) {\n    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;\n}\n\nfunction applyEach$1(eachfn) {\n    return function(fns/*, ...args*/) {\n        var args = slice(arguments, 1);\n        var go = initialParams(function(args, callback) {\n            var that = this;\n            return eachfn(fns, function (fn, cb) {\n                wrapAsync(fn).apply(that, args.concat(cb));\n            }, callback);\n        });\n        if (args.length) {\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n}\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Built-in value references. */\nvar Symbol$1 = root.Symbol;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1];\n\n  try {\n    value[symToStringTag$1] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$1.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString$1.call(value);\n}\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]';\nvar undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]';\nvar funcTag = '[object Function]';\nvar genTag = '[object GeneratorFunction]';\nvar proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nvar breakLoop = {};\n\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nfunction once(fn) {\n    return function () {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nvar iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;\n\nvar getIterator = function (coll) {\n    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();\n};\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/** Used for built-in method references. */\nvar objectProto$3 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$2 = objectProto$3.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto$3.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER$1 = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER$1 : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/** `Object#toString` result references. */\nvar argsTag$1 = '[object Arguments]';\nvar arrayTag = '[object Array]';\nvar boolTag = '[object Boolean]';\nvar dateTag = '[object Date]';\nvar errorTag = '[object Error]';\nvar funcTag$1 = '[object Function]';\nvar mapTag = '[object Map]';\nvar numberTag = '[object Number]';\nvar objectTag = '[object Object]';\nvar regexpTag = '[object RegExp]';\nvar setTag = '[object Set]';\nvar stringTag = '[object String]';\nvar weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]';\nvar dataViewTag = '[object DataView]';\nvar float32Tag = '[object Float32Array]';\nvar float64Tag = '[object Float64Array]';\nvar int8Tag = '[object Int8Array]';\nvar int16Tag = '[object Int16Array]';\nvar int32Tag = '[object Int32Array]';\nvar uint8Tag = '[object Uint8Array]';\nvar uint8ClampedTag = '[object Uint8ClampedArray]';\nvar uint16Tag = '[object Uint16Array]';\nvar uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag$1] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/** Detect free variable `exports`. */\nvar freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports$1 && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/** Used for built-in method references. */\nvar objectProto$2 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty$1.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$5 = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;\n\n  return value === proto;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/** Used for built-in method references. */\nvar objectProto$4 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? {value: coll[i], key: i} : null;\n    }\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done)\n            return null;\n        i++;\n        return {value: item.value, key: i};\n    }\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = keys(obj);\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        return i < len ? {value: obj[key], key: key} : null;\n    };\n}\n\nfunction iterator(coll) {\n    if (isArrayLike(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = getIterator(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\n\nfunction onlyOnce(fn) {\n    return function() {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nfunction _eachOfLimit(limit) {\n    return function (obj, iteratee, callback) {\n        callback = once(callback || noop);\n        if (limit <= 0 || !obj) {\n            return callback(null);\n        }\n        var nextElem = iterator(obj);\n        var done = false;\n        var running = 0;\n        var looping = false;\n\n        function iterateeCallback(err, value) {\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            }\n            else if (value === breakLoop || (done && running <= 0)) {\n                done = true;\n                return callback(null);\n            }\n            else if (!looping) {\n                replenish();\n            }\n        }\n\n        function replenish () {\n            looping = true;\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));\n            }\n            looping = false;\n        }\n\n        replenish();\n    };\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name eachOfLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachOfLimit(coll, limit, iteratee, callback) {\n    _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);\n}\n\nfunction doLimit(fn, limit) {\n    return function (iterable, iteratee, callback) {\n        return fn(iterable, limit, iteratee, callback);\n    };\n}\n\n// eachOf implementation optimized for array-likes\nfunction eachOfArrayLike(coll, iteratee, callback) {\n    callback = once(callback || noop);\n    var index = 0,\n        completed = 0,\n        length = coll.length;\n    if (length === 0) {\n        callback(null);\n    }\n\n    function iteratorCallback(err, value) {\n        if (err) {\n            callback(err);\n        } else if ((++completed === length) || value === breakLoop) {\n            callback(null);\n        }\n    }\n\n    for (; index < length; index++) {\n        iteratee(coll[index], index, onlyOnce(iteratorCallback));\n    }\n}\n\n// a generic version of eachOf which can handle array, object, and iterator cases.\nvar eachOfGeneric = doLimit(eachOfLimit, Infinity);\n\n/**\n * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument\n * to the iteratee.\n *\n * @name eachOf\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEachOf\n * @category Collection\n * @see [async.each]{@link module:Collections.each}\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each\n * item in `coll`.\n * The `key` is the item's key, or index in the case of an array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * var obj = {dev: \"/dev.json\", test: \"/test.json\", prod: \"/prod.json\"};\n * var configs = {};\n *\n * async.forEachOf(obj, function (value, key, callback) {\n *     fs.readFile(__dirname + value, \"utf8\", function (err, data) {\n *         if (err) return callback(err);\n *         try {\n *             configs[key] = JSON.parse(data);\n *         } catch (e) {\n *             return callback(e);\n *         }\n *         callback();\n *     });\n * }, function (err) {\n *     if (err) console.error(err.message);\n *     // configs is now a map of JSON data\n *     doSomethingWith(configs);\n * });\n */\nvar eachOf = function(coll, iteratee, callback) {\n    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;\n    eachOfImplementation(coll, wrapAsync(iteratee), callback);\n};\n\nfunction doParallel(fn) {\n    return function (obj, iteratee, callback) {\n        return fn(eachOf, obj, wrapAsync(iteratee), callback);\n    };\n}\n\nfunction _asyncMap(eachfn, arr, iteratee, callback) {\n    callback = callback || noop;\n    arr = arr || [];\n    var results = [];\n    var counter = 0;\n    var _iteratee = wrapAsync(iteratee);\n\n    eachfn(arr, function (value, _, callback) {\n        var index = counter++;\n        _iteratee(value, function (err, v) {\n            results[index] = v;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Produces a new collection of values by mapping each value in `coll` through\n * the `iteratee` function. The `iteratee` is called with an item from `coll`\n * and a callback for when it has finished processing. Each of these callback\n * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n * `iteratee` passes an error to its callback, the main `callback` (for the\n * `map` function) is immediately called with the error.\n *\n * Note, that since this function applies the `iteratee` to each item in\n * parallel, there is no guarantee that the `iteratee` functions will complete\n * in order. However, the results array will be in the same order as the\n * original `coll`.\n *\n * If `map` is passed an Object, the results will be an Array.  The results\n * will roughly be in the order of the original Objects' keys (but this can\n * vary across JavaScript engines).\n *\n * @name map\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an Array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @example\n *\n * async.map(['file1','file2','file3'], fs.stat, function(err, results) {\n *     // results is now an array of stats for each file\n * });\n */\nvar map = doParallel(_asyncMap);\n\n/**\n * Applies the provided arguments to each function in the array, calling\n * `callback` after all functions have completed. If you only provide the first\n * argument, `fns`, then it will return a function which lets you pass in the\n * arguments as if it were a single function call. If more arguments are\n * provided, `callback` is required while `args` is still optional.\n *\n * @name applyEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s\n * to all call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument, `fns`, is provided, it will\n * return a function which lets you pass in the arguments as if it were a single\n * function call. The signature is `(..args, callback)`. If invoked with any\n * arguments, `callback` is required.\n * @example\n *\n * async.applyEach([enableSearch, updateSchema], 'bucket', callback);\n *\n * // partial application example:\n * async.each(\n *     buckets,\n *     async.applyEach([enableSearch, updateSchema]),\n *     callback\n * );\n */\nvar applyEach = applyEach$1(map);\n\nfunction doParallelLimit(fn) {\n    return function (obj, limit, iteratee, callback) {\n        return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);\n    };\n}\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.\n *\n * @name mapLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapLimit = doParallelLimit(_asyncMap);\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.\n *\n * @name mapSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapSeries = doLimit(mapLimit, 1);\n\n/**\n * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.\n *\n * @name applyEachSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.applyEach]{@link module:ControlFlow.applyEach}\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s to all\n * call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument is provided, it will return\n * a function which lets you pass in the arguments as if it were a single\n * function call.\n */\nvar applyEachSeries = applyEach$1(mapSeries);\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\n/**\n * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns undefined\n * @example\n *\n * async.auto({\n *     // this function will just be passed a callback\n *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),\n *     showData: ['readData', function(results, cb) {\n *         // results.readData is the file's contents\n *         // ...\n *     }]\n * }, callback);\n *\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         console.log('in write_file', JSON.stringify(results));\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         console.log('in email_link', JSON.stringify(results));\n *         // once the file is written let's email a link to it...\n *         // results.write_file contains the filename returned by write_file.\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('results = ', results);\n * });\n */\nvar auto = function (tasks, concurrency, callback) {\n    if (typeof concurrency === 'function') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = once(callback || noop);\n    var keys$$1 = keys(tasks);\n    var numTasks = keys$$1.length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var hasError = false;\n\n    var listeners = Object.create(null);\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    baseForOwn(tasks, function (task, key) {\n        if (!isArray(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        arrayEach(dependencies, function (dependencyName) {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key +\n                    '` has a non-existent dependency `' +\n                    dependencyName + '` in ' +\n                    dependencies.join(', '));\n            }\n            addListener(dependencyName, function () {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(function () {\n            runTask(key, task);\n        });\n    }\n\n    function processQueue() {\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while(readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        arrayEach(taskListeners, function (fn) {\n            fn();\n        });\n        processQueue();\n    }\n\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = onlyOnce(function(err, result) {\n            runningTasks--;\n            if (arguments.length > 2) {\n                result = slice(arguments, 1);\n            }\n            if (err) {\n                var safeResults = {};\n                baseForOwn(results, function(val, rkey) {\n                    safeResults[rkey] = val;\n                });\n                safeResults[key] = result;\n                hasError = true;\n                listeners = Object.create(null);\n\n                callback(err, safeResults);\n            } else {\n                results[key] = result;\n                taskComplete(key);\n            }\n        });\n\n        runningTasks++;\n        var taskFn = wrapAsync(task[task.length - 1]);\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            arrayEach(getDependents(currentTask), function (dependent) {\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error(\n                'async.auto cannot execute tasks due to a recursive dependency'\n            );\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        baseForOwn(tasks, function (task, key) {\n            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n};\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;\nvar symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === undefined ? length : end;\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\n}\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the last unmatched string symbol.\n */\nfunction charsEndIndex(strSymbols, chrSymbols) {\n  var index = strSymbols.length;\n\n  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the first unmatched string symbol.\n */\nfunction charsStartIndex(strSymbols, chrSymbols) {\n  var index = -1,\n      length = strSymbols.length;\n\n  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction asciiToArray(string) {\n  return string.split('');\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange = '\\\\u0300-\\\\u036f';\nvar reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f';\nvar rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff';\nvar rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;\nvar rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange$1 = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange$1 = '\\\\u0300-\\\\u036f';\nvar reComboHalfMarksRange$1 = '\\\\ufe20-\\\\ufe2f';\nvar rsComboSymbolsRange$1 = '\\\\u20d0-\\\\u20ff';\nvar rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;\nvar rsVarRange$1 = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange$1 + ']';\nvar rsCombo = '[' + rsComboRange$1 + ']';\nvar rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nvar rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';\nvar rsNonAstral = '[^' + rsAstralRange$1 + ']';\nvar rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nvar rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nvar rsZWJ$1 = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?';\nvar rsOptVar = '[' + rsVarRange$1 + ']?';\nvar rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\nvar rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction stringToArray(string) {\n  return hasUnicode(string)\n    ? unicodeToArray(string)\n    : asciiToArray(string);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/**\n * Removes leading and trailing whitespace or specified characters from `string`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to trim.\n * @param {string} [chars=whitespace] The characters to trim.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {string} Returns the trimmed string.\n * @example\n *\n * _.trim('  abc  ');\n * // => 'abc'\n *\n * _.trim('-_-abc-_-', '_-');\n * // => 'abc'\n *\n * _.map(['  foo  ', '  bar  '], _.trim);\n * // => ['foo', 'bar']\n */\nfunction trim(string, chars, guard) {\n  string = toString(string);\n  if (string && (guard || chars === undefined)) {\n    return string.replace(reTrim, '');\n  }\n  if (!string || !(chars = baseToString(chars))) {\n    return string;\n  }\n  var strSymbols = stringToArray(string),\n      chrSymbols = stringToArray(chars),\n      start = charsStartIndex(strSymbols, chrSymbols),\n      end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n  return castSlice(strSymbols, start, end).join('');\n}\n\nvar FN_ARGS = /^(?:async\\s+)?(function)?\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\nfunction parseParams(func) {\n    func = func.toString().replace(STRIP_COMMENTS, '');\n    func = func.match(FN_ARGS)[2].replace(' ', '');\n    func = func ? func.split(FN_ARG_SPLIT) : [];\n    func = func.map(function (arg){\n        return trim(arg.replace(FN_ARG, ''));\n    });\n    return func;\n}\n\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\nfunction autoInject(tasks, callback) {\n    var newTasks = {};\n\n    baseForOwn(tasks, function (taskFn, key) {\n        var params;\n        var fnIsAsync = isAsync(taskFn);\n        var hasNoDeps =\n            (!fnIsAsync && taskFn.length === 1) ||\n            (fnIsAsync && taskFn.length === 0);\n\n        if (isArray(taskFn)) {\n            params = taskFn.slice(0, -1);\n            taskFn = taskFn[taskFn.length - 1];\n\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (hasNoDeps) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {\n                throw new Error(\"autoInject task functions require explicit parameters.\");\n            }\n\n            // remove callback param\n            if (!fnIsAsync) params.pop();\n\n            newTasks[key] = params.concat(newTask);\n        }\n\n        function newTask(results, taskCb) {\n            var newArgs = arrayMap(params, function (name) {\n                return results[name];\n            });\n            newArgs.push(taskCb);\n            wrapAsync(taskFn).apply(null, newArgs);\n        }\n    });\n\n    auto(newTasks, callback);\n}\n\n// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation\n// used for queues. This implementation assumes that the node provided by the user can be modified\n// to adjust the next and last properties. We implement only the minimal functionality\n// for queue support.\nfunction DLL() {\n    this.head = this.tail = null;\n    this.length = 0;\n}\n\nfunction setInitial(dll, node) {\n    dll.length = 1;\n    dll.head = dll.tail = node;\n}\n\nDLL.prototype.removeLink = function(node) {\n    if (node.prev) node.prev.next = node.next;\n    else this.head = node.next;\n    if (node.next) node.next.prev = node.prev;\n    else this.tail = node.prev;\n\n    node.prev = node.next = null;\n    this.length -= 1;\n    return node;\n};\n\nDLL.prototype.empty = function () {\n    while(this.head) this.shift();\n    return this;\n};\n\nDLL.prototype.insertAfter = function(node, newNode) {\n    newNode.prev = node;\n    newNode.next = node.next;\n    if (node.next) node.next.prev = newNode;\n    else this.tail = newNode;\n    node.next = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.insertBefore = function(node, newNode) {\n    newNode.prev = node.prev;\n    newNode.next = node;\n    if (node.prev) node.prev.next = newNode;\n    else this.head = newNode;\n    node.prev = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.unshift = function(node) {\n    if (this.head) this.insertBefore(this.head, node);\n    else setInitial(this, node);\n};\n\nDLL.prototype.push = function(node) {\n    if (this.tail) this.insertAfter(this.tail, node);\n    else setInitial(this, node);\n};\n\nDLL.prototype.shift = function() {\n    return this.head && this.removeLink(this.head);\n};\n\nDLL.prototype.pop = function() {\n    return this.tail && this.removeLink(this.tail);\n};\n\nDLL.prototype.toArray = function () {\n    var arr = Array(this.length);\n    var curr = this.head;\n    for(var idx = 0; idx < this.length; idx++) {\n        arr[idx] = curr.data;\n        curr = curr.next;\n    }\n    return arr;\n};\n\nDLL.prototype.remove = function (testFn) {\n    var curr = this.head;\n    while(!!curr) {\n        var next = curr.next;\n        if (testFn(curr)) {\n            this.removeLink(curr);\n        }\n        curr = next;\n    }\n    return this;\n};\n\nfunction queue(worker, concurrency, payload) {\n    if (concurrency == null) {\n        concurrency = 1;\n    }\n    else if(concurrency === 0) {\n        throw new Error('Concurrency must not be zero');\n    }\n\n    var _worker = wrapAsync(worker);\n    var numRunning = 0;\n    var workersList = [];\n\n    var processingScheduled = false;\n    function _insert(data, insertAtFront, callback) {\n        if (callback != null && typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0 && q.idle()) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function() {\n                q.drain();\n            });\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                callback: callback || noop\n            };\n\n            if (insertAtFront) {\n                q._tasks.unshift(item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n\n        if (!processingScheduled) {\n            processingScheduled = true;\n            setImmediate$1(function() {\n                processingScheduled = false;\n                q.process();\n            });\n        }\n    }\n\n    function _next(tasks) {\n        return function(err){\n            numRunning -= 1;\n\n            for (var i = 0, l = tasks.length; i < l; i++) {\n                var task = tasks[i];\n\n                var index = baseIndexOf(workersList, task, 0);\n                if (index === 0) {\n                    workersList.shift();\n                } else if (index > 0) {\n                    workersList.splice(index, 1);\n                }\n\n                task.callback.apply(task, arguments);\n\n                if (err != null) {\n                    q.error(err, task.data);\n                }\n            }\n\n            if (numRunning <= (q.concurrency - q.buffer) ) {\n                q.unsaturated();\n            }\n\n            if (q.idle()) {\n                q.drain();\n            }\n            q.process();\n        };\n    }\n\n    var isProcessing = false;\n    var q = {\n        _tasks: new DLL(),\n        concurrency: concurrency,\n        payload: payload,\n        saturated: noop,\n        unsaturated:noop,\n        buffer: concurrency / 4,\n        empty: noop,\n        drain: noop,\n        error: noop,\n        started: false,\n        paused: false,\n        push: function (data, callback) {\n            _insert(data, false, callback);\n        },\n        kill: function () {\n            q.drain = noop;\n            q._tasks.empty();\n        },\n        unshift: function (data, callback) {\n            _insert(data, true, callback);\n        },\n        remove: function (testFn) {\n            q._tasks.remove(testFn);\n        },\n        process: function () {\n            // Avoid trying to start too many processing operations. This can occur\n            // when callbacks resolve synchronously (#1267).\n            if (isProcessing) {\n                return;\n            }\n            isProcessing = true;\n            while(!q.paused && numRunning < q.concurrency && q._tasks.length){\n                var tasks = [], data = [];\n                var l = q._tasks.length;\n                if (q.payload) l = Math.min(l, q.payload);\n                for (var i = 0; i < l; i++) {\n                    var node = q._tasks.shift();\n                    tasks.push(node);\n                    workersList.push(node);\n                    data.push(node.data);\n                }\n\n                numRunning += 1;\n\n                if (q._tasks.length === 0) {\n                    q.empty();\n                }\n\n                if (numRunning === q.concurrency) {\n                    q.saturated();\n                }\n\n                var cb = onlyOnce(_next(tasks));\n                _worker(data, cb);\n            }\n            isProcessing = false;\n        },\n        length: function () {\n            return q._tasks.length;\n        },\n        running: function () {\n            return numRunning;\n        },\n        workersList: function () {\n            return workersList;\n        },\n        idle: function() {\n            return q._tasks.length + numRunning === 0;\n        },\n        pause: function () {\n            q.paused = true;\n        },\n        resume: function () {\n            if (q.paused === false) { return; }\n            q.paused = false;\n            setImmediate$1(q.process);\n        }\n    };\n    return q;\n}\n\n/**\n * A cargo of tasks for the worker function to complete. Cargo inherits all of\n * the same methods and event callbacks as [`queue`]{@link module:ControlFlow.queue}.\n * @typedef {Object} CargoObject\n * @memberOf module:ControlFlow\n * @property {Function} length - A function returning the number of items\n * waiting to be processed. Invoke like `cargo.length()`.\n * @property {number} payload - An `integer` for determining how many tasks\n * should be process per round. This property can be changed after a `cargo` is\n * created to alter the payload on-the-fly.\n * @property {Function} push - Adds `task` to the `queue`. The callback is\n * called once the `worker` has finished processing the task. Instead of a\n * single task, an array of `tasks` can be submitted. The respective callback is\n * used for every task in the list. Invoke like `cargo.push(task, [callback])`.\n * @property {Function} saturated - A callback that is called when the\n * `queue.length()` hits the concurrency and further tasks will be queued.\n * @property {Function} empty - A callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - A callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke like `cargo.idle()`.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke like `cargo.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke like `cargo.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.\n */\n\n/**\n * Creates a `cargo` object with the specified payload. Tasks added to the\n * cargo will be processed altogether (up to the `payload` limit). If the\n * `worker` is in progress, the task is queued until it becomes available. Once\n * the `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, cargo passes an array of tasks to a single worker, repeating\n * when the worker is finished.\n *\n * @name cargo\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargo and inner queue.\n * @example\n *\n * // create a cargo object with payload 2\n * var cargo = async.cargo(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2);\n *\n * // add some items\n * cargo.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargo.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * cargo.push({name: 'baz'}, function(err) {\n *     console.log('finished processing baz');\n * });\n */\nfunction cargo(worker, payload) {\n    return queue(worker, 1, payload);\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n *\n * @name eachOfSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachOfSeries = doLimit(eachOfLimit, 1);\n\n/**\n * Reduces `coll` into a single value using an async `iteratee` to return each\n * successive step. `memo` is the initial state of the reduction. This function\n * only operates in series.\n *\n * For performance reasons, it may make sense to split a call to this function\n * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n * results. This function is for situations where each step in the reduction\n * needs to be async; if you can get the data before reducing it, then it's\n * probably a good idea to do so.\n *\n * @name reduce\n * @static\n * @memberOf module:Collections\n * @method\n * @alias inject\n * @alias foldl\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee complete with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n * @example\n *\n * async.reduce([1,2,3], 0, function(memo, item, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         callback(null, memo + item)\n *     });\n * }, function(err, result) {\n *     // result is now equal to the last value of memo, which is 6\n * });\n */\nfunction reduce(coll, memo, iteratee, callback) {\n    callback = once(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n    eachOfSeries(coll, function(x, i, callback) {\n        _iteratee(memo, x, function(err, v) {\n            memo = v;\n            callback(err);\n        });\n    }, function(err) {\n        callback(err, memo);\n    });\n}\n\n/**\n * Version of the compose function that is more natural to read. Each function\n * consumes the return value of the previous function. It is the equivalent of\n * [compose]{@link module:ControlFlow.compose} with the arguments reversed.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name seq\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.compose]{@link module:ControlFlow.compose}\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} a function that composes the `functions` in order\n * @example\n *\n * // Requires lodash (or underscore), express3 and dresende's orm2.\n * // Part of an app, that fetches cats of the logged user.\n * // This example uses `seq` function to avoid overnesting and error\n * // handling clutter.\n * app.get('/cats', function(request, response) {\n *     var User = request.models.User;\n *     async.seq(\n *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\n *         function(user, fn) {\n *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n *         }\n *     )(req.session.user_id, function (err, cats) {\n *         if (err) {\n *             console.error(err);\n *             response.json({ status: 'error', message: err.message });\n *         } else {\n *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n *         }\n *     });\n * });\n */\nfunction seq(/*...functions*/) {\n    var _functions = arrayMap(arguments, wrapAsync);\n    return function(/*...args*/) {\n        var args = slice(arguments);\n        var that = this;\n\n        var cb = args[args.length - 1];\n        if (typeof cb == 'function') {\n            args.pop();\n        } else {\n            cb = noop;\n        }\n\n        reduce(_functions, args, function(newargs, fn, cb) {\n            fn.apply(that, newargs.concat(function(err/*, ...nextargs*/) {\n                var nextargs = slice(arguments, 1);\n                cb(err, nextargs);\n            }));\n        },\n        function(err, results) {\n            cb.apply(that, [err].concat(results));\n        });\n    };\n}\n\n/**\n * Creates a function which is a composition of the passed asynchronous\n * functions. Each function consumes the return value of the function that\n * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name compose\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} an asynchronous function that is the composed\n * asynchronous `functions`\n * @example\n *\n * function add1(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n + 1);\n *     }, 10);\n * }\n *\n * function mul3(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n * 3);\n *     }, 10);\n * }\n *\n * var add1mul3 = async.compose(mul3, add1);\n * add1mul3(4, function (err, result) {\n *     // result now equals 15\n * });\n */\nvar compose = function(/*...args*/) {\n    return seq.apply(null, slice(arguments).reverse());\n};\n\nvar _concat = Array.prototype.concat;\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.\n *\n * @name concatLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n */\nvar concatLimit = function(coll, limit, iteratee, callback) {\n    callback = callback || noop;\n    var _iteratee = wrapAsync(iteratee);\n    mapLimit(coll, limit, function(val, callback) {\n        _iteratee(val, function(err /*, ...args*/) {\n            if (err) return callback(err);\n            return callback(null, slice(arguments, 1));\n        });\n    }, function(err, mapResults) {\n        var result = [];\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                result = _concat.apply(result, mapResults[i]);\n            }\n        }\n\n        return callback(err, result);\n    });\n};\n\n/**\n * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n * the concatenated list. The `iteratee`s are called in parallel, and the\n * results are concatenated as they return. There is no guarantee that the\n * results array will be returned in the original order of `coll` passed to the\n * `iteratee` function.\n *\n * @name concat\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @example\n *\n * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {\n *     // files is now a list of filenames that exist in the 3 directories\n * });\n */\nvar concat = doLimit(concatLimit, Infinity);\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n *\n * @name concatSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.\n * The iteratee should complete with an array an array of results.\n * Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n */\nvar concatSeries = doLimit(concatLimit, 1);\n\n/**\n * Returns a function that when called, calls-back with the values provided.\n * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to\n * [`auto`]{@link module:ControlFlow.auto}.\n *\n * @name constant\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {...*} arguments... - Any number of arguments to automatically invoke\n * callback with.\n * @returns {AsyncFunction} Returns a function that when invoked, automatically\n * invokes the callback with the previous given arguments.\n * @example\n *\n * async.waterfall([\n *     async.constant(42),\n *     function (value, next) {\n *         // value === 42\n *     },\n *     //...\n * ], callback);\n *\n * async.waterfall([\n *     async.constant(filename, \"utf8\"),\n *     fs.readFile,\n *     function (fileData, next) {\n *         //...\n *     }\n *     //...\n * ], callback);\n *\n * async.auto({\n *     hostname: async.constant(\"https://server.net/\"),\n *     port: findFreePort,\n *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n *         startServer(options, cb);\n *     }],\n *     //...\n * }, callback);\n */\nvar constant = function(/*...values*/) {\n    var values = slice(arguments);\n    var args = [null].concat(values);\n    return function (/*...ignoredArgs, callback*/) {\n        var callback = arguments[arguments.length - 1];\n        return callback.apply(this, args);\n    };\n};\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nfunction _createTester(check, getResult) {\n    return function(eachfn, arr, iteratee, cb) {\n        cb = cb || noop;\n        var testPassed = false;\n        var testResult;\n        eachfn(arr, function(value, _, callback) {\n            iteratee(value, function(err, result) {\n                if (err) {\n                    callback(err);\n                } else if (check(result) && !testResult) {\n                    testPassed = true;\n                    testResult = getResult(true, value);\n                    callback(null, breakLoop);\n                } else {\n                    callback();\n                }\n            });\n        }, function(err) {\n            if (err) {\n                cb(err);\n            } else {\n                cb(null, testPassed ? testResult : getResult(false));\n            }\n        });\n    };\n}\n\nfunction _findGetResult(v, x) {\n    return x;\n}\n\n/**\n * Returns the first value in `coll` that passes an async truth test. The\n * `iteratee` is applied in parallel, meaning the first iteratee to return\n * `true` will fire the detect `callback` with that result. That means the\n * result might not be the first item in the original `coll` (in terms of order)\n * that passes the test.\n\n * If order within the original `coll` is important, then look at\n * [`detectSeries`]{@link module:Collections.detectSeries}.\n *\n * @name detect\n * @static\n * @memberOf module:Collections\n * @method\n * @alias find\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @example\n *\n * async.detect(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // result now equals the first file in the list that exists\n * });\n */\nvar detect = doParallel(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name detectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findLimit\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectLimit = doParallelLimit(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.\n *\n * @name detectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findSeries\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectSeries = doLimit(detectLimit, 1);\n\nfunction consoleFunc(name) {\n    return function (fn/*, ...args*/) {\n        var args = slice(arguments, 1);\n        args.push(function (err/*, ...args*/) {\n            var args = slice(arguments, 1);\n            if (typeof console === 'object') {\n                if (err) {\n                    if (console.error) {\n                        console.error(err);\n                    }\n                } else if (console[name]) {\n                    arrayEach(args, function (x) {\n                        console[name](x);\n                    });\n                }\n            }\n        });\n        wrapAsync(fn).apply(null, args);\n    };\n}\n\n/**\n * Logs the result of an [`async` function]{@link AsyncFunction} to the\n * `console` using `console.dir` to display the properties of the resulting object.\n * Only works in Node.js or in browsers that support `console.dir` and\n * `console.error` (such as FF and Chrome).\n * If multiple arguments are returned from the async function,\n * `console.dir` is called on each argument in order.\n *\n * @name dir\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, {hello: name});\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.dir(hello, 'world');\n * {hello: 'world'}\n */\nvar dir = consoleFunc('dir');\n\n/**\n * The post-check version of [`during`]{@link module:ControlFlow.during}. To reflect the difference in\n * the order of operations, the arguments `test` and `fn` are switched.\n *\n * Also a version of [`doWhilst`]{@link module:ControlFlow.doWhilst} with asynchronous `test` function.\n * @name doDuring\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.during]{@link module:ControlFlow.during}\n * @category Control Flow\n * @param {AsyncFunction} fn - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (...args, callback), where `...args` are the\n * non-error args from the previous callback of `fn`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error if one occurred, otherwise `null`.\n */\nfunction doDuring(fn, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var _fn = wrapAsync(fn);\n    var _test = wrapAsync(test);\n\n    function next(err/*, ...args*/) {\n        if (err) return callback(err);\n        var args = slice(arguments, 1);\n        args.push(check);\n        _test.apply(this, args);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        _fn(next);\n    }\n\n    check(null, true);\n\n}\n\n/**\n * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in\n * the order of operations, the arguments `test` and `iteratee` are switched.\n *\n * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n *\n * @name doWhilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - A function which is called each time `test`\n * passes. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with any non-error callback results of\n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped.\n * `callback` will be passed an error and any arguments passed to the final\n * `iteratee`'s callback. Invoked with (err, [results]);\n */\nfunction doWhilst(iteratee, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n    var next = function(err/*, ...args*/) {\n        if (err) return callback(err);\n        var args = slice(arguments, 1);\n        if (test.apply(this, args)) return _iteratee(next);\n        callback.apply(null, [null].concat(args));\n    };\n    _iteratee(next);\n}\n\n/**\n * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the\n * argument ordering differs from `until`.\n *\n * @name doUntil\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with any non-error callback results of\n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n */\nfunction doUntil(iteratee, test, callback) {\n    doWhilst(iteratee, function() {\n        return !test.apply(this, arguments);\n    }, callback);\n}\n\n/**\n * Like [`whilst`]{@link module:ControlFlow.whilst}, except the `test` is an asynchronous function that\n * is passed a callback in the form of `function (err, truth)`. If error is\n * passed to `test` or `fn`, the main callback is immediately called with the\n * value of the error.\n *\n * @name during\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (callback).\n * @param {AsyncFunction} fn - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error, if one occurred, otherwise `null`.\n * @example\n *\n * var count = 0;\n *\n * async.during(\n *     function (callback) {\n *         return callback(null, count < 5);\n *     },\n *     function (callback) {\n *         count++;\n *         setTimeout(callback, 1000);\n *     },\n *     function (err) {\n *         // 5 seconds have passed\n *     }\n * );\n */\nfunction during(test, fn, callback) {\n    callback = onlyOnce(callback || noop);\n    var _fn = wrapAsync(fn);\n    var _test = wrapAsync(test);\n\n    function next(err) {\n        if (err) return callback(err);\n        _test(check);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        _fn(next);\n    }\n\n    _test(check);\n}\n\nfunction _withoutIndex(iteratee) {\n    return function (value, index, callback) {\n        return iteratee(value, callback);\n    };\n}\n\n/**\n * Applies the function `iteratee` to each item in `coll`, in parallel.\n * The `iteratee` is called with an item from the list, and a callback for when\n * it has finished. If the `iteratee` passes an error to its `callback`, the\n * main `callback` (for the `each` function) is immediately called with the\n * error.\n *\n * Note, that since this function applies `iteratee` to each item in parallel,\n * there is no guarantee that the iteratee functions will complete in order.\n *\n * @name each\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEach\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to\n * each item in `coll`. Invoked with (item, callback).\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOf`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * // assuming openFiles is an array of file names and saveFile is a function\n * // to save the modified contents of that file:\n *\n * async.each(openFiles, saveFile, function(err){\n *   // if any of the saves produced an error, err would equal that error\n * });\n *\n * // assuming openFiles is an array of file names\n * async.each(openFiles, function(file, callback) {\n *\n *     // Perform operation on file here.\n *     console.log('Processing file ' + file);\n *\n *     if( file.length > 32 ) {\n *       console.log('This file name is too long');\n *       callback('File name too long');\n *     } else {\n *       // Do work to process file here\n *       console.log('File processed');\n *       callback();\n *     }\n * }, function(err) {\n *     // if any of the file processing produced an error, err would equal that error\n *     if( err ) {\n *       // One of the iterations produced an error.\n *       // All processing will now stop.\n *       console.log('A file failed to process');\n *     } else {\n *       console.log('All files have been processed successfully');\n *     }\n * });\n */\nfunction eachLimit(coll, iteratee, callback) {\n    eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachLimit$1(coll, limit, iteratee, callback) {\n    _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n *\n * @name eachSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfSeries`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachSeries = doLimit(eachLimit$1, 1);\n\n/**\n * Wrap an async function and ensure it calls its callback on a later tick of\n * the event loop.  If the function already calls its callback on a next tick,\n * no extra deferral is added. This is useful for preventing stack overflows\n * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n * contained. ES2017 `async` functions are returned as-is -- they are immune\n * to Zalgo's corrupting influences, as they always resolve on a later tick.\n *\n * @name ensureAsync\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - an async function, one that expects a node-style\n * callback as its last argument.\n * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n * signature as the function passed in.\n * @example\n *\n * function sometimesAsync(arg, callback) {\n *     if (cache[arg]) {\n *         return callback(null, cache[arg]); // this would be synchronous!!\n *     } else {\n *         doSomeIO(arg, callback); // this IO would be asynchronous\n *     }\n * }\n *\n * // this has a risk of stack overflows if many results are cached in a row\n * async.mapSeries(args, sometimesAsync, done);\n *\n * // this will defer sometimesAsync's callback if necessary,\n * // preventing stack overflows\n * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n */\nfunction ensureAsync(fn) {\n    if (isAsync(fn)) return fn;\n    return initialParams(function (args, callback) {\n        var sync = true;\n        args.push(function () {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate$1(function () {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        fn.apply(this, args);\n        sync = false;\n    });\n}\n\nfunction notId(v) {\n    return !v;\n}\n\n/**\n * Returns `true` if every element in `coll` satisfies an async test. If any\n * iteratee call returns `false`, the main `callback` is immediately called.\n *\n * @name every\n * @static\n * @memberOf module:Collections\n * @method\n * @alias all\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @example\n *\n * async.every(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then every file exists\n * });\n */\nvar every = doParallel(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.\n *\n * @name everyLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everyLimit = doParallelLimit(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.\n *\n * @name everySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in series.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everySeries = doLimit(everyLimit, 1);\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nfunction filterArray(eachfn, arr, iteratee, callback) {\n    var truthValues = new Array(arr.length);\n    eachfn(arr, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            truthValues[index] = !!v;\n            callback(err);\n        });\n    }, function (err) {\n        if (err) return callback(err);\n        var results = [];\n        for (var i = 0; i < arr.length; i++) {\n            if (truthValues[i]) results.push(arr[i]);\n        }\n        callback(null, results);\n    });\n}\n\nfunction filterGeneric(eachfn, coll, iteratee, callback) {\n    var results = [];\n    eachfn(coll, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            if (err) {\n                callback(err);\n            } else {\n                if (v) {\n                    results.push({index: index, value: x});\n                }\n                callback();\n            }\n        });\n    }, function (err) {\n        if (err) {\n            callback(err);\n        } else {\n            callback(null, arrayMap(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), baseProperty('value')));\n        }\n    });\n}\n\nfunction _filter(eachfn, coll, iteratee, callback) {\n    var filter = isArrayLike(coll) ? filterArray : filterGeneric;\n    filter(eachfn, coll, wrapAsync(iteratee), callback || noop);\n}\n\n/**\n * Returns a new array of all the values in `coll` which pass an async truth\n * test. This operation is performed in parallel, but the results array will be\n * in the same order as the original.\n *\n * @name filter\n * @static\n * @memberOf module:Collections\n * @method\n * @alias select\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.filter(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of the existing files\n * });\n */\nvar filter = doParallel(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name filterLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar filterLimit = doParallelLimit(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.\n *\n * @name filterSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results)\n */\nvar filterSeries = doLimit(filterLimit, 1);\n\n/**\n * Calls the asynchronous function `fn` with a callback parameter that allows it\n * to call itself again, in series, indefinitely.\n\n * If an error is passed to the callback then `errback` is called with the\n * error, and execution stops, otherwise it will never be called.\n *\n * @name forever\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} fn - an async function to call repeatedly.\n * Invoked with (next).\n * @param {Function} [errback] - when `fn` passes an error to it's callback,\n * this function will be called, and execution stops. Invoked with (err).\n * @example\n *\n * async.forever(\n *     function(next) {\n *         // next is suitable for passing to things that need a callback(err [, whatever]);\n *         // it will result in this function being called again.\n *     },\n *     function(err) {\n *         // if next is called with a value in its first parameter, it will appear\n *         // in here as 'err', and execution will stop.\n *     }\n * );\n */\nfunction forever(fn, errback) {\n    var done = onlyOnce(errback || noop);\n    var task = wrapAsync(ensureAsync(fn));\n\n    function next(err) {\n        if (err) return done(err);\n        task(next);\n    }\n    next();\n}\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.\n *\n * @name groupByLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n */\nvar groupByLimit = function(coll, limit, iteratee, callback) {\n    callback = callback || noop;\n    var _iteratee = wrapAsync(iteratee);\n    mapLimit(coll, limit, function(val, callback) {\n        _iteratee(val, function(err, key) {\n            if (err) return callback(err);\n            return callback(null, {key: key, val: val});\n        });\n    }, function(err, mapResults) {\n        var result = {};\n        // from MDN, handle object having an `hasOwnProperty` prop\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                var key = mapResults[i].key;\n                var val = mapResults[i].val;\n\n                if (hasOwnProperty.call(result, key)) {\n                    result[key].push(val);\n                } else {\n                    result[key] = [val];\n                }\n            }\n        }\n\n        return callback(err, result);\n    });\n};\n\n/**\n * Returns a new object, where each value corresponds to an array of items, from\n * `coll`, that returned the corresponding key. That is, the keys of the object\n * correspond to the values passed to the `iteratee` callback.\n *\n * Note: Since this function applies the `iteratee` to each item in parallel,\n * there is no guarantee that the `iteratee` functions will complete in order.\n * However, the values for each key in the `result` will be in the same order as\n * the original `coll`. For Objects, the values will roughly be in the order of\n * the original Objects' keys (but this can vary across JavaScript engines).\n *\n * @name groupBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n * @example\n *\n * async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {\n *     db.findById(userId, function(err, user) {\n *         if (err) return callback(err);\n *         return callback(null, user.age);\n *     });\n * }, function(err, result) {\n *     // result is object containing the userIds grouped by age\n *     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};\n * });\n */\nvar groupBy = doLimit(groupByLimit, Infinity);\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.\n *\n * @name groupBySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n */\nvar groupBySeries = doLimit(groupByLimit, 1);\n\n/**\n * Logs the result of an `async` function to the `console`. Only works in\n * Node.js or in browsers that support `console.log` and `console.error` (such\n * as FF and Chrome). If multiple arguments are returned from the async\n * function, `console.log` is called on each argument in order.\n *\n * @name log\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, 'hello ' + name);\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.log(hello, 'world');\n * 'hello world'\n */\nvar log = consoleFunc('log');\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name mapValuesLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nfunction mapValuesLimit(obj, limit, iteratee, callback) {\n    callback = once(callback || noop);\n    var newObj = {};\n    var _iteratee = wrapAsync(iteratee);\n    eachOfLimit(obj, limit, function(val, key, next) {\n        _iteratee(val, key, function (err, result) {\n            if (err) return next(err);\n            newObj[key] = result;\n            next();\n        });\n    }, function (err) {\n        callback(err, newObj);\n    });\n}\n\n/**\n * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.\n *\n * Produces a new Object by mapping each value of `obj` through the `iteratee`\n * function. The `iteratee` is called each `value` and `key` from `obj` and a\n * callback for when it has finished processing. Each of these callbacks takes\n * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n * passes an error to its callback, the main `callback` (for the `mapValues`\n * function) is immediately called with the error.\n *\n * Note, the order of the keys in the result is not guaranteed.  The keys will\n * be roughly in the order they complete, (but this is very engine-specific)\n *\n * @name mapValues\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @example\n *\n * async.mapValues({\n *     f1: 'file1',\n *     f2: 'file2',\n *     f3: 'file3'\n * }, function (file, key, callback) {\n *   fs.stat(file, callback);\n * }, function(err, result) {\n *     // result is now a map of stats for each file, e.g.\n *     // {\n *     //     f1: [stats for file1],\n *     //     f2: [stats for file2],\n *     //     f3: [stats for file3]\n *     // }\n * });\n */\n\nvar mapValues = doLimit(mapValuesLimit, Infinity);\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.\n *\n * @name mapValuesSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nvar mapValuesSeries = doLimit(mapValuesLimit, 1);\n\nfunction has(obj, key) {\n    return key in obj;\n}\n\n/**\n * Caches the results of an async function. When creating a hash to store\n * function results against, the callback is omitted from the hash and an\n * optional hash function can be used.\n *\n * If no hash function is specified, the first argument is used as a hash key,\n * which may work reasonably if it is a string or a data type that converts to a\n * distinct string. Note that objects and arrays will not behave reasonably.\n * Neither will cases where the other arguments are significant. In such cases,\n * specify your own hash function.\n *\n * The cache of results is exposed as the `memo` property of the function\n * returned by `memoize`.\n *\n * @name memoize\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function to proxy and cache results from.\n * @param {Function} hasher - An optional function for generating a custom hash\n * for storing results. It has all the arguments applied to it apart from the\n * callback, and must be synchronous.\n * @returns {AsyncFunction} a memoized version of `fn`\n * @example\n *\n * var slow_fn = function(name, callback) {\n *     // do something\n *     callback(null, result);\n * };\n * var fn = async.memoize(slow_fn);\n *\n * // fn can now be used as if it were slow_fn\n * fn('some name', function() {\n *     // callback\n * });\n */\nfunction memoize(fn, hasher) {\n    var memo = Object.create(null);\n    var queues = Object.create(null);\n    hasher = hasher || identity;\n    var _fn = wrapAsync(fn);\n    var memoized = initialParams(function memoized(args, callback) {\n        var key = hasher.apply(null, args);\n        if (has(memo, key)) {\n            setImmediate$1(function() {\n                callback.apply(null, memo[key]);\n            });\n        } else if (has(queues, key)) {\n            queues[key].push(callback);\n        } else {\n            queues[key] = [callback];\n            _fn.apply(null, args.concat(function(/*args*/) {\n                var args = slice(arguments);\n                memo[key] = args;\n                var q = queues[key];\n                delete queues[key];\n                for (var i = 0, l = q.length; i < l; i++) {\n                    q[i].apply(null, args);\n                }\n            }));\n        }\n    });\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n}\n\n/**\n * Calls `callback` on a later loop around the event loop. In Node.js this just\n * calls `process.nextTick`.  In the browser it will use `setImmediate` if\n * available, otherwise `setTimeout(callback, 0)`, which means other higher\n * priority events may precede the execution of `callback`.\n *\n * This is used internally for browser-compatibility purposes.\n *\n * @name nextTick\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.setImmediate]{@link module:Utils.setImmediate}\n * @category Util\n * @param {Function} callback - The function to call on a later loop around\n * the event loop. Invoked with (args...).\n * @param {...*} args... - any number of additional arguments to pass to the\n * callback on the next tick.\n * @example\n *\n * var call_order = [];\n * async.nextTick(function() {\n *     call_order.push('two');\n *     // call_order now equals ['one','two']\n * });\n * call_order.push('one');\n *\n * async.setImmediate(function (a, b, c) {\n *     // a, b, and c equal 1, 2, and 3\n * }, 1, 2, 3);\n */\nvar _defer$1;\n\nif (hasNextTick) {\n    _defer$1 = process.nextTick;\n} else if (hasSetImmediate) {\n    _defer$1 = setImmediate;\n} else {\n    _defer$1 = fallback;\n}\n\nvar nextTick = wrap(_defer$1);\n\nfunction _parallel(eachfn, tasks, callback) {\n    callback = callback || noop;\n    var results = isArrayLike(tasks) ? [] : {};\n\n    eachfn(tasks, function (task, key, callback) {\n        wrapAsync(task)(function (err, result) {\n            if (arguments.length > 2) {\n                result = slice(arguments, 1);\n            }\n            results[key] = result;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Run the `tasks` collection of functions in parallel, without waiting until\n * the previous function has completed. If any of the functions pass an error to\n * its callback, the main `callback` is immediately called with the value of the\n * error. Once the `tasks` have completed, the results are passed to the final\n * `callback` as an array.\n *\n * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n * parallel execution of code.  If your tasks do not use any timers or perform\n * any I/O, they will actually be executed in series.  Any synchronous setup\n * sections for each task will happen one after the other.  JavaScript remains\n * single-threaded.\n *\n * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the\n * execution of other tasks when a task fails.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n * results from {@link async.parallel}.\n *\n * @name parallel\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n *\n * @example\n * async.parallel([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // the results array will equal ['one','two'] even though\n *     // the second function had a shorter timeout.\n * });\n *\n * // an example using an object instead of an array\n * async.parallel({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equals to: {one: 1, two: 2}\n * });\n */\nfunction parallelLimit(tasks, callback) {\n    _parallel(eachOf, tasks, callback);\n}\n\n/**\n * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name parallelLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.parallel]{@link module:ControlFlow.parallel}\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n */\nfunction parallelLimit$1(tasks, limit, callback) {\n    _parallel(_eachOfLimit(limit), tasks, callback);\n}\n\n/**\n * A queue of tasks for the worker function to complete.\n * @typedef {Object} QueueObject\n * @memberOf module:ControlFlow\n * @property {Function} length - a function returning the number of items\n * waiting to be processed. Invoke with `queue.length()`.\n * @property {boolean} started - a boolean indicating whether or not any\n * items have been pushed and processed by the queue.\n * @property {Function} running - a function returning the number of items\n * currently being processed. Invoke with `queue.running()`.\n * @property {Function} workersList - a function returning the array of items\n * currently being processed. Invoke with `queue.workersList()`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n * @property {number} concurrency - an integer for determining how many `worker`\n * functions should be run in parallel. This property can be changed after a\n * `queue` is created to alter the concurrency on-the-fly.\n * @property {Function} push - add a new task to the `queue`. Calls `callback`\n * once the `worker` has finished processing the task. Instead of a single task,\n * a `tasks` array can be submitted. The respective callback is used for every\n * task in the list. Invoke with `queue.push(task, [callback])`,\n * @property {Function} unshift - add a new task to the front of the `queue`.\n * Invoke with `queue.unshift(task, [callback])`.\n * @property {Function} remove - remove items from the queue that match a test\n * function.  The test function will be passed an object with a `data` property,\n * and a `priority` property, if this is a\n * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.\n * Invoked with `queue.remove(testFn)`, where `testFn` is of the form\n * `function ({data, priority}) {}` and returns a Boolean.\n * @property {Function} saturated - a callback that is called when the number of\n * running workers hits the `concurrency` limit, and further tasks will be\n * queued.\n * @property {Function} unsaturated - a callback that is called when the number\n * of running workers is less than the `concurrency` & `buffer` limits, and\n * further tasks will not be queued.\n * @property {number} buffer - A minimum threshold buffer in order to say that\n * the `queue` is `unsaturated`.\n * @property {Function} empty - a callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - a callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} error - a callback that is called when a task errors.\n * Has the signature `function(error, task)`.\n * @property {boolean} paused - a boolean for determining whether the queue is\n * in a paused state.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke with `queue.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke with `queue.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. No more tasks\n * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.\n */\n\n/**\n * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n * `queue` are processed in parallel (up to the `concurrency` limit). If all\n * `worker`s are in progress, the task is queued until one becomes available.\n * Once a `worker` completes a `task`, that `task`'s callback is called.\n *\n * @name queue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`. Invoked with (task, callback).\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the queue.\n * @example\n *\n * // create a queue object with concurrency 2\n * var q = async.queue(function(task, callback) {\n *     console.log('hello ' + task.name);\n *     callback();\n * }, 2);\n *\n * // assign a callback\n * q.drain = function() {\n *     console.log('all items have been processed');\n * };\n *\n * // add some items to the queue\n * q.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * q.push({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n *\n * // add some items to the queue (batch-wise)\n * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n *     console.log('finished processing item');\n * });\n *\n * // add some items to the front of the queue\n * q.unshift({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n */\nvar queue$1 = function (worker, concurrency) {\n    var _worker = wrapAsync(worker);\n    return queue(function (items, cb) {\n        _worker(items[0], cb);\n    }, concurrency, 1);\n};\n\n/**\n * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and\n * completed in ascending priority order.\n *\n * @name priorityQueue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`.\n * Invoked with (task, callback).\n * @param {number} concurrency - An `integer` for determining how many `worker`\n * functions should be run in parallel.  If omitted, the concurrency defaults to\n * `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two\n * differences between `queue` and `priorityQueue` objects:\n * * `push(task, priority, [callback])` - `priority` should be a number. If an\n *   array of `tasks` is given, all tasks will be assigned the same priority.\n * * The `unshift` method was removed.\n */\nvar priorityQueue = function(worker, concurrency) {\n    // Start with a normal queue\n    var q = queue$1(worker, concurrency);\n\n    // Override push to accept second parameter representing priority\n    q.push = function(data, priority, callback) {\n        if (callback == null) callback = noop;\n        if (typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function() {\n                q.drain();\n            });\n        }\n\n        priority = priority || 0;\n        var nextNode = q._tasks.head;\n        while (nextNode && priority >= nextNode.priority) {\n            nextNode = nextNode.next;\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                priority: priority,\n                callback: callback\n            };\n\n            if (nextNode) {\n                q._tasks.insertBefore(nextNode, item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n        setImmediate$1(q.process);\n    };\n\n    // Remove unshift function\n    delete q.unshift;\n\n    return q;\n};\n\n/**\n * Runs the `tasks` array of functions in parallel, without waiting until the\n * previous function has completed. Once any of the `tasks` complete or pass an\n * error to its callback, the main `callback` is immediately called. It's\n * equivalent to `Promise.race()`.\n *\n * @name race\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}\n * to run. Each function can complete with an optional `result` value.\n * @param {Function} callback - A callback to run once any of the functions have\n * completed. This function gets an error or result from the first function that\n * completed. Invoked with (err, result).\n * @returns undefined\n * @example\n *\n * async.race([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // main callback\n * function(err, result) {\n *     // the result will be equal to 'two' as it finishes earlier\n * });\n */\nfunction race(tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));\n    if (!tasks.length) return callback();\n    for (var i = 0, l = tasks.length; i < l; i++) {\n        wrapAsync(tasks[i])(callback);\n    }\n}\n\n/**\n * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.\n *\n * @name reduceRight\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reduce]{@link module:Collections.reduce}\n * @alias foldr\n * @category Collection\n * @param {Array} array - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee complete with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n */\nfunction reduceRight (array, memo, iteratee, callback) {\n    var reversed = slice(array).reverse();\n    reduce(reversed, memo, iteratee, callback);\n}\n\n/**\n * Wraps the async function in another function that always completes with a\n * result object, even when it errors.\n *\n * The result object has either the property `error` or `value`.\n *\n * @name reflect\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function you want to wrap\n * @returns {Function} - A function that always passes null to it's callback as\n * the error. The second argument to the callback will be an `object` with\n * either an `error` or a `value` property.\n * @example\n *\n * async.parallel([\n *     async.reflect(function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff but error ...\n *         callback('bad stuff happened');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     })\n * ],\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = 'bad stuff happened'\n *     // results[2].value = 'two'\n * });\n */\nfunction reflect(fn) {\n    var _fn = wrapAsync(fn);\n    return initialParams(function reflectOn(args, reflectCallback) {\n        args.push(function callback(error, cbArg) {\n            if (error) {\n                reflectCallback(null, { error: error });\n            } else {\n                var value;\n                if (arguments.length <= 2) {\n                    value = cbArg;\n                } else {\n                    value = slice(arguments, 1);\n                }\n                reflectCallback(null, { value: value });\n            }\n        });\n\n        return _fn.apply(this, args);\n    });\n}\n\n/**\n * A helper function that wraps an array or an object of functions with `reflect`.\n *\n * @name reflectAll\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.reflect]{@link module:Utils.reflect}\n * @category Util\n * @param {Array|Object|Iterable} tasks - The collection of\n * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.\n * @returns {Array} Returns an array of async functions, each wrapped in\n * `async.reflect`\n * @example\n *\n * let tasks = [\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         // do some more stuff but error ...\n *         callback(new Error('bad stuff happened'));\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ];\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = Error('bad stuff happened')\n *     // results[2].value = 'two'\n * });\n *\n * // an example using an object instead of an array\n * let tasks = {\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         callback('two');\n *     },\n *     three: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'three');\n *         }, 100);\n *     }\n * };\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results.one.value = 'one'\n *     // results.two.error = 'two'\n *     // results.three.value = 'three'\n * });\n */\nfunction reflectAll(tasks) {\n    var results;\n    if (isArray(tasks)) {\n        results = arrayMap(tasks, reflect);\n    } else {\n        results = {};\n        baseForOwn(tasks, function(task, key) {\n            results[key] = reflect.call(this, task);\n        });\n    }\n    return results;\n}\n\nfunction reject$1(eachfn, arr, iteratee, callback) {\n    _filter(eachfn, arr, function(value, cb) {\n        iteratee(value, function(err, v) {\n            cb(err, !v);\n        });\n    }, callback);\n}\n\n/**\n * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.\n *\n * @name reject\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.reject(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of missing files\n *     createFiles(results);\n * });\n */\nvar reject = doParallel(reject$1);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name rejectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectLimit = doParallelLimit(reject$1);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.\n *\n * @name rejectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectSeries = doLimit(rejectLimit, 1);\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant$1(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // to retry individual methods that are not as reliable within other\n * // control flow functions, use the `retryable` wrapper:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nfunction retry(opts, task, callback) {\n    var DEFAULT_TIMES = 5;\n    var DEFAULT_INTERVAL = 0;\n\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: constant$1(DEFAULT_INTERVAL)\n    };\n\n    function parseTimes(acc, t) {\n        if (typeof t === 'object') {\n            acc.times = +t.times || DEFAULT_TIMES;\n\n            acc.intervalFunc = typeof t.interval === 'function' ?\n                t.interval :\n                constant$1(+t.interval || DEFAULT_INTERVAL);\n\n            acc.errorFilter = t.errorFilter;\n        } else if (typeof t === 'number' || typeof t === 'string') {\n            acc.times = +t || DEFAULT_TIMES;\n        } else {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n    }\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || noop;\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || noop;\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var _task = wrapAsync(task);\n\n    var attempt = 1;\n    function retryAttempt() {\n        _task(function(err) {\n            if (err && attempt++ < options.times &&\n                (typeof options.errorFilter != 'function' ||\n                    options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt));\n            } else {\n                callback.apply(null, arguments);\n            }\n        });\n    }\n\n    retryAttempt();\n}\n\n/**\n * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method\n * wraps a task and makes it retryable, rather than immediately calling it\n * with retries.\n *\n * @name retryable\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.retry]{@link module:ControlFlow.retry}\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n * options, exactly the same as from `retry`\n * @param {AsyncFunction} task - the asynchronous function to wrap.\n * This function will be passed any arguments passed to the returned wrapper.\n * Invoked with (...args, callback).\n * @returns {AsyncFunction} The wrapped function, which when invoked, will\n * retry on an error, based on the parameters specified in `opts`.\n * This function will accept the same parameters as `task`.\n * @example\n *\n * async.auto({\n *     dep1: async.retryable(3, getFromFlakyService),\n *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n *         maybeProcessData(results.dep1, cb);\n *     })]\n * }, callback);\n */\nvar retryable = function (opts, task) {\n    if (!task) {\n        task = opts;\n        opts = null;\n    }\n    var _task = wrapAsync(task);\n    return initialParams(function (args, callback) {\n        function taskFn(cb) {\n            _task.apply(null, args.concat(cb));\n        }\n\n        if (opts) retry(opts, taskFn, callback);\n        else retry(taskFn, callback);\n\n    });\n};\n\n/**\n * Run the functions in the `tasks` collection in series, each one running once\n * the previous function has completed. If any functions in the series pass an\n * error to its callback, no more functions are run, and `callback` is\n * immediately called with the value of the error. Otherwise, `callback`\n * receives an array of results when `tasks` have completed.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function, and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n *  results from {@link async.series}.\n *\n * **Note** that while many implementations preserve the order of object\n * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n * explicitly states that\n *\n * > The mechanics and order of enumerating the properties is not specified.\n *\n * So if you rely on the order in which your series of functions are executed,\n * and want this to work on all platforms, consider using an array.\n *\n * @name series\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection containing\n * [async functions]{@link AsyncFunction} to run in series.\n * Each function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This function gets a results array (or object)\n * containing all the result arguments passed to the `task` callbacks. Invoked\n * with (err, result).\n * @example\n * async.series([\n *     function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     },\n *     function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // results is now equal to ['one', 'two']\n * });\n *\n * async.series({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback){\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equal to: {one: 1, two: 2}\n * });\n */\nfunction series(tasks, callback) {\n    _parallel(eachOfSeries, tasks, callback);\n}\n\n/**\n * Returns `true` if at least one element in the `coll` satisfies an async test.\n * If any iteratee call returns `true`, the main `callback` is immediately\n * called.\n *\n * @name some\n * @static\n * @memberOf module:Collections\n * @method\n * @alias any\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @example\n *\n * async.some(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then at least one of the files exists\n * });\n */\nvar some = doParallel(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.\n *\n * @name someLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anyLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someLimit = doParallelLimit(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.\n *\n * @name someSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anySeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in series.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someSeries = doLimit(someLimit, 1);\n\n/**\n * Sorts a list by the results of running each `coll` value through an async\n * `iteratee`.\n *\n * @name sortBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a value to use as the sort criteria as\n * its `result`.\n * Invoked with (item, callback).\n * @param {Function} callback - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is the items\n * from the original `coll` sorted by the values returned by the `iteratee`\n * calls. Invoked with (err, results).\n * @example\n *\n * async.sortBy(['file1','file2','file3'], function(file, callback) {\n *     fs.stat(file, function(err, stats) {\n *         callback(err, stats.mtime);\n *     });\n * }, function(err, results) {\n *     // results is now the original array of files sorted by\n *     // modified date\n * });\n *\n * // By modifying the callback parameter the\n * // sorting order can be influenced:\n *\n * // ascending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x);\n * }, function(err,result) {\n *     // result callback\n * });\n *\n * // descending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around\n * }, function(err,result) {\n *     // result callback\n * });\n */\nfunction sortBy (coll, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    map(coll, function (x, callback) {\n        _iteratee(x, function (err, criteria) {\n            if (err) return callback(err);\n            callback(null, {value: x, criteria: criteria});\n        });\n    }, function (err, results) {\n        if (err) return callback(err);\n        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));\n    });\n\n    function comparator(left, right) {\n        var a = left.criteria, b = right.criteria;\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n}\n\n/**\n * Sets a time limit on an asynchronous function. If the function does not call\n * its callback within the specified milliseconds, it will be called with a\n * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n *\n * @name timeout\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} asyncFn - The async function to limit in time.\n * @param {number} milliseconds - The specified time limit.\n * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n * to timeout Error for more information..\n * @returns {AsyncFunction} Returns a wrapped function that can be used with any\n * of the control flow functions.\n * Invoke this function with the same parameters as you would `asyncFunc`.\n * @example\n *\n * function myFunction(foo, callback) {\n *     doAsyncTask(foo, function(err, data) {\n *         // handle errors\n *         if (err) return callback(err);\n *\n *         // do some stuff ...\n *\n *         // return processed data\n *         return callback(null, data);\n *     });\n * }\n *\n * var wrapped = async.timeout(myFunction, 1000);\n *\n * // call `wrapped` as you would `myFunction`\n * wrapped({ bar: 'bar' }, function(err, data) {\n *     // if `myFunction` takes < 1000 ms to execute, `err`\n *     // and `data` will have their expected values\n *\n *     // else `err` will be an Error with the code 'ETIMEDOUT'\n * });\n */\nfunction timeout(asyncFn, milliseconds, info) {\n    var fn = wrapAsync(asyncFn);\n\n    return initialParams(function (args, callback) {\n        var timedOut = false;\n        var timer;\n\n        function timeoutCallback() {\n            var name = asyncFn.name || 'anonymous';\n            var error  = new Error('Callback function \"' + name + '\" timed out.');\n            error.code = 'ETIMEDOUT';\n            if (info) {\n                error.info = info;\n            }\n            timedOut = true;\n            callback(error);\n        }\n\n        args.push(function () {\n            if (!timedOut) {\n                callback.apply(null, arguments);\n                clearTimeout(timer);\n            }\n        });\n\n        // setup timer and call original function\n        timer = setTimeout(timeoutCallback, milliseconds);\n        fn.apply(null, args);\n    });\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil;\nvar nativeMax = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name timesLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} count - The number of times to run the function.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see [async.map]{@link module:Collections.map}.\n */\nfunction timeLimit(count, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);\n}\n\n/**\n * Calls the `iteratee` function `n` times, and accumulates results in the same\n * manner you would use with [map]{@link module:Collections.map}.\n *\n * @name times\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n * @example\n *\n * // Pretend this is some complicated async factory\n * var createUser = function(id, callback) {\n *     callback(null, {\n *         id: 'user' + id\n *     });\n * };\n *\n * // generate 5 users\n * async.times(5, function(n, next) {\n *     createUser(n, function(err, user) {\n *         next(err, user);\n *     });\n * }, function(err, users) {\n *     // we should now have 5 users\n * });\n */\nvar times = doLimit(timeLimit, Infinity);\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.\n *\n * @name timesSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n */\nvar timesSeries = doLimit(timeLimit, 1);\n\n/**\n * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n * element in series, each step potentially mutating an `accumulator` value.\n * The type of the accumulator defaults to the type of collection passed in.\n *\n * @name transform\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n * it will default to an empty Object or Array, depending on the type of `coll`\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * collection that potentially modifies the accumulator.\n * Invoked with (accumulator, item, key, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the transformed accumulator.\n * Invoked with (err, result).\n * @example\n *\n * async.transform([1,2,3], function(acc, item, index, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         acc.push(item * 2)\n *         callback(null)\n *     });\n * }, function(err, result) {\n *     // result is now equal to [2, 4, 6]\n * });\n *\n * @example\n *\n * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {\n *     setImmediate(function () {\n *         obj[key] = val * 2;\n *         callback();\n *     })\n * }, function (err, result) {\n *     // result is equal to {a: 2, b: 4, c: 6}\n * })\n */\nfunction transform (coll, accumulator, iteratee, callback) {\n    if (arguments.length <= 3) {\n        callback = iteratee;\n        iteratee = accumulator;\n        accumulator = isArray(coll) ? [] : {};\n    }\n    callback = once(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n\n    eachOf(coll, function(v, k, cb) {\n        _iteratee(accumulator, v, k, cb);\n    }, function(err) {\n        callback(err, accumulator);\n    });\n}\n\n/**\n * It runs each task in series but stops whenever any of the functions were\n * successful. If one of the tasks were successful, the `callback` will be\n * passed the result of the successful task. If all tasks fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name tryEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection containing functions to\n * run, each function is passed a `callback(err, result)` it must call on\n * completion with an error `err` (which can be `null`) and an optional `result`\n * value.\n * @param {Function} [callback] - An optional callback which is called when one\n * of the tasks has succeeded, or all have failed. It receives the `err` and\n * `result` arguments of the last attempt at completing the `task`. Invoked with\n * (err, results).\n * @example\n * async.tryEach([\n *     function getDataFromFirstWebsite(callback) {\n *         // Try getting the data from the first website\n *         callback(err, data);\n *     },\n *     function getDataFromSecondWebsite(callback) {\n *         // First website failed,\n *         // Try getting the data from the backup website\n *         callback(err, data);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     Now do something with the data.\n * });\n *\n */\nfunction tryEach(tasks, callback) {\n    var error = null;\n    var result;\n    callback = callback || noop;\n    eachSeries(tasks, function(task, callback) {\n        wrapAsync(task)(function (err, res/*, ...args*/) {\n            if (arguments.length > 2) {\n                result = slice(arguments, 1);\n            } else {\n                result = res;\n            }\n            error = err;\n            callback(!err);\n        });\n    }, function () {\n        callback(error, result);\n    });\n}\n\n/**\n * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,\n * unmemoized form. Handy for testing.\n *\n * @name unmemoize\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.memoize]{@link module:Utils.memoize}\n * @category Util\n * @param {AsyncFunction} fn - the memoized function\n * @returns {AsyncFunction} a function that calls the original unmemoized function\n */\nfunction unmemoize(fn) {\n    return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n    };\n}\n\n/**\n * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs.\n *\n * @name whilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns undefined\n * @example\n *\n * var count = 0;\n * async.whilst(\n *     function() { return count < 5; },\n *     function(callback) {\n *         count++;\n *         setTimeout(function() {\n *             callback(null, count);\n *         }, 1000);\n *     },\n *     function (err, n) {\n *         // 5 seconds have passed, n = 5\n *     }\n * );\n */\nfunction whilst(test, iteratee, callback) {\n    callback = onlyOnce(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n    if (!test()) return callback(null);\n    var next = function(err/*, ...args*/) {\n        if (err) return callback(err);\n        if (test()) return _iteratee(next);\n        var args = slice(arguments, 1);\n        callback.apply(null, [null].concat(args));\n    };\n    _iteratee(next);\n}\n\n/**\n * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs. `callback` will be passed an error and any\n * arguments passed to the final `iteratee`'s callback.\n *\n * The inverse of [whilst]{@link module:ControlFlow.whilst}.\n *\n * @name until\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n */\nfunction until(test, iteratee, callback) {\n    whilst(function() {\n        return !test.apply(this, arguments);\n    }, iteratee, callback);\n}\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns undefined\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nvar waterfall = function(tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        var task = wrapAsync(tasks[taskIndex++]);\n        args.push(onlyOnce(next));\n        task.apply(null, args);\n    }\n\n    function next(err/*, ...args*/) {\n        if (err || taskIndex === tasks.length) {\n            return callback.apply(null, arguments);\n        }\n        nextTask(slice(arguments, 1));\n    }\n\n    nextTask([]);\n};\n\n/**\n * An \"async function\" in the context of Async is an asynchronous function with\n * a variable number of parameters, with the final parameter being a callback.\n * (`function (arg1, arg2, ..., callback) {}`)\n * The final callback is of the form `callback(err, results...)`, which must be\n * called once the function is completed.  The callback should be called with a\n * Error as its first argument to signal that an error occurred.\n * Otherwise, if no error occurred, it should be called with `null` as the first\n * argument, and any additional `result` arguments that may apply, to signal\n * successful completion.\n * The callback must be called exactly once, ideally on a later tick of the\n * JavaScript event loop.\n *\n * This type of function is also referred to as a \"Node-style async function\",\n * or a \"continuation passing-style function\" (CPS). Most of the methods of this\n * library are themselves CPS/Node-style async functions, or functions that\n * return CPS/Node-style async functions.\n *\n * Wherever we accept a Node-style async function, we also directly accept an\n * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.\n * In this case, the `async` function will not be passed a final callback\n * argument, and any thrown error will be used as the `err` argument of the\n * implicit callback, and the return value will be used as the `result` value.\n * (i.e. a `rejected` of the returned Promise becomes the `err` callback\n * argument, and a `resolved` value becomes the `result`.)\n *\n * Note, due to JavaScript limitations, we can only detect native `async`\n * functions and not transpilied implementations.\n * Your environment must have `async`/`await` support for this to work.\n * (e.g. Node > v7.6, or a recent version of a modern browser).\n * If you are using `async` functions through a transpiler (e.g. Babel), you\n * must still wrap the function with [asyncify]{@link module:Utils.asyncify},\n * because the `async function` will be compiled to an ordinary function that\n * returns a promise.\n *\n * @typedef {Function} AsyncFunction\n * @static\n */\n\n/**\n * Async is a utility module which provides straight-forward, powerful functions\n * for working with asynchronous JavaScript. Although originally designed for\n * use with [Node.js](http://nodejs.org) and installable via\n * `npm install --save async`, it can also be used directly in the browser.\n * @module async\n * @see AsyncFunction\n */\n\n\n/**\n * A collection of `async` functions for manipulating collections, such as\n * arrays and objects.\n * @module Collections\n */\n\n/**\n * A collection of `async` functions for controlling the flow through a script.\n * @module ControlFlow\n */\n\n/**\n * A collection of `async` utility functions.\n * @module Utils\n */\n\nvar index = {\n    apply: apply,\n    applyEach: applyEach,\n    applyEachSeries: applyEachSeries,\n    asyncify: asyncify,\n    auto: auto,\n    autoInject: autoInject,\n    cargo: cargo,\n    compose: compose,\n    concat: concat,\n    concatLimit: concatLimit,\n    concatSeries: concatSeries,\n    constant: constant,\n    detect: detect,\n    detectLimit: detectLimit,\n    detectSeries: detectSeries,\n    dir: dir,\n    doDuring: doDuring,\n    doUntil: doUntil,\n    doWhilst: doWhilst,\n    during: during,\n    each: eachLimit,\n    eachLimit: eachLimit$1,\n    eachOf: eachOf,\n    eachOfLimit: eachOfLimit,\n    eachOfSeries: eachOfSeries,\n    eachSeries: eachSeries,\n    ensureAsync: ensureAsync,\n    every: every,\n    everyLimit: everyLimit,\n    everySeries: everySeries,\n    filter: filter,\n    filterLimit: filterLimit,\n    filterSeries: filterSeries,\n    forever: forever,\n    groupBy: groupBy,\n    groupByLimit: groupByLimit,\n    groupBySeries: groupBySeries,\n    log: log,\n    map: map,\n    mapLimit: mapLimit,\n    mapSeries: mapSeries,\n    mapValues: mapValues,\n    mapValuesLimit: mapValuesLimit,\n    mapValuesSeries: mapValuesSeries,\n    memoize: memoize,\n    nextTick: nextTick,\n    parallel: parallelLimit,\n    parallelLimit: parallelLimit$1,\n    priorityQueue: priorityQueue,\n    queue: queue$1,\n    race: race,\n    reduce: reduce,\n    reduceRight: reduceRight,\n    reflect: reflect,\n    reflectAll: reflectAll,\n    reject: reject,\n    rejectLimit: rejectLimit,\n    rejectSeries: rejectSeries,\n    retry: retry,\n    retryable: retryable,\n    seq: seq,\n    series: series,\n    setImmediate: setImmediate$1,\n    some: some,\n    someLimit: someLimit,\n    someSeries: someSeries,\n    sortBy: sortBy,\n    timeout: timeout,\n    times: times,\n    timesLimit: timeLimit,\n    timesSeries: timesSeries,\n    transform: transform,\n    tryEach: tryEach,\n    unmemoize: unmemoize,\n    until: until,\n    waterfall: waterfall,\n    whilst: whilst,\n\n    // aliases\n    all: every,\n    allLimit: everyLimit,\n    allSeries: everySeries,\n    any: some,\n    anyLimit: someLimit,\n    anySeries: someSeries,\n    find: detect,\n    findLimit: detectLimit,\n    findSeries: detectSeries,\n    forEach: eachLimit,\n    forEachSeries: eachSeries,\n    forEachLimit: eachLimit$1,\n    forEachOf: eachOf,\n    forEachOfSeries: eachOfSeries,\n    forEachOfLimit: eachOfLimit,\n    inject: reduce,\n    foldl: reduce,\n    foldr: reduceRight,\n    select: filter,\n    selectLimit: filterLimit,\n    selectSeries: filterSeries,\n    wrapSync: asyncify\n};\n\nexports['default'] = index;\nexports.apply = apply;\nexports.applyEach = applyEach;\nexports.applyEachSeries = applyEachSeries;\nexports.asyncify = asyncify;\nexports.auto = auto;\nexports.autoInject = autoInject;\nexports.cargo = cargo;\nexports.compose = compose;\nexports.concat = concat;\nexports.concatLimit = concatLimit;\nexports.concatSeries = concatSeries;\nexports.constant = constant;\nexports.detect = detect;\nexports.detectLimit = detectLimit;\nexports.detectSeries = detectSeries;\nexports.dir = dir;\nexports.doDuring = doDuring;\nexports.doUntil = doUntil;\nexports.doWhilst = doWhilst;\nexports.during = during;\nexports.each = eachLimit;\nexports.eachLimit = eachLimit$1;\nexports.eachOf = eachOf;\nexports.eachOfLimit = eachOfLimit;\nexports.eachOfSeries = eachOfSeries;\nexports.eachSeries = eachSeries;\nexports.ensureAsync = ensureAsync;\nexports.every = every;\nexports.everyLimit = everyLimit;\nexports.everySeries = everySeries;\nexports.filter = filter;\nexports.filterLimit = filterLimit;\nexports.filterSeries = filterSeries;\nexports.forever = forever;\nexports.groupBy = groupBy;\nexports.groupByLimit = groupByLimit;\nexports.groupBySeries = groupBySeries;\nexports.log = log;\nexports.map = map;\nexports.mapLimit = mapLimit;\nexports.mapSeries = mapSeries;\nexports.mapValues = mapValues;\nexports.mapValuesLimit = mapValuesLimit;\nexports.mapValuesSeries = mapValuesSeries;\nexports.memoize = memoize;\nexports.nextTick = nextTick;\nexports.parallel = parallelLimit;\nexports.parallelLimit = parallelLimit$1;\nexports.priorityQueue = priorityQueue;\nexports.queue = queue$1;\nexports.race = race;\nexports.reduce = reduce;\nexports.reduceRight = reduceRight;\nexports.reflect = reflect;\nexports.reflectAll = reflectAll;\nexports.reject = reject;\nexports.rejectLimit = rejectLimit;\nexports.rejectSeries = rejectSeries;\nexports.retry = retry;\nexports.retryable = retryable;\nexports.seq = seq;\nexports.series = series;\nexports.setImmediate = setImmediate$1;\nexports.some = some;\nexports.someLimit = someLimit;\nexports.someSeries = someSeries;\nexports.sortBy = sortBy;\nexports.timeout = timeout;\nexports.times = times;\nexports.timesLimit = timeLimit;\nexports.timesSeries = timesSeries;\nexports.transform = transform;\nexports.tryEach = tryEach;\nexports.unmemoize = unmemoize;\nexports.until = until;\nexports.waterfall = waterfall;\nexports.whilst = whilst;\nexports.all = every;\nexports.allLimit = everyLimit;\nexports.allSeries = everySeries;\nexports.any = some;\nexports.anyLimit = someLimit;\nexports.anySeries = someSeries;\nexports.find = detect;\nexports.findLimit = detectLimit;\nexports.findSeries = detectSeries;\nexports.forEach = eachLimit;\nexports.forEachSeries = eachSeries;\nexports.forEachLimit = eachLimit$1;\nexports.forEachOf = eachOf;\nexports.forEachOfSeries = eachOfSeries;\nexports.forEachOfLimit = eachOfLimit;\nexports.inject = reduce;\nexports.foldl = reduce;\nexports.foldr = reduceRight;\nexports.select = filter;\nexports.selectLimit = filterLimit;\nexports.selectSeries = filterSeries;\nexports.wrapSync = asyncify;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","'use strict'\nconst Transaction = require('ethereumjs-tx')\nconst ethUtil = require('ethereumjs-util')\nconst Block = require('./')\nconst blockHeaderFromRpc = require('./header-from-rpc')\n\nmodule.exports = blockFromRpc\n\n/**\n * Creates a new block object from Ethereum JSON RPC.\n * @param {Object} blockParams - Ethereum JSON RPC of block (eth_getBlockByNumber)\n * @param {Array.<Object>} Optional list of Ethereum JSON RPC of uncles (eth_getUncleByBlockHashAndIndex)\n */\nfunction blockFromRpc (blockParams, uncles) {\n  uncles = uncles || []\n  const block = new Block({\n    transactions: [],\n    uncleHeaders: []\n  })\n  block.header = blockHeaderFromRpc(blockParams)\n\n  block.transactions = (blockParams.transactions || []).map(function (_txParams) {\n    const txParams = normalizeTxParams(_txParams)\n    // override from address\n    const fromAddress = ethUtil.toBuffer(txParams.from)\n    delete txParams.from\n    const tx = new Transaction(txParams)\n    tx._from = fromAddress\n    tx.getSenderAddress = function () { return fromAddress }\n    // override hash\n    const txHash = ethUtil.toBuffer(txParams.hash)\n    tx.hash = function () { return txHash }\n    return tx\n  })\n  block.uncleHeaders = uncles.map(function (uncleParams) {\n    return blockHeaderFromRpc(uncleParams)\n  })\n\n  return block\n}\n\nfunction normalizeTxParams (_txParams) {\n  const txParams = Object.assign({}, _txParams)\n  // hot fix for https://github.com/ethereumjs/ethereumjs-util/issues/40\n  txParams.gasLimit = (txParams.gasLimit === undefined) ? txParams.gas : txParams.gasLimit\n  txParams.data = (txParams.data === undefined) ? txParams.input : txParams.data\n  // strict byte length checking\n  txParams.to = txParams.to ? ethUtil.setLengthLeft(ethUtil.toBuffer(txParams.to), 20) : null\n  // v as raw signature value {0,1}\n  txParams.v = txParams.v < 27 ? txParams.v + 27 : txParams.v\n  return txParams\n}\n","'use strict'\nconst BlockHeader = require('./header')\nconst ethUtil = require('ethereumjs-util')\n\nmodule.exports = blockHeaderFromRpc\n\n/**\n * Creates a new block header object from Ethereum JSON RPC.\n * @param {Object} blockParams - Ethereum JSON RPC of block (eth_getBlockByNumber)\n */\nfunction blockHeaderFromRpc (blockParams) {\n  const blockHeader = new BlockHeader({\n    parentHash: blockParams.parentHash,\n    uncleHash: blockParams.sha3Uncles,\n    coinbase: blockParams.miner,\n    stateRoot: blockParams.stateRoot,\n    transactionsTrie: blockParams.transactionsRoot,\n    receiptTrie: blockParams.receiptRoot || blockParams.receiptsRoot || ethUtil.SHA3_NULL,\n    bloom: blockParams.logsBloom,\n    difficulty: blockParams.difficulty,\n    number: blockParams.number,\n    gasLimit: blockParams.gasLimit,\n    gasUsed: blockParams.gasUsed,\n    timestamp: blockParams.timestamp,\n    extraData: blockParams.extraData,\n    mixHash: blockParams.mixHash,\n    nonce: blockParams.nonce\n  })\n\n  // override hash incase something was missing\n  blockHeader.hash = function () {\n    return ethUtil.toBuffer(blockParams.hash)\n  }\n\n  return blockHeader\n}\n","const Common = require('ethereumjs-common').default\nconst utils = require('ethereumjs-util')\nconst BN = utils.BN\n  /**\n   * An object that repersents the block header\n   * @constructor\n   * @param {Array} data raw data, deserialized\n   * @param {Array} opts Options\n   * @param {String|Number} opts.chain The chain for the block header [default: 'mainnet']\n   * @param {String} opts.hardfork Hardfork for the block header [default: null, block number-based behaviour]\n   * @param {Object} opts.common Alternatively pass a Common instance instead of setting chain/hardfork directly\n   * @prop {Buffer} parentHash the blocks' parent's hash\n   * @prop {Buffer} uncleHash sha3(rlp_encode(uncle_list))\n   * @prop {Buffer} coinbase the miner address\n   * @prop {Buffer} stateRoot The root of a Merkle Patricia tree\n   * @prop {Buffer} transactionTrie the root of a Trie containing the transactions\n   * @prop {Buffer} receiptTrie the root of a Trie containing the transaction Reciept\n   * @prop {Buffer} bloom\n   * @prop {Buffer} difficulty\n   * @prop {Buffer} number the block's height\n   * @prop {Buffer} gasLimit\n   * @prop {Buffer} gasUsed\n   * @prop {Buffer} timestamp\n   * @prop {Buffer} extraData\n   * @prop {Array.<Buffer>} raw an array of buffers containing the raw blocks.\n   */\nvar BlockHeader = module.exports = function (data, opts) {\n  opts = opts || {}\n\n  if (opts.common) {\n    if (opts.chain) {\n      throw new Error('Instantiation with both opts.common and opts.chain parameter not allowed!')\n    }\n    this._common = opts.common\n  } else {\n    let chain = opts.chain ? opts.chain : 'mainnet'\n    let hardfork = opts.hardfork ? opts.hardfork : null\n    this._common = new Common(chain, hardfork)\n  }\n\n  var fields = [{\n    name: 'parentHash',\n    length: 32,\n    default: utils.zeros(32)\n  }, {\n    name: 'uncleHash',\n    default: utils.SHA3_RLP_ARRAY\n  }, {\n    name: 'coinbase',\n    length: 20,\n    default: utils.zeros(20)\n  }, {\n    name: 'stateRoot',\n    length: 32,\n    default: utils.zeros(32)\n  }, {\n    name: 'transactionsTrie',\n    length: 32,\n    default: utils.SHA3_RLP\n  }, {\n    name: 'receiptTrie',\n    length: 32,\n    default: utils.SHA3_RLP\n  }, {\n    name: 'bloom',\n    default: utils.zeros(256)\n  }, {\n    name: 'difficulty',\n    default: Buffer.from([])\n  }, {\n    name: 'number',\n    // TODO: params.homeSteadForkNumber.v left for legacy reasons, replace on future release\n    default: utils.intToBuffer(1150000)\n  }, {\n    name: 'gasLimit',\n    default: Buffer.from('ffffffffffffff', 'hex')\n  }, {\n    name: 'gasUsed',\n    empty: true,\n    default: Buffer.from([])\n  }, {\n    name: 'timestamp',\n    default: Buffer.from([])\n  }, {\n    name: 'extraData',\n    allowZero: true,\n    empty: true,\n    default: Buffer.from([])\n  }, {\n    name: 'mixHash',\n    default: utils.zeros(32)\n      // length: 32\n  }, {\n    name: 'nonce',\n    default: utils.zeros(8) // sha3(42)\n  }]\n  utils.defineProperties(this, fields, data)\n}\n\n/**\n * Returns the canoncical difficulty of the block\n * @method canonicalDifficulty\n * @param {Block} parentBlock the parent `Block` of the this header\n * @return {BN}\n */\nBlockHeader.prototype.canonicalDifficulty = function (parentBlock) {\n  const hardfork = this._common.hardfork() || this._common.activeHardfork(utils.bufferToInt(this.number))\n  const blockTs = new BN(this.timestamp)\n  const parentTs = new BN(parentBlock.header.timestamp)\n  const parentDif = new BN(parentBlock.header.difficulty)\n  const minimumDifficulty = new BN(this._common.param('pow', 'minimumDifficulty', hardfork))\n  var offset = parentDif.div(new BN(this._common.param('pow', 'difficultyBoundDivisor', hardfork)))\n  var num = new BN(this.number)\n  var a\n  var cutoff\n  var dif\n\n  if (this._common.hardforkGteHardfork(hardfork, 'byzantium')) {\n    // max((2 if len(parent.uncles) else 1) - ((timestamp - parent.timestamp) // 9), -99) (EIP100)\n    var uncleAddend = parentBlock.header.uncleHash.equals(utils.SHA3_RLP_ARRAY) ? 1 : 2\n    a = blockTs.sub(parentTs).idivn(9).ineg().iaddn(uncleAddend)\n    cutoff = new BN(-99)\n    // MAX(cutoff, a)\n    if (cutoff.cmp(a) === 1) {\n      a = cutoff\n    }\n    dif = parentDif.add(offset.mul(a))\n  }\n\n  if (this._common.hardforkGteHardfork(hardfork, 'constantinople')) {\n    // Constantinople difficulty bomb delay (EIP1234)\n    num.isubn(5000000)\n    if (num.ltn(0)) {\n      num = new BN(0)\n    }\n  } else if (this._common.hardforkGteHardfork(hardfork, 'byzantium')) {\n    // Byzantium difficulty bomb delay (EIP649)\n    num.isubn(3000000)\n    if (num.ltn(0)) {\n      num = new BN(0)\n    }\n  } else if (this._common.hardforkGteHardfork(hardfork, 'homestead')) {\n    // 1 - (block_timestamp - parent_timestamp) // 10\n    a = blockTs.sub(parentTs).idivn(10).ineg().iaddn(1)\n    cutoff = new BN(-99)\n    // MAX(cutoff, a)\n    if (cutoff.cmp(a) === 1) {\n      a = cutoff\n    }\n    dif = parentDif.add(offset.mul(a))\n  } else {\n    // pre-homestead\n    if (parentTs.addn(this._common.param('pow', 'durationLimit', hardfork)).cmp(blockTs) === 1) {\n      dif = offset.add(parentDif)\n    } else {\n      dif = parentDif.sub(offset)\n    }\n  }\n\n  var exp = num.idivn(100000).isubn(2)\n  if (!exp.isNeg()) {\n    dif.iadd(new BN(2).pow(exp))\n  }\n\n  if (dif.cmp(minimumDifficulty) === -1) {\n    dif = minimumDifficulty\n  }\n\n  return dif\n}\n\n/**\n * checks that the block's `difficuly` matches the canonical difficulty\n * @method validateDifficulty\n * @param {Block} parentBlock this block's parent\n * @return {Boolean}\n */\nBlockHeader.prototype.validateDifficulty = function (parentBlock) {\n  const dif = this.canonicalDifficulty(parentBlock)\n  return dif.cmp(new BN(this.difficulty)) === 0\n}\n\n/**\n * Validates the gasLimit\n * @method validateGasLimit\n * @param {Block} parentBlock this block's parent\n * @returns {Boolean}\n */\nBlockHeader.prototype.validateGasLimit = function (parentBlock) {\n  const pGasLimit = new BN(parentBlock.header.gasLimit)\n  const gasLimit = new BN(this.gasLimit)\n  const hardfork = this._common.hardfork() ? this._common.hardfork() : this._common.activeHardfork(this.number)\n  const a = pGasLimit.div(new BN(this._common.param('gasConfig', 'gasLimitBoundDivisor', hardfork)))\n  const maxGasLimit = pGasLimit.add(a)\n  const minGasLimit = pGasLimit.sub(a)\n\n  return gasLimit.lt(maxGasLimit) && gasLimit.gt(minGasLimit) && gasLimit.gte(this._common.param('gasConfig', 'minGasLimit', hardfork))\n}\n\n/**\n * Validates the entire block header\n * @method validate\n * @param {Blockchain} blockChain the blockchain that this block is validating against\n * @param {Bignum} [height] if this is an uncle header, this is the height of the block that is including it\n * @param {Function} cb the callback function. The callback is given an `error` if the block is invalid\n */\nBlockHeader.prototype.validate = function (blockchain, height, cb) {\n  var self = this\n  if (arguments.length === 2) {\n    cb = height\n    height = false\n  }\n\n  if (this.isGenesis()) {\n    return cb()\n  }\n\n  // find the blocks parent\n  blockchain.getBlock(self.parentHash, function (err, parentBlock) {\n    if (err) {\n      return cb('could not find parent block')\n    }\n\n    self.parentBlock = parentBlock\n\n    var number = new BN(self.number)\n    if (number.cmp(new BN(parentBlock.header.number).iaddn(1)) !== 0) {\n      return cb('invalid number')\n    }\n\n    if (height) {\n      var dif = height.sub(new BN(parentBlock.header.number))\n      if (!(dif.cmpn(8) === -1 && dif.cmpn(1) === 1)) {\n        return cb('uncle block has a parent that is too old or to young')\n      }\n    }\n\n    if (!self.validateDifficulty(parentBlock)) {\n      return cb('invalid Difficulty')\n    }\n\n    if (!self.validateGasLimit(parentBlock)) {\n      return cb('invalid gas limit')\n    }\n\n    if (utils.bufferToInt(parentBlock.header.number) + 1 !== utils.bufferToInt(self.number)) {\n      return cb('invalid heigth')\n    }\n\n    if (utils.bufferToInt(self.timestamp) <= utils.bufferToInt(parentBlock.header.timestamp)) {\n      return cb('invalid timestamp')\n    }\n\n    const hardfork = self._common.hardfork() ? self._common.hardfork() : self._common.activeHardfork(height)\n    if (self.extraData.length > self._common.param('vm', 'maxExtraDataSize', hardfork)) {\n      return cb('invalid amount of extra data')\n    }\n\n    cb()\n  })\n}\n\n/**\n * Returns the sha3 hash of the blockheader\n * @method hash\n * @return {Buffer}\n */\nBlockHeader.prototype.hash = function () {\n  return utils.rlphash(this.raw)\n}\n\n/**\n * checks if the blockheader is a genesis header\n * @method isGenesis\n * @return {Boolean}\n */\nBlockHeader.prototype.isGenesis = function () {\n  return this.number.toString('hex') === ''\n}\n\n/**\n * turns the header into the canonical genesis block header\n * @method setGenesisParams\n */\nBlockHeader.prototype.setGenesisParams = function () {\n  this.timestamp = this._common.genesis().timestamp\n  this.gasLimit = this._common.genesis().gasLimit\n  this.difficulty = this._common.genesis().difficulty\n  this.extraData = this._common.genesis().extraData\n  this.nonce = this._common.genesis().nonce\n  this.stateRoot = this._common.genesis().stateRoot\n  this.number = Buffer.from([])\n}\n","const Common = require('ethereumjs-common').default\nconst ethUtil = require('ethereumjs-util')\nconst Tx = require('ethereumjs-tx')\nconst Trie = require('merkle-patricia-tree')\nconst BN = ethUtil.BN\nconst rlp = ethUtil.rlp\nconst async = require('async')\nconst BlockHeader = require('./header')\n\n/**\n * Creates a new block object\n * @constructor the raw serialized or the deserialized block.\n * @param {Array|Buffer|Object} data\n * @param {Array} opts Options\n * @param {String|Number} opts.chain The chain for the block [default: 'mainnet']\n * @param {String} opts.hardfork Hardfork for the block [default: null, block number-based behaviour]\n * @param {Object} opts.common Alternatively pass a Common instance (ethereumjs-common) instead of setting chain/hardfork directly\n * @prop {Header} header the block's header\n * @prop {Array.<Header>} uncleList an array of uncle headers\n * @prop {Array.<Buffer>} raw an array of buffers containing the raw blocks.\n */\nvar Block = module.exports = function (data, opts) {\n  opts = opts || {}\n\n  if (opts.common) {\n    if (opts.chain) {\n      throw new Error('Instantiation with both opts.common and opts.chain parameter not allowed!')\n    }\n    this._common = opts.common\n  } else {\n    let chain = opts.chain ? opts.chain : 'mainnet'\n    let hardfork = opts.hardfork ? opts.hardfork : null\n    this._common = new Common(chain, hardfork)\n  }\n\n  this.transactions = []\n  this.uncleHeaders = []\n  this._inBlockChain = false\n  this.txTrie = new Trie()\n\n  Object.defineProperty(this, 'raw', {\n    get: function () {\n      return this.serialize(false)\n    }\n  })\n\n  var rawTransactions, rawUncleHeaders\n\n  // defaults\n  if (!data) {\n    data = [[], [], []]\n  }\n\n  if (Buffer.isBuffer(data)) {\n    data = rlp.decode(data)\n  }\n\n  if (Array.isArray(data)) {\n    this.header = new BlockHeader(data[0], opts)\n    rawTransactions = data[1]\n    rawUncleHeaders = data[2]\n  } else {\n    this.header = new BlockHeader(data.header, opts)\n    rawTransactions = data.transactions || []\n    rawUncleHeaders = data.uncleHeaders || []\n  }\n\n  // parse uncle headers\n  for (var i = 0; i < rawUncleHeaders.length; i++) {\n    this.uncleHeaders.push(new BlockHeader(rawUncleHeaders[i], opts))\n  }\n\n  // parse transactions\n  for (i = 0; i < rawTransactions.length; i++) {\n    var tx = new Tx(rawTransactions[i])\n    tx._homestead = true\n    this.transactions.push(tx)\n  }\n}\n\nBlock.Header = BlockHeader\n\n/**\n * Produces a hash the RLP of the block\n * @method hash\n */\nBlock.prototype.hash = function () {\n  return this.header.hash()\n}\n\n/**\n * Determines if a given block is the genesis block\n * @method isGenisis\n * @return Boolean\n */\nBlock.prototype.isGenesis = function () {\n  return this.header.isGenesis()\n}\n\n/**\n * turns the block into the canonical genesis block\n * @method setGenesisParams\n */\nBlock.prototype.setGenesisParams = function () {\n  this.header.setGenesisParams()\n}\n\n/**\n * Produces a serialization of the block.\n * @method serialize\n * @param {Boolean} rlpEncode whether to rlp encode the block or not\n */\nBlock.prototype.serialize = function (rlpEncode) {\n  var raw = [this.header.raw, [],\n    []\n  ]\n\n  // rlpEnode defaults to true\n  if (typeof rlpEncode === 'undefined') {\n    rlpEncode = true\n  }\n\n  this.transactions.forEach(function (tx) {\n    raw[1].push(tx.raw)\n  })\n\n  this.uncleHeaders.forEach(function (uncle) {\n    raw[2].push(uncle.raw)\n  })\n\n  return rlpEncode ? rlp.encode(raw) : raw\n}\n\n/**\n * Generate transaction trie. The tx trie must be generated before the transaction trie can\n * be validated with `validateTransactionTrie`\n * @method genTxTrie\n * @param {Function} cb the callback\n */\nBlock.prototype.genTxTrie = function (cb) {\n  var i = 0\n  var self = this\n\n  async.eachSeries(this.transactions, function (tx, done) {\n    self.txTrie.put(rlp.encode(i), tx.serialize(), done)\n    i++\n  }, cb)\n}\n\n/**\n * Validates the transaction trie\n * @method validateTransactionTrie\n * @return {Boolean}\n */\nBlock.prototype.validateTransactionsTrie = function () {\n  var txT = this.header.transactionsTrie.toString('hex')\n  if (this.transactions.length) {\n    return txT === this.txTrie.root.toString('hex')\n  } else {\n    return txT === ethUtil.SHA3_RLP.toString('hex')\n  }\n}\n\n/**\n * Validates the transactions\n * @method validateTransactions\n * @param {Boolean} [stringError=false] whether to return a string with a dscription of why the validation failed or return a Bloolean\n * @return {Boolean}\n */\nBlock.prototype.validateTransactions = function (stringError) {\n  var errors = []\n\n  this.transactions.forEach(function (tx, i) {\n    var error = tx.validate(true)\n    if (error) {\n      errors.push(error + ' at tx ' + i)\n    }\n  })\n\n  if (stringError === undefined || stringError === false) {\n    return errors.length === 0\n  } else {\n    return arrayToString(errors)\n  }\n}\n\n/**\n * Validates the entire block. Returns a string to the callback if block is invalid\n * @method validate\n * @param {BlockChain} blockChain the blockchain that this block wants to be part of\n * @param {Function} cb the callback which is given a `String` if the block is not valid\n */\nBlock.prototype.validate = function (blockChain, cb) {\n  var self = this\n  var errors = []\n\n  async.parallel([\n    // validate uncles\n    self.validateUncles.bind(self, blockChain),\n    // validate block\n    self.header.validate.bind(self.header, blockChain),\n    // generate the transaction trie\n    self.genTxTrie.bind(self)\n  ], function (err) {\n    if (err) {\n      errors.push(err)\n    }\n\n    if (!self.validateTransactionsTrie()) {\n      errors.push('invalid transaction trie')\n    }\n\n    var txErrors = self.validateTransactions(true)\n    if (txErrors !== '') {\n      errors.push(txErrors)\n    }\n\n    if (!self.validateUnclesHash()) {\n      errors.push('invalid uncle hash')\n    }\n\n    cb(arrayToString(errors))\n  })\n}\n\n/**\n * Validates the uncle's hash\n * @method validateUncleHash\n * @return {Boolean}\n */\nBlock.prototype.validateUnclesHash = function () {\n  var raw = []\n  this.uncleHeaders.forEach(function (uncle) {\n    raw.push(uncle.raw)\n  })\n\n  raw = rlp.encode(raw)\n  return ethUtil.sha3(raw).toString('hex') === this.header.uncleHash.toString('hex')\n}\n\n/**\n * Validates the uncles that are in the block if any. Returns a string to the callback if uncles are invalid\n * @method validateUncles\n * @param {Blockchain} blockChaina an instance of the Blockchain\n * @param {Function} cb the callback\n */\nBlock.prototype.validateUncles = function (blockChain, cb) {\n  if (this.isGenesis()) {\n    return cb()\n  }\n\n  var self = this\n\n  if (self.uncleHeaders.length > 2) {\n    return cb('too many uncle headers')\n  }\n\n  var uncleHashes = self.uncleHeaders.map(function (header) {\n    return header.hash().toString('hex')\n  })\n\n  if (!((new Set(uncleHashes)).size === uncleHashes.length)) {\n    return cb('duplicate uncles')\n  }\n\n  async.each(self.uncleHeaders, function (uncle, cb2) {\n    var height = new BN(self.header.number)\n    async.parallel([\n      uncle.validate.bind(uncle, blockChain, height),\n      // check to make sure the uncle is not already in the blockchain\n      function (cb3) {\n        blockChain.getDetails(uncle.hash(), function (err, blockInfo) {\n          // TODO: remove uncles from BC\n          if (blockInfo && blockInfo.isUncle) {\n            cb3(err || 'uncle already included')\n          } else {\n            cb3()\n          }\n        })\n      }\n    ], cb2)\n  }, cb)\n}\n\n/**\n * Converts the block toJSON\n * @method toJSON\n * @param {Bool} labeled whether to create an labeled object or an array\n * @return {Object}\n */\nBlock.prototype.toJSON = function (labeled) {\n  if (labeled) {\n    var obj = {\n      header: this.header.toJSON(true),\n      transactions: [],\n      uncleHeaders: []\n    }\n\n    this.transactions.forEach(function (tx) {\n      obj.transactions.push(tx.toJSON(labeled))\n    })\n\n    this.uncleHeaders.forEach(function (uh) {\n      obj.uncleHeaders.push(uh.toJSON())\n    })\n    return obj\n  } else {\n    return ethUtil.baToJSON(this.raw)\n  }\n}\n\nfunction arrayToString (array) {\n  try {\n    return array.reduce(function (str, err) {\n      if (str) {\n        str += ' '\n      }\n      return str + err\n    })\n  } catch (e) {\n    return ''\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.chains = void 0;\nexports.chains = {\n    names: {\n        '1': 'mainnet',\n        '3': 'ropsten',\n        '4': 'rinkeby',\n        '42': 'kovan',\n        '5': 'goerli',\n    },\n    mainnet: require('./mainnet.json'),\n    ropsten: require('./ropsten.json'),\n    rinkeby: require('./rinkeby.json'),\n    kovan: require('./kovan.json'),\n    goerli: require('./goerli.json'),\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hardforks = void 0;\nexports.hardforks = [\n    ['chainstart', require('./chainstart.json')],\n    ['homestead', require('./homestead.json')],\n    ['dao', require('./dao.json')],\n    ['tangerineWhistle', require('./tangerineWhistle.json')],\n    ['spuriousDragon', require('./spuriousDragon.json')],\n    ['byzantium', require('./byzantium.json')],\n    ['constantinople', require('./constantinople.json')],\n    ['petersburg', require('./petersburg.json')],\n    ['istanbul', require('./istanbul.json')],\n    ['muirGlacier', require('./muirGlacier.json')],\n];\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar chains_1 = require(\"./chains\");\nvar hardforks_1 = require(\"./hardforks\");\n/**\n * Common class to access chain and hardfork parameters\n */\nvar Common = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param chain String ('mainnet') or Number (1) chain\n     * @param hardfork String identifier ('byzantium') for hardfork (optional)\n     * @param supportedHardforks Limit parameter returns to the given hardforks (optional)\n     */\n    function Common(chain, hardfork, supportedHardforks) {\n        this._chainParams = this.setChain(chain);\n        this._hardfork = null;\n        this._supportedHardforks = supportedHardforks === undefined ? [] : supportedHardforks;\n        if (hardfork) {\n            this.setHardfork(hardfork);\n        }\n    }\n    /**\n     * Creates a Common object for a custom chain, based on a standard one. It uses all the [[Chain]]\n     * params from [[baseChain]] except the ones overridden in [[customChainParams]].\n     *\n     * @param baseChain The name (`mainnet`) or id (`1`) of a standard chain used to base the custom\n     * chain params on.\n     * @param customChainParams The custom parameters of the chain.\n     * @param hardfork String identifier ('byzantium') for hardfork (optional)\n     * @param supportedHardforks Limit parameter returns to the given hardforks (optional)\n     */\n    Common.forCustomChain = function (baseChain, customChainParams, hardfork, supportedHardforks) {\n        var standardChainParams = Common._getChainParams(baseChain);\n        return new Common(__assign(__assign({}, standardChainParams), customChainParams), hardfork, supportedHardforks);\n    };\n    Common._getChainParams = function (chain) {\n        if (typeof chain === 'number') {\n            if (chains_1.chains['names'][chain]) {\n                return chains_1.chains[chains_1.chains['names'][chain]];\n            }\n            throw new Error(\"Chain with ID \" + chain + \" not supported\");\n        }\n        if (chains_1.chains[chain]) {\n            return chains_1.chains[chain];\n        }\n        throw new Error(\"Chain with name \" + chain + \" not supported\");\n    };\n    /**\n     * Sets the chain\n     * @param chain String ('mainnet') or Number (1) chain\n     *     representation. Or, a Dictionary of chain parameters for a private network.\n     * @returns The dictionary with parameters set as chain\n     */\n    Common.prototype.setChain = function (chain) {\n        if (typeof chain === 'number' || typeof chain === 'string') {\n            this._chainParams = Common._getChainParams(chain);\n        }\n        else if (typeof chain === 'object') {\n            var required = ['networkId', 'genesis', 'hardforks', 'bootstrapNodes'];\n            for (var _i = 0, required_1 = required; _i < required_1.length; _i++) {\n                var param = required_1[_i];\n                if (chain[param] === undefined) {\n                    throw new Error(\"Missing required chain parameter: \" + param);\n                }\n            }\n            this._chainParams = chain;\n        }\n        else {\n            throw new Error('Wrong input format');\n        }\n        return this._chainParams;\n    };\n    /**\n     * Sets the hardfork to get params for\n     * @param hardfork String identifier ('byzantium')\n     */\n    Common.prototype.setHardfork = function (hardfork) {\n        if (!this._isSupportedHardfork(hardfork)) {\n            throw new Error(\"Hardfork \" + hardfork + \" not set as supported in supportedHardforks\");\n        }\n        var changed = false;\n        for (var _i = 0, hardforkChanges_1 = hardforks_1.hardforks; _i < hardforkChanges_1.length; _i++) {\n            var hfChanges = hardforkChanges_1[_i];\n            if (hfChanges[0] === hardfork) {\n                this._hardfork = hardfork;\n                changed = true;\n            }\n        }\n        if (!changed) {\n            throw new Error(\"Hardfork with name \" + hardfork + \" not supported\");\n        }\n    };\n    /**\n     * Internal helper function to choose between hardfork set and hardfork provided as param\n     * @param hardfork Hardfork given to function as a parameter\n     * @returns Hardfork chosen to be used\n     */\n    Common.prototype._chooseHardfork = function (hardfork, onlySupported) {\n        onlySupported = onlySupported === undefined ? true : onlySupported;\n        if (!hardfork) {\n            if (!this._hardfork) {\n                throw new Error('Method called with neither a hardfork set nor provided by param');\n            }\n            else {\n                hardfork = this._hardfork;\n            }\n        }\n        else if (onlySupported && !this._isSupportedHardfork(hardfork)) {\n            throw new Error(\"Hardfork \" + hardfork + \" not set as supported in supportedHardforks\");\n        }\n        return hardfork;\n    };\n    /**\n     * Internal helper function, returns the params for the given hardfork for the chain set\n     * @param hardfork Hardfork name\n     * @returns Dictionary with hardfork params\n     */\n    Common.prototype._getHardfork = function (hardfork) {\n        var hfs = this.hardforks();\n        for (var _i = 0, hfs_1 = hfs; _i < hfs_1.length; _i++) {\n            var hf = hfs_1[_i];\n            if (hf['name'] === hardfork)\n                return hf;\n        }\n        throw new Error(\"Hardfork \" + hardfork + \" not defined for chain \" + this.chainName());\n    };\n    /**\n     * Internal helper function to check if a hardfork is set to be supported by the library\n     * @param hardfork Hardfork name\n     * @returns True if hardfork is supported\n     */\n    Common.prototype._isSupportedHardfork = function (hardfork) {\n        if (this._supportedHardforks.length > 0) {\n            for (var _i = 0, _a = this._supportedHardforks; _i < _a.length; _i++) {\n                var supportedHf = _a[_i];\n                if (hardfork === supportedHf)\n                    return true;\n            }\n        }\n        else {\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Returns the parameter corresponding to a hardfork\n     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow', 'casper', 'sharding')\n     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)\n     * @param hardfork Hardfork name, optional if hardfork set\n     */\n    Common.prototype.param = function (topic, name, hardfork) {\n        hardfork = this._chooseHardfork(hardfork);\n        var value;\n        for (var _i = 0, hardforkChanges_2 = hardforks_1.hardforks; _i < hardforkChanges_2.length; _i++) {\n            var hfChanges = hardforkChanges_2[_i];\n            if (!hfChanges[1][topic]) {\n                throw new Error(\"Topic \" + topic + \" not defined\");\n            }\n            if (hfChanges[1][topic][name] !== undefined) {\n                value = hfChanges[1][topic][name].v;\n            }\n            if (hfChanges[0] === hardfork)\n                break;\n        }\n        if (value === undefined) {\n            throw new Error(topic + \" value for \" + name + \" not found\");\n        }\n        return value;\n    };\n    /**\n     * Returns a parameter for the hardfork active on block number\n     * @param topic Parameter topic\n     * @param name Parameter name\n     * @param blockNumber Block number\n     */\n    Common.prototype.paramByBlock = function (topic, name, blockNumber) {\n        var activeHfs = this.activeHardforks(blockNumber);\n        var hardfork = activeHfs[activeHfs.length - 1]['name'];\n        return this.param(topic, name, hardfork);\n    };\n    /**\n     * Checks if set or provided hardfork is active on block number\n     * @param hardfork Hardfork name or null (for HF set)\n     * @param blockNumber\n     * @param opts Hardfork options (onlyActive unused)\n     * @returns True if HF is active on block number\n     */\n    Common.prototype.hardforkIsActiveOnBlock = function (hardfork, blockNumber, opts) {\n        opts = opts !== undefined ? opts : {};\n        var onlySupported = opts.onlySupported === undefined ? false : opts.onlySupported;\n        hardfork = this._chooseHardfork(hardfork, onlySupported);\n        var hfBlock = this.hardforkBlock(hardfork);\n        if (hfBlock !== null && blockNumber >= hfBlock)\n            return true;\n        return false;\n    };\n    /**\n     * Alias to hardforkIsActiveOnBlock when hardfork is set\n     * @param blockNumber\n     * @param opts Hardfork options (onlyActive unused)\n     * @returns True if HF is active on block number\n     */\n    Common.prototype.activeOnBlock = function (blockNumber, opts) {\n        return this.hardforkIsActiveOnBlock(null, blockNumber, opts);\n    };\n    /**\n     * Sequence based check if given or set HF1 is greater than or equal HF2\n     * @param hardfork1 Hardfork name or null (if set)\n     * @param hardfork2 Hardfork name\n     * @param opts Hardfork options\n     * @returns True if HF1 gte HF2\n     */\n    Common.prototype.hardforkGteHardfork = function (hardfork1, hardfork2, opts) {\n        opts = opts !== undefined ? opts : {};\n        var onlyActive = opts.onlyActive === undefined ? false : opts.onlyActive;\n        hardfork1 = this._chooseHardfork(hardfork1, opts.onlySupported);\n        var hardforks;\n        if (onlyActive) {\n            hardforks = this.activeHardforks(null, opts);\n        }\n        else {\n            hardforks = this.hardforks();\n        }\n        var posHf1 = -1, posHf2 = -1;\n        var index = 0;\n        for (var _i = 0, hardforks_2 = hardforks; _i < hardforks_2.length; _i++) {\n            var hf = hardforks_2[_i];\n            if (hf['name'] === hardfork1)\n                posHf1 = index;\n            if (hf['name'] === hardfork2)\n                posHf2 = index;\n            index += 1;\n        }\n        return posHf1 >= posHf2;\n    };\n    /**\n     * Alias to hardforkGteHardfork when hardfork is set\n     * @param hardfork Hardfork name\n     * @param opts Hardfork options\n     * @returns True if hardfork set is greater than hardfork provided\n     */\n    Common.prototype.gteHardfork = function (hardfork, opts) {\n        return this.hardforkGteHardfork(null, hardfork, opts);\n    };\n    /**\n     * Checks if given or set hardfork is active on the chain\n     * @param hardfork Hardfork name, optional if HF set\n     * @param opts Hardfork options (onlyActive unused)\n     * @returns True if hardfork is active on the chain\n     */\n    Common.prototype.hardforkIsActiveOnChain = function (hardfork, opts) {\n        opts = opts !== undefined ? opts : {};\n        var onlySupported = opts.onlySupported === undefined ? false : opts.onlySupported;\n        hardfork = this._chooseHardfork(hardfork, onlySupported);\n        for (var _i = 0, _a = this.hardforks(); _i < _a.length; _i++) {\n            var hf = _a[_i];\n            if (hf['name'] === hardfork && hf['block'] !== null)\n                return true;\n        }\n        return false;\n    };\n    /**\n     * Returns the active hardfork switches for the current chain\n     * @param blockNumber up to block if provided, otherwise for the whole chain\n     * @param opts Hardfork options (onlyActive unused)\n     * @return Array with hardfork arrays\n     */\n    Common.prototype.activeHardforks = function (blockNumber, opts) {\n        opts = opts !== undefined ? opts : {};\n        var activeHardforks = [];\n        var hfs = this.hardforks();\n        for (var _i = 0, hfs_2 = hfs; _i < hfs_2.length; _i++) {\n            var hf = hfs_2[_i];\n            if (hf['block'] === null)\n                continue;\n            if (blockNumber !== undefined && blockNumber !== null && blockNumber < hf['block'])\n                break;\n            if (opts.onlySupported && !this._isSupportedHardfork(hf['name']))\n                continue;\n            activeHardforks.push(hf);\n        }\n        return activeHardforks;\n    };\n    /**\n     * Returns the latest active hardfork name for chain or block or throws if unavailable\n     * @param blockNumber up to block if provided, otherwise for the whole chain\n     * @param opts Hardfork options (onlyActive unused)\n     * @return Hardfork name\n     */\n    Common.prototype.activeHardfork = function (blockNumber, opts) {\n        opts = opts !== undefined ? opts : {};\n        var activeHardforks = this.activeHardforks(blockNumber, opts);\n        if (activeHardforks.length > 0) {\n            return activeHardforks[activeHardforks.length - 1]['name'];\n        }\n        else {\n            throw new Error(\"No (supported) active hardfork found\");\n        }\n    };\n    /**\n     * Returns the hardfork change block for hardfork provided or set\n     * @param hardfork Hardfork name, optional if HF set\n     * @returns Block number\n     */\n    Common.prototype.hardforkBlock = function (hardfork) {\n        hardfork = this._chooseHardfork(hardfork, false);\n        return this._getHardfork(hardfork)['block'];\n    };\n    /**\n     * True if block number provided is the hardfork (given or set) change block of the current chain\n     * @param blockNumber Number of the block to check\n     * @param hardfork Hardfork name, optional if HF set\n     * @returns True if blockNumber is HF block\n     */\n    Common.prototype.isHardforkBlock = function (blockNumber, hardfork) {\n        hardfork = this._chooseHardfork(hardfork, false);\n        if (this.hardforkBlock(hardfork) === blockNumber) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * Provide the consensus type for the hardfork set or provided as param\n     * @param hardfork Hardfork name, optional if hardfork set\n     * @returns Consensus type (e.g. 'pow', 'poa')\n     */\n    Common.prototype.consensus = function (hardfork) {\n        hardfork = this._chooseHardfork(hardfork);\n        return this._getHardfork(hardfork)['consensus'];\n    };\n    /**\n     * Provide the finality type for the hardfork set or provided as param\n     * @param {String} hardfork Hardfork name, optional if hardfork set\n     * @returns {String} Finality type (e.g. 'pos', null of no finality)\n     */\n    Common.prototype.finality = function (hardfork) {\n        hardfork = this._chooseHardfork(hardfork);\n        return this._getHardfork(hardfork)['finality'];\n    };\n    /**\n     * Returns the Genesis parameters of current chain\n     * @returns Genesis dictionary\n     */\n    Common.prototype.genesis = function () {\n        return this._chainParams['genesis'];\n    };\n    /**\n     * Returns the hardforks for current chain\n     * @returns {Array} Array with arrays of hardforks\n     */\n    Common.prototype.hardforks = function () {\n        return this._chainParams['hardforks'];\n    };\n    /**\n     * Returns bootstrap nodes for the current chain\n     * @returns {Dictionary} Dict with bootstrap nodes\n     */\n    Common.prototype.bootstrapNodes = function () {\n        return this._chainParams['bootstrapNodes'];\n    };\n    /**\n     * Returns the hardfork set\n     * @returns Hardfork name\n     */\n    Common.prototype.hardfork = function () {\n        return this._hardfork;\n    };\n    /**\n     * Returns the Id of current chain\n     * @returns chain Id\n     */\n    Common.prototype.chainId = function () {\n        return this._chainParams['chainId'];\n    };\n    /**\n     * Returns the name of current chain\n     * @returns chain name (lower case)\n     */\n    Common.prototype.chainName = function () {\n        return chains_1.chains['names'][this.chainId()] || this._chainParams['name'];\n    };\n    /**\n     * Returns the Id of current network\n     * @returns network Id\n     */\n    Common.prototype.networkId = function () {\n        return this._chainParams['networkId'];\n    };\n    return Common;\n}());\nexports.default = Common;\n//# sourceMappingURL=index.js.map","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","import { throwNotImplemented } from \"..\";\n\nexport abstract class BaseBigNumber {\n    static isBN(value) {\n        return throwNotImplemented<boolean>();\n    }\n\n    abstract toString(): string;\n    abstract toNumber(): number;\n    abstract toBuffer(): Buffer;\n    abstract add(value: BaseBigNumber): BaseBigNumber;\n    abstract sub(value: BaseBigNumber): BaseBigNumber;\n    abstract mul(value: BaseBigNumber): BaseBigNumber;\n    abstract div(value: BaseBigNumber): BaseBigNumber;\n\n    abstract lte(value: BaseBigNumber): boolean;\n    abstract lt(value: BaseBigNumber): boolean;\n    abstract gte(value: BaseBigNumber): boolean;\n    abstract gt(value: BaseBigNumber): boolean;\n    abstract eq(value: BaseBigNumber): boolean;\n}","import { BaseContractMethod } from \"../abstracts\";\nimport { Logger } from \"../utils\";\n\nexport abstract class BaseContract {\n\n    constructor(public address: string, public logger:Logger) {\n\n    }\n\n    abstract method(methodName: string, ...args): BaseContractMethod;\n}","import { BaseContract } from \"../abstracts\";\nimport { ITransactionRequestConfig, ITransactionReceipt, ITransactionData, IBlock, IBlockWithTransaction, IJsonRpcRequestPayload, IJsonRpcResponse, ITransactionWriteResult } from \"../interfaces\";\nimport { Logger } from \"../utils\";\n\nexport abstract class BaseWeb3Client {\n\n    constructor(public logger: Logger) {\n\n    }\n\n    abstract getContract(address: string, abi: any): BaseContract;\n\n    abstract read(config: ITransactionRequestConfig): Promise<string>;\n\n    abstract write(config: ITransactionRequestConfig): ITransactionWriteResult;\n    abstract getGasPrice(): Promise<string>;\n    abstract estimateGas(config: ITransactionRequestConfig): Promise<number>;\n    abstract getChainId(): Promise<number>;\n    abstract getTransactionCount(address: string, blockNumber: any): Promise<number>;\n\n    abstract getTransaction(transactionHash: string): Promise<ITransactionData>;\n    abstract getTransactionReceipt(transactionHash: string): Promise<ITransactionReceipt>;\n    // abstract extend(property: string, methods: IMethod[])\n\n    abstract getBlock(blockHashOrBlockNumber): Promise<IBlock>;\n    abstract getBlockWithTransaction(blockHashOrBlockNumber): Promise<IBlockWithTransaction>;\n\n    getRootHash?(startBlock: number, endBlock: number) {\n        return this.sendRPCRequest({\n            jsonrpc: '2.0',\n            method: 'eth_getRootHash',\n            params: [Number(startBlock), Number(endBlock)],\n            id: new Date().getTime()\n        }).then(payload => {\n            return String(payload.result);\n        });\n    }\n\n    abstract sendRPCRequest(request: IJsonRpcRequestPayload): Promise<IJsonRpcResponse>;\n\n    abstract encodeParameters(params: any[], types: any[]): string;\n    abstract decodeParameters(hexString: string, types: any[]): any[];\n    abstract etheriumSha3(...value): string;\n\n}\n","import { ITransactionRequestConfig, ITransactionWriteResult } from \"../interfaces\";\nimport { Logger } from \"../utils\";\n\nexport abstract class BaseContractMethod {\n    constructor(public logger: Logger) {\n\n    }\n    abstract get address(): string;\n    abstract read<T>(tx?: ITransactionRequestConfig,): Promise<T>;\n    abstract write(tx: ITransactionRequestConfig,): ITransactionWriteResult;\n    abstract estimateGas(tx: ITransactionRequestConfig,): Promise<number>;\n    abstract encodeABI(): any;\n}","export * from \"./contract_method\";\nexport * from \"./base_web3_client\";\nexport * from \"./base_contract\";\nexport * from \"./base_big_number\";","\nexport const config = {\n    abiStoreUrl: 'https://static.matic.network/network/'\n};","export const MAX_AMOUNT = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';\n","import { POSClient } from \"./pos\";\nimport { use, utils } from \"./utils\";\n\nexport const defaultExport = {\n    utils: utils,\n    use,\n    POSClient,\n};","export enum ERROR_TYPE {\n    AllowedOnRoot = \"allowed_on_root\",\n    AllowedOnChild = \"allowed_on_child\",\n    Unknown = \"unknown\",\n    ProofAPINotSet = \"proof_api_not_set\",\n    TransactionOptionNotObject = \"transation_object_not_object\",\n    BurnTxNotCheckPointed = \"burn_tx_not_checkpointed\",\n    EIP1559NotSupported = \"eip-1559_not_supported\"\n}","export * from \"./log_event_signature\";\nexport * from \"./error_type\";","export enum Log_Event_Signature {\n    // PlasmaErc20WithdrawEventSig = '0xebff2602b3f468259e1e99f613fed6691f3a6526effe6ef3e768ba7ae7a36c4f',\n    // PlasmaErc721WithdrawEventSig = '0x9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb',\n    Erc20Transfer = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n    Erc721Transfer = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n    Erc1155Transfer = '0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62',\n    Erc721BatchTransfer = '0xf871896b17e9cb7a64941c62c188a4f5c621b86800e3d15452ece01ce56073df',\n    Erc1155BatchTransfer = '0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb',\n\n}","import { throwNotImplemented } from \"..\";\nimport { BaseBigNumber } from \"../abstracts\";\n\nexport class EmptyBigNumber extends BaseBigNumber {\n\n    constructor(value) {\n        super();\n    }\n\n    toString(base?) {\n        return throwNotImplemented<string>();\n    }\n\n    toNumber() {\n        return throwNotImplemented<number>();\n    }\n\n    toBuffer(base?) {\n        return throwNotImplemented<Buffer>();\n    }\n\n    add(value: BaseBigNumber) {\n        return throwNotImplemented<BaseBigNumber>();\n    }\n\n    sub(value: BaseBigNumber) {\n        return throwNotImplemented<BaseBigNumber>();\n    }\n\n    mul(value: BaseBigNumber) {\n        return throwNotImplemented<BaseBigNumber>();\n    }\n\n    div(value: BaseBigNumber) {\n        return throwNotImplemented<BaseBigNumber>();\n    }\n\n    lte(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n    }\n\n    lt(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n\n    }\n\n    gte(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n\n    }\n\n    gt(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n\n    }\n\n    eq(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n    }\n}","export * from \"./bn\";","import { defaultExport } from \"./default\";\n\nexport * from \"./utils\";\nexport * from \"./enums\";\nexport * from \"./pos\";\nexport * from \"./interfaces\";\nexport * from \"./types\";\nexport * from \"./constant\";\nexport * from \"./abstracts\";\nexport * from \"./services\";\n\nexport default defaultExport;\n\n","export * from \"./plugin\";\nexport * from \"./method\";\nexport * from \"./transaction_config\";\nexport * from \"./transaction_write_result\";\nexport * from \"./transaction_result\";\nexport * from \"./transaction_option\";\nexport * from \"./contract_init_param\";\nexport * from \"./tx_receipt\";\nexport * from \"./pos_client_config\";\nexport * from \"./transaction_data\";\nexport * from \"./block\";\nexport * from \"./block_with_transaction\";\nexport * from \"./rpc_request_payload\";\nexport * from \"./rpc_response_payload\";\nexport * from \"./map_promise_option\";\nexport * from \"./base_client_config\";\nexport * from \"./error\";\nexport * from \"./pos_contracts\";\nexport * from \"./root_block_info\";","import { IPOSClientConfig, ITransactionOption } from \"../interfaces\";\nimport { Converter, promiseResolve, Web3SideChainClient } from \"../utils\";\nimport { POSToken } from \"./pos_token\";\nimport { Log_Event_Signature } from \"../enums\";\nimport { IPOSContracts, IPOSERC1155Address } from \"../interfaces\";\nimport { POSERC1155DepositBatchParam, POSERC1155DepositParam, POSERC1155TransferParam, TYPE_AMOUNT } from \"..\";\n\nexport class ERC1155 extends POSToken {\n\n    mintablePredicateAddress: string;\n\n    get addressConfig(): IPOSERC1155Address {\n        return this.client.config.erc1155 || {};\n    }\n\n    constructor(\n        tokenAddress: string,\n        isParent: boolean,\n        client: Web3SideChainClient<IPOSClientConfig>,\n        getContracts: () => IPOSContracts\n    ) {\n        super({\n            isParent,\n            address: tokenAddress,\n            name: 'ChildERC1155',\n            bridgeType: 'pos'\n        }, client, getContracts);\n\n    }\n\n    private getAddress_(value: string) {\n        const addresses = this.addressConfig;\n        if (addresses[value]) {\n            return promiseResolve(addresses[value]);\n        }\n\n        return this.client.getConfig(value);\n    }\n\n    /**\n     * get balance of a user for supplied token\n     *\n     * @param {string} userAddress\n     * @param {TYPE_AMOUNT} tokenId\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    getBalance(userAddress: string, tokenId: TYPE_AMOUNT, option?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"balanceOf\",\n                userAddress,\n                Converter.toHex(tokenId)\n            );\n            return this.processRead<string>(method, option);\n        });\n    }\n\n    /**\n     * check if a user is approved for all tokens\n     *\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    isApprovedAll(userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"isApprovedAll\");\n\n        return Promise.all([this.getContract(), this.getPredicateAddress()]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"isApprovedForAll\",\n                userAddress,\n                predicateAddress\n            );\n            return this.processRead<boolean>(method, option);\n        });\n\n    }\n\n    private approveAll_(predicateAddressPromise: Promise<string>, option: ITransactionOption) {\n        this.checkForRoot(\"approve\");\n\n        return Promise.all([this.getContract(), predicateAddressPromise]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"setApprovalForAll\",\n                predicateAddress,\n                true\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * approve all tokens \n     *\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    approveAll(option?: ITransactionOption) {\n        this.checkForRoot(\"approve\");\n\n        return this.approveAll_(\n            this.getPredicateAddress(), option\n        );\n    }\n\n    /**\n     * approve all tokens for mintable token\n     *\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    approveAllForMintable(option?: ITransactionOption) {\n        this.checkForRoot(\"approveForMintable\");\n        const addressPath = \"Main.POSContracts.MintableERC1155PredicateProxy\";\n        return this.approveAll_(\n            this.getAddress_(addressPath), option\n        );\n    }\n\n    /**\n     * deposit supplied amount of token for a user \n     *\n     * @param {POSERC1155DepositParam} param\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    deposit(param: POSERC1155DepositParam, option?: ITransactionOption) {\n        this.checkForRoot(\"deposit\");\n        return this.depositMany({\n            amounts: [param.amount],\n            tokenIds: [param.tokenId],\n            userAddress: param.userAddress,\n            data: param.data\n        }, option);\n    }\n\n    /**\n     * deposit supplied amount of multiple token for user\n     *\n     * @param {POSERC1155DepositBatchParam} param\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    depositMany(param: POSERC1155DepositBatchParam, option?: ITransactionOption) {\n        this.checkForRoot(\"depositMany\");\n\n        const { tokenIds, amounts, data, userAddress } = param;\n        const emptyHex = Converter.toHex(0);\n        const amountInABI = this.client.parent.encodeParameters(\n            [\n                tokenIds.map(t => Converter.toHex(t)),\n                amounts.map(a => Converter.toHex(a)),\n                data || emptyHex\n            ],\n            ['uint256[]', 'uint256[]', 'bytes'],\n        );\n\n        return this.rootChainManager.deposit(\n            userAddress,\n            this.contractParam.address,\n            amountInABI,\n            option\n        );\n\n    }\n\n    /**\n     * start withdraw process by burning the required amount for a token\n     *\n     * @param {string} tokenId\n     * @param {TYPE_AMOUNT} amount\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawStart(tokenId: TYPE_AMOUNT, amount: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStart\");\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdrawSingle\",\n                Converter.toHex(tokenId),\n                Converter.toHex(amount)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * start the withdraw process by burning the supplied amount of multiple token at a time\n     *\n     * @param {TYPE_AMOUNT[]} tokenIds\n     * @param {TYPE_AMOUNT[]} amounts\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawStartMany(tokenIds: TYPE_AMOUNT[], amounts: TYPE_AMOUNT[], option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStartMany\");\n\n        const tokensInHex = tokenIds.map(t => {\n            return Converter.toHex(t);\n        });\n        const amountsInHex = amounts.map(t => {\n            return Converter.toHex(t);\n        });\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdrawBatch\",\n                tokensInHex,\n                amountsInHex\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * exit the withdraw process and get the burned amount on root chain\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawExit(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExit\");\n\n        return this.withdrawExitPOS(\n            burnTransactionHash,\n            Log_Event_Signature.Erc1155Transfer,\n            false,\n            option\n        );\n    }\n\n    /**\n     * exit the withdraw process and get the burned amount on root chain\n     * \n     * the process is faster because it uses proof api\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawExitFaster(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFaster\");\n\n        return this.withdrawExitPOS(\n            burnTransactionHash,\n            Log_Event_Signature.Erc1155Transfer,\n            true,\n            option\n        );\n    }\n\n    /**\n     * exit the withdraw process for many burned transaction and get the burned amount on root chain\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawExitMany(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitMany\");\n\n\n        return this.withdrawExitPOS(\n            burnTransactionHash,\n            Log_Event_Signature.Erc1155BatchTransfer,\n            false,\n            option\n        );\n    }\n\n    /**\n     * exit the withdraw process for many burned transaction and get the burned amount on root chain\n     *\n     * the process is faster because it uses proof api\n     * \n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawExitFasterMany(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFasterMany\");\n\n\n        return this.withdrawExitPOS(\n            burnTransactionHash,\n            Log_Event_Signature.Erc1155BatchTransfer,\n            true,\n            option\n        );\n    }\n\n    /**\n     * check if exit has been completed for a transaction hash\n     *\n     * @param {string} burnTxHash\n     * @return {*} \n     * @memberof ERC1155\n     */\n    isWithdrawExited(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc1155Transfer\n        );\n    }\n\n    /**\n     * check if batch exit has been completed for a transaction hash\n     *\n     * @param {string} txHash\n     * @return {*} \n     * @memberof ERC1155\n     */\n    isWithdrawExitedMany(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc1155BatchTransfer\n        );\n    }\n\n    /**\n     * transfer the required amount of a token to anothe user\n     *\n     * @param {POSERC1155TransferParam} param\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    transfer(param: POSERC1155TransferParam, option?: ITransactionOption) {\n        return this.transferERC1155(\n            param, option\n        );\n    }\n}","import { ITransactionOption } from \"../interfaces\";\nimport { RootChainManager } from \"./root_chain_manager\";\nimport { Converter, Web3SideChainClient } from \"../utils\";\nimport { POSToken } from \"./pos_token\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { ExitUtil } from \"./exit_util\";\nimport { Log_Event_Signature } from \"../enums\";\nimport { IPOSClientConfig, MAX_AMOUNT } from \"..\";\nimport { IPOSContracts } from \"../interfaces/pos_contracts\";\n\nexport class ERC20 extends POSToken {\n\n\n    constructor(\n        tokenAddress: string,\n        isParent: boolean,\n        client: Web3SideChainClient<IPOSClientConfig>,\n        getContracts: () => IPOSContracts\n    ) {\n        super({\n            isParent,\n            address: tokenAddress,\n            name: 'ChildERC20',\n            bridgeType: 'pos'\n        }, client, getContracts);\n    }\n\n    getBalance(userAddress: string, option?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"balanceOf\",\n                userAddress\n            );\n            return this.processRead<string>(method, option);\n        });\n    }\n\n    /**\n     * get allowance of user\n     *\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    getAllowance(userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"getAllowance\");\n\n        return Promise.all([this.getPredicateAddress(), this.getContract()]).then(result => {\n            const [predicateAddress, contract] = result;\n            const method = contract.method(\n                \"allowance\",\n                userAddress,\n                predicateAddress,\n            );\n            return this.processRead<string>(method, option);\n        });\n    }\n\n    approve(amount: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForRoot(\"approve\");\n\n        return Promise.all([this.getPredicateAddress(), this.getContract()]).then(result => {\n            const [predicateAddress, contract] = result;\n            const method = contract.method(\n                \"approve\",\n                predicateAddress,\n                Converter.toHex(amount)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    approveMax(option?: ITransactionOption) {\n        return this.approve(\n            MAX_AMOUNT\n            , option\n        );\n    }\n\n    /**\n     * Deposit given amount of token for user\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    deposit(amount: TYPE_AMOUNT, userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"deposit\");\n\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n        return this.rootChainManager.deposit(\n            userAddress,\n            this.contractParam.address,\n            amountInABI,\n            option\n        );\n    }\n\n    private depositEther_(amount: TYPE_AMOUNT, userAddress: string, option: ITransactionOption = {}) {\n        this.checkForRoot(\"depositEther\");\n\n\n        option.value = Converter.toHex(amount);\n        return this.rootChainManager.method(\"depositEtherFor\", userAddress).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * initiate withdraw by burning provided amount\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawStart(amount: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStart\");\n\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdraw\",\n                Converter.toHex(amount)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * complete withdraw process after checkpoint has been submitted for the block containing burn tx.\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawExit(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExit\");\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc20Transfer,\n            false\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    /**\n     * complete withdraw process after checkpoint has been submitted for the block containing burn tx.\n     *\n     *  Note:- It create the proof in api call for fast exit.\n     * \n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawExitFaster(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFaster\");\n\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc20Transfer,\n            true\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    /**\n     * check if exit has been completed for a transaction hash\n     *\n     * @param {string} burnTxHash\n     * @returns\n     * @memberof ERC20\n     */\n    isWithdrawExited(burnTxHash: string) {\n        return this.isWithdrawn(burnTxHash, Log_Event_Signature.Erc20Transfer);\n    }\n\n    /**\n     * transfer amount to another user\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} to\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    transfer(amount: TYPE_AMOUNT, to: string, option?: ITransactionOption) {\n        return this.transferERC20(to, amount, option);\n    }\n\n}","import { IPOSClientConfig, IPOSContracts, ITransactionOption } from \"../interfaces\";\nimport { RootChainManager } from \"./root_chain_manager\";\nimport { Converter, Web3SideChainClient } from \"../utils\";\nimport { POSToken } from \"./pos_token\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { ExitUtil } from \"./exit_util\";\nimport { Log_Event_Signature } from \"../enums\";\n\nexport class ERC721 extends POSToken {\n\n\n    constructor(\n        tokenAddress: string,\n        isParent: boolean,\n        client: Web3SideChainClient<IPOSClientConfig>,\n        getContracts: () => IPOSContracts\n    ) {\n        super({\n            isParent,\n            address: tokenAddress,\n            name: 'ChildERC721',\n            bridgeType: 'pos'\n        }, client, getContracts);\n    }\n\n    private validateMany_(tokenIds) {\n        if (tokenIds.length > 20) {\n            throw new Error('can not process more than 20 tokens');\n        }\n        return tokenIds.map(tokenId => {\n            return Converter.toHex(tokenId);\n        });\n    }\n\n    /**\n     * get tokens count for the user\n     *\n     * @param {string} userAddress\n     * @param {ITransactionOption} [options]\n     * @returns\n     * @memberof ERC721\n     */\n    getTokensCount(userAddress: string, options?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"balanceOf\",\n                userAddress\n            );\n            return this.processRead<string>(method, options);\n        }).then(count => {\n            return Number(count);\n        });\n    }\n\n    /**\n     * returns token id on supplied index for user\n     *\n     * @param {number} index\n     * @param {string} userAddress\n     * @param {ITransactionOption} [options]\n     * @returns\n     * @memberof ERC721\n     */\n    getTokenIdAtIndexForUser(index: number, userAddress: string, options?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"tokenOfOwnerByIndex\",\n                userAddress,\n                index\n            );\n\n            return this.processRead<string>(method, options);\n        });\n    }\n\n    /**\n     * get all tokens for user\n     *\n     * @param {string} userAddress\n     * @param {*} [limit=Infinity]\n     * @returns\n     * @memberof ERC721\n     */\n    getAllTokens(userAddress: string, limit = Infinity) {\n        return this.getTokensCount(userAddress).then(count => {\n            count = Number(count);\n            if (count > limit) {\n                count = limit;\n            }\n            const promises = [];\n            for (let i = 0; i < count; i++) {\n                promises.push(\n                    this.getTokenIdAtIndexForUser(i, userAddress)\n                );\n            }\n            return Promise.all(\n                promises\n            );\n        });\n    }\n\n    isApproved(tokenId: string, option?: ITransactionOption) {\n        this.checkForRoot(\"isApproved\");\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"getApproved\",\n                tokenId\n            );\n            return Promise.all([\n                this.processRead<string>(method, option),\n                this.getPredicateAddress()\n            ]).then(result => {\n                return result[0] === result[1];\n            });\n        });\n    }\n\n    isApprovedAll(userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"isApprovedAll\");\n\n        return Promise.all([this.getContract(), this.getPredicateAddress()]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"isApprovedForAll\",\n                userAddress,\n                predicateAddress\n            );\n            return this.processRead<boolean>(method, option);\n        });\n\n    }\n\n    approve(tokenId: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForRoot(\"approve\");\n\n        return Promise.all([this.getContract(), this.getPredicateAddress()]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"approve\",\n                predicateAddress,\n                Converter.toHex(tokenId)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    approveAll(option?: ITransactionOption) {\n        this.checkForRoot(\"approveAll\");\n\n        return Promise.all([this.getContract(), this.getPredicateAddress()]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"setApprovalForAll\",\n                predicateAddress,\n                true\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n\n    deposit(tokenId: TYPE_AMOUNT, userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"deposit\");\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(tokenId)],\n            ['uint256'],\n        );\n        return this.rootChainManager.deposit(\n            userAddress,\n            this.contractParam.address,\n            amountInABI,\n            option\n        );\n    }\n\n    depositMany(tokenIds: TYPE_AMOUNT[], userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"depositMany\");\n\n        const tokensInHex = this.validateMany_(tokenIds);\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [tokensInHex],\n            ['uint256[]'],\n        );\n        return this.rootChainManager.deposit(\n            userAddress,\n            this.contractParam.address,\n            amountInABI,\n            option\n        );\n    }\n\n    withdrawStart(tokenId: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStart\");\n\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdraw\",\n                Converter.toHex(tokenId)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    withdrawStartWithMetaData(tokenId: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStartWithMetaData\");\n\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdrawWithMetadata\",\n                Converter.toHex(tokenId)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    withdrawStartMany(tokenIds: TYPE_AMOUNT[], option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStartMany\");\n\n        const tokensInHex = this.validateMany_(tokenIds);\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdrawBatch\",\n                tokensInHex\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    withdrawExit(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExit\");\n\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc721Transfer,\n            false\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    withdrawExitMany(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitMany\");\n\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc721BatchTransfer,\n            false\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    withdrawExitFaster(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFaster\");\n\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc721Transfer,\n            true\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    withdrawExitFasterMany(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFasterMany\");\n\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc721BatchTransfer,\n            true\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    isWithdrawExited(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc721Transfer\n        );\n    }\n\n    isWithdrawExitedMany(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc721BatchTransfer\n        );\n    }\n\n    /**\n     * tranfer to another user\n     *\n     * @param {string} tokenId\n     * @param {string} from\n     * @param {string} to\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC721\n     */\n    transfer(tokenId: string, from: string, to: string, option?: ITransactionOption) {\n        return this.transferERC721(\n            from,\n            to,\n            tokenId,\n            option\n        );\n    }\n\n}","import { RootChain } from \"./root_chain\";\nimport { Converter, ProofUtil, Web3SideChainClient } from \"../utils\";\nimport ethUtils from \"ethereumjs-util\";\nimport { IBlockWithTransaction, ITransactionReceipt } from \"../interfaces\";\nimport { service } from \"../services\";\nimport { BaseBigNumber, BaseWeb3Client } from \"../abstracts\";\nimport { ErrorHelper } from \"../utils/error_helper\";\nimport { ERROR_TYPE, IBaseClientConfig, IRootBlockInfo, utils } from \"..\";\n\ninterface IChainBlockInfo {\n    lastChildBlock: string;\n    txBlockNumber: number;\n}\n\n\n\nexport class ExitUtil {\n    private maticClient_: BaseWeb3Client;\n\n    rootChain: RootChain;\n\n    requestConcurrency: number;\n    config: IBaseClientConfig;\n\n    constructor(client: Web3SideChainClient<IBaseClientConfig>, rootChain: RootChain) {\n        this.maticClient_ = client.child;\n        this.rootChain = rootChain;\n        const config = client.config;\n        this.config = config;\n        this.requestConcurrency = config.requestConcurrency;\n    }\n\n    private getLogIndex_(logEventSig: string, receipt: ITransactionReceipt) {\n        let logIndex = -1;\n\n        switch (logEventSig) {\n            case '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef':\n            case '0xf94915c6d1fd521cee85359239227480c7e8776d7caf1fc3bacad5c269b66a14':\n                logIndex = receipt.logs.findIndex(\n                    log =>\n                        log.topics[0].toLowerCase() === logEventSig.toLowerCase() &&\n                        log.topics[2].toLowerCase() === '0x0000000000000000000000000000000000000000000000000000000000000000'\n                );\n                break;\n\n            case '0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62':\n            case '0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb':\n                logIndex = receipt.logs.findIndex(\n                    log =>\n                        log.topics[0].toLowerCase() === logEventSig.toLowerCase() &&\n                        log.topics[3].toLowerCase() === '0x0000000000000000000000000000000000000000000000000000000000000000'\n                );\n                break;\n\n            default:\n                logIndex = receipt.logs.findIndex(log => log.topics[0].toLowerCase() === logEventSig.toLowerCase());\n        }\n        if (logIndex < 0) {\n            throw new Error(\"Log not found in receipt\");\n        }\n        return logIndex;\n    }\n\n    getChainBlockInfo(burnTxHash: string) {\n        return Promise.all([\n            this.rootChain.getLastChildBlock(),\n            this.maticClient_.getTransaction(burnTxHash),\n        ]).then(result => {\n            return {\n                lastChildBlock: result[0],\n                txBlockNumber: result[1].blockNumber\n            } as IChainBlockInfo;\n        });\n    }\n\n    private isCheckPointed_(data: IChainBlockInfo) {\n        // lastchild block is greater equal to transacton block number; \n        return new utils.BN(data.lastChildBlock).gte(\n            new utils.BN(data.txBlockNumber)\n        );\n    }\n\n    isCheckPointed(burnTxHash: string) {\n        return this.getChainBlockInfo(\n            burnTxHash\n        ).then(result => {\n            return this.isCheckPointed_(\n                result\n            );\n        });\n    }\n\n    private getRootBlockInfo(txBlockNumber: number) {\n        // find in which block child was included in parent\n        let rootBlockNumber: BaseBigNumber;\n        return this.rootChain.findRootBlockFromChild(\n            txBlockNumber\n        ).then(blockNumber => {\n            rootBlockNumber = blockNumber;\n            return this.rootChain.method(\n                \"headerBlocks\",\n                Converter.toHex(blockNumber)\n            );\n        }).then(method => {\n            return method.read<IRootBlockInfo>();\n        }).then(rootBlockInfo => {\n            return {\n                headerBlockNumber: rootBlockNumber,\n                end: rootBlockInfo.end.toString(),\n                start: rootBlockInfo.start.toString(),\n            } as IRootBlockInfo;\n        });\n\n    }\n\n    private getRootBlockInfoFromAPI(txBlockNumber: number) {\n        this.maticClient_.logger.log(\"block info from API 1\");\n        return service.network.getBlockIncluded(\n            this.config.network,\n            txBlockNumber\n        ).then(headerBlock => {\n            this.maticClient_.logger.log(\"block info from API 2\", headerBlock);\n            if (!headerBlock || !headerBlock.start || !headerBlock.end || !headerBlock.headerBlockNumber) {\n                throw Error('Network API Error');\n            }\n            return headerBlock;\n        }).catch(err => {\n            this.maticClient_.logger.log(\"block info from API\", err);\n            return this.getRootBlockInfo(txBlockNumber);\n        });\n    }\n\n    private getBlockProof(txBlockNumber: number, rootBlockInfo: { start, end }) {\n        return ProofUtil.buildBlockProof(\n            this.maticClient_,\n            parseInt(rootBlockInfo.start, 10),\n            parseInt(rootBlockInfo.end, 10),\n            parseInt(txBlockNumber + '', 10)\n        );\n    }\n\n    private getBlockProofFromAPI(txBlockNumber: number, rootBlockInfo: { start, end }) {\n\n        return service.network.getProof(\n            this.config.network,\n            rootBlockInfo.start,\n            rootBlockInfo.end,\n            txBlockNumber\n        ).then(blockProof => {\n            if (!blockProof) {\n                throw Error('Network API Error');\n            }\n            this.maticClient_.logger.log(\"block proof from API 1\");\n            return blockProof;\n        }).catch(_ => {\n            return this.getBlockProof(txBlockNumber, rootBlockInfo);\n        });\n    }\n\n    buildPayloadForExit(burnTxHash: string, logEventSig: string, isFast: boolean) {\n\n        if (isFast && !service.network) {\n            new ErrorHelper(ERROR_TYPE.ProofAPINotSet).throw();\n        }\n\n        let txBlockNumber: number,\n            rootBlockInfo: IRootBlockInfo,\n            receipt: ITransactionReceipt,\n            block: IBlockWithTransaction,\n            blockProof;\n\n        return this.getChainBlockInfo(\n            burnTxHash\n        ).then(blockInfo => {\n            if (!this.isCheckPointed_(blockInfo)) {\n                throw new Error(\n                    'Burn transaction has not been checkpointed as yet'\n                );\n            }\n\n            txBlockNumber = blockInfo.txBlockNumber;\n            return Promise.all([\n                this.maticClient_.getTransactionReceipt(burnTxHash),\n                this.maticClient_.getBlockWithTransaction(txBlockNumber)\n            ]);\n        }).then(result => {\n            [receipt, block] = result;\n            return (\n                isFast ? this.getRootBlockInfoFromAPI(txBlockNumber) :\n                    this.getRootBlockInfo(txBlockNumber)\n            );\n        }).then(rootBlockInfoResult => {\n            rootBlockInfo = rootBlockInfoResult;\n            // build block proof\n            return (\n                isFast ? this.getBlockProofFromAPI(txBlockNumber, rootBlockInfo) :\n                    this.getBlockProof(txBlockNumber, rootBlockInfo)\n            );\n        }).then(blockProofResult => {\n            blockProof = blockProofResult;\n            return ProofUtil.getReceiptProof(\n                receipt,\n                block,\n                this.maticClient_,\n                this.requestConcurrency\n            );\n        }).then((receiptProof: any) => {\n            const logIndex = this.getLogIndex_(\n                logEventSig, receipt\n            );\n\n            return this.encodePayload_(\n                rootBlockInfo.headerBlockNumber.toNumber(),\n                blockProof,\n                txBlockNumber,\n                block.timestamp,\n                Buffer.from(block.transactionsRoot.slice(2), 'hex'),\n                Buffer.from(block.receiptsRoot.slice(2), 'hex'),\n                ProofUtil.getReceiptBytes(receipt), // rlp encoded\n                receiptProof.parentNodes,\n                receiptProof.path,\n                logIndex\n            );\n        });\n    }\n\n    private encodePayload_(\n        headerNumber,\n        buildBlockProof,\n        blockNumber,\n        timestamp,\n        transactionsRoot,\n        receiptsRoot,\n        receipt,\n        receiptParentNodes,\n        path,\n        logIndex\n    ) {\n        return ethUtils.bufferToHex(\n            ethUtils.rlp.encode([\n                headerNumber,\n                buildBlockProof,\n                blockNumber,\n                timestamp,\n                ethUtils.bufferToHex(transactionsRoot),\n                ethUtils.bufferToHex(receiptsRoot),\n                ethUtils.bufferToHex(receipt),\n                ethUtils.bufferToHex(ethUtils.rlp.encode(receiptParentNodes)),\n                ethUtils.bufferToHex(Buffer.concat([Buffer.from('00', 'hex'), path])),\n                logIndex,\n            ])\n        );\n    }\n\n    getExitHash(burnTxHash, logEventSig) {\n        let lastChildBlock: string,\n            receipt: ITransactionReceipt,\n            block: IBlockWithTransaction;\n\n        return Promise.all([\n            this.rootChain.getLastChildBlock(),\n            this.maticClient_.getTransactionReceipt(burnTxHash)\n        ]).then(result => {\n            lastChildBlock = result[0];\n            receipt = result[1];\n            return this.maticClient_.getBlockWithTransaction(\n                receipt.blockNumber\n            );\n        }).then(blockResult => {\n            block = blockResult;\n            if (!this.isCheckPointed_({ lastChildBlock: lastChildBlock, txBlockNumber: receipt.blockNumber })) {\n                this.maticClient_.logger.error(ERROR_TYPE.BurnTxNotCheckPointed).throw();\n            }\n            return ProofUtil.getReceiptProof(\n                receipt,\n                block,\n                this.maticClient_,\n                this.requestConcurrency\n            );\n        }).then((receiptProof: any) => {\n            const logIndex = this.getLogIndex_(logEventSig, receipt);\n            const nibbleArr = [];\n            receiptProof.path.forEach(byte => {\n                nibbleArr.push(Buffer.from('0' + (byte / 0x10).toString(16), 'hex'));\n                nibbleArr.push(Buffer.from('0' + (byte % 0x10).toString(16), 'hex'));\n            });\n\n            return this.maticClient_.etheriumSha3(\n                receipt.blockNumber, ethUtils.bufferToHex(Buffer.concat(nibbleArr)), logIndex\n            );\n        });\n    }\n}","import { ERC20 } from \"./erc20\";\nimport { RootChainManager } from \"./root_chain_manager\";\nimport { BridgeClient } from \"../utils\";\nimport { IPOSClientConfig, IPOSContracts, ITransactionOption } from \"../interfaces\";\nimport { ExitUtil } from \"./exit_util\";\nimport { RootChain } from \"./root_chain\";\nimport { ERC721 } from \"./erc721\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { ERC1155 } from \"./erc1155\";\n\nexport * from \"./exit_util\";\nexport * from \"./root_chain_manager\";\nexport * from \"./root_chain\";\n\nexport class POSClient extends BridgeClient<IPOSClientConfig> {\n\n    rootChainManager: RootChainManager;\n\n    init(config: IPOSClientConfig) {\n        const client = this.client;\n\n        return client.init(config).then(_ => {\n            const mainPOSContracts = client.mainPOSContracts;\n            client.config = config = Object.assign(\n                {\n\n                    rootChainManager: mainPOSContracts.RootChainManagerProxy,\n                    rootChain: client.mainPlasmaContracts.RootChainProxy\n                } as IPOSClientConfig,\n                config\n            );\n\n            this.rootChainManager = new RootChainManager(\n                this.client,\n                config.rootChainManager,\n            );\n\n            const rootChain = new RootChain(\n                this.client,\n                config.rootChain,\n            );\n\n            this.exitUtil = new ExitUtil(\n                this.client,\n                rootChain\n            );\n\n            return this;\n        });\n    }\n\n    erc20(tokenAddress, isParent?: boolean) {\n        return new ERC20(\n            tokenAddress,\n            isParent,\n            this.client,\n            this.getContracts_.bind(this)\n        );\n    }\n\n    erc721(tokenAddress, isParent?: boolean) {\n        return new ERC721(\n            tokenAddress,\n            isParent,\n            this.client,\n            this.getContracts_.bind(this)\n        );\n    }\n\n    erc1155(tokenAddress, isParent?: boolean) {\n        return new ERC1155(\n            tokenAddress,\n            isParent,\n            this.client,\n            this.getContracts_.bind(this)\n        );\n    }\n\n    depositEther(amount: TYPE_AMOUNT, userAddress: string, option: ITransactionOption) {\n        return new ERC20(\n            '', true, this.client,\n            this.getContracts_.bind(this),\n        )['depositEther_'](amount, userAddress, option);\n    }\n\n    private getContracts_() {\n        return {\n            exitUtil: this.exitUtil,\n            rootChainManager: this.rootChainManager\n        } as IPOSContracts;\n    }\n}","import { BaseToken, Web3SideChainClient, promiseResolve } from \"../utils\";\nimport { IContractInitParam, IPOSClientConfig, ITransactionOption } from \"../interfaces\";\nimport { IPOSContracts } from \"../interfaces\";\n\nexport class POSToken extends BaseToken<IPOSClientConfig> {\n\n    private predicateAddress: string;\n\n    constructor(\n        contractParam: IContractInitParam,\n        client: Web3SideChainClient<IPOSClientConfig>,\n        protected getPOSContracts: () => IPOSContracts\n    ) {\n        super(contractParam, client);\n    }\n\n    protected get rootChainManager() {\n        return this.getPOSContracts().rootChainManager;\n    }\n\n    protected get exitUtil() {\n        return this.getPOSContracts().exitUtil;\n    }\n\n\n    getPredicateAddress(): Promise<string> {\n        if (this.predicateAddress) {\n            return promiseResolve(this.predicateAddress);\n        }\n        return this.rootChainManager.method(\n            \"tokenToType\",\n            this.contractParam.address\n        ).then(method => {\n            return method.read();\n        }).then(tokenType => {\n            if (!tokenType) {\n                throw new Error('Invalid Token Type');\n            }\n            return this.rootChainManager.method(\n                \"typeToPredicate\", tokenType\n            );\n        }).then(typeToPredicateMethod => {\n            return typeToPredicateMethod.read<string>();\n        }).then(predicateAddress => {\n            this.predicateAddress = predicateAddress;\n            return predicateAddress;\n        });\n    }\n\n    protected isWithdrawn(txHash: string, eventSignature: string) {\n        if (!txHash) {\n            throw new Error(`txHash not provided`);\n        }\n        return this.exitUtil.getExitHash(\n            txHash, eventSignature\n        ).then(exitHash => {\n            return this.rootChainManager.isExitProcessed(\n                exitHash\n            );\n        });\n    }\n\n    protected withdrawExitPOS(burnTxHash: string, eventSignature: string, isFast: boolean, option: ITransactionOption) {\n        return this.exitUtil.buildPayloadForExit(\n            burnTxHash,\n            eventSignature,\n            isFast\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n}","import { BaseToken, utils, Web3SideChainClient } from \"../utils\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { IPOSClientConfig, ITransactionOption } from \"../interfaces\";\nimport { BaseBigNumber } from \"..\";\n\nexport class RootChain extends BaseToken<IPOSClientConfig> {\n\n    constructor(client_: Web3SideChainClient<IPOSClientConfig>, address: string) {\n        super({\n            address: address,\n            name: 'RootChain',\n            isParent: true\n        }, client_);\n    }\n\n    method(methodName: string, ...args) {\n        return this.getContract().then(contract => {\n            return contract.method(methodName, ...args);\n        });\n    }\n\n    getLastChildBlock() {\n        return this.method(\"getLastChildBlock\").then(method => {\n            return method.read<string>();\n        });\n    }\n\n    async findRootBlockFromChild(childBlockNumber: TYPE_AMOUNT): Promise<BaseBigNumber> {\n        const bigOne = new utils.BN(1);\n        const bigtwo = new utils.BN(2);\n        const checkPointInterval = new utils.BN(10000);\n\n        childBlockNumber = new utils.BN(childBlockNumber);\n        // first checkpoint id = start * 10000\n        let start = bigOne;\n\n        // last checkpoint id = end * 10000\n        const method = await this.method(\"currentHeaderBlock\");\n        const currentHeaderBlock = await method.read<string>();\n        let end = new utils.BN(currentHeaderBlock).div(\n            checkPointInterval\n        );\n\n        // binary search on all the checkpoints to find the checkpoint that contains the childBlockNumber\n        let ans;\n        while (start.lte(end)) {\n            if (start.eq(end)) {\n                ans = start;\n                break;\n            }\n            const mid = start.add(end).div(bigtwo);\n            const headerBlocksMethod = await this.method(\n                \"headerBlocks\",\n                mid.mul(checkPointInterval).toString()\n            );\n            const headerBlock = await headerBlocksMethod.read<{ start: number, end: number }>();\n\n            const headerStart = new utils.BN(headerBlock.start);\n            const headerEnd = new utils.BN(headerBlock.end);\n\n            if (headerStart.lte(childBlockNumber) && childBlockNumber.lte(headerEnd)) {\n                // if childBlockNumber is between the upper and lower bounds of the headerBlock, we found our answer\n                ans = mid;\n                break;\n            } else if (headerStart.gt(childBlockNumber)) {\n                // childBlockNumber was checkpointed before this header\n                end = mid.sub(bigOne);\n            } else if (headerEnd.lt(childBlockNumber)) {\n                // childBlockNumber was checkpointed after this header\n                start = mid.add(bigOne);\n            }\n        }\n        return ans.mul(checkPointInterval);\n    }\n\n}","import { BaseToken, Web3SideChainClient } from \"../utils\";\nimport { IPOSClientConfig, ITransactionOption } from \"../interfaces\";\n\nexport class RootChainManager extends BaseToken<IPOSClientConfig> {\n\n    constructor(client_: Web3SideChainClient<IPOSClientConfig>, address: string) {\n        super({\n            address: address,\n            name: 'RootChainManager',\n            bridgeType: 'pos',\n            isParent: true\n        }, client_);\n    }\n\n    method(methodName: string, ...args) {\n        return this.getContract().then(contract => {\n            return contract.method(methodName, ...args);\n        });\n    }\n\n    deposit(userAddress: string, tokenAddress: string, depositData: string, option?: ITransactionOption) {\n        return this.method(\n            \"depositFor\",\n            userAddress,\n            tokenAddress,\n            depositData\n        ).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n    exit(exitPayload: string, option: ITransactionOption) {\n        return this.method(\"exit\", exitPayload).then(method => {\n            return this.processWrite(\n                method,\n                option\n            );\n        });\n    }\n\n    isExitProcessed(exitHash: string) {\n        return this.method(\n            \"processedExits\", exitHash\n        ).then(method => {\n            return this.processRead<boolean>(method);\n        });\n    }\n\n}","import { HttpRequest } from \"../utils\";\n\nexport class ABIService {\n    httpRequest: HttpRequest;\n\n    constructor(baseUrl: string) {\n        this.httpRequest = new HttpRequest(baseUrl);\n    }\n\n    getABI(network: string, version: string, bridgeType: string, contractName: string) {\n        const url = `${network}/${version}/artifacts/${bridgeType}/${contractName}.json`;\n        return this.httpRequest.get(url).then((result: any) => {\n            return result.abi;\n        });\n    }\n\n    getAddress(network: string, version: string) {\n        const url = `${network}/${version}/index.json`;\n        return this.httpRequest.get(url);\n    }\n}","import { ABIService } from \"./abi_service\";\nimport { config } from \"../config\";\nimport { NetworkService } from \"./network_service\";\n\nexport * from \"./network_service\";\n\nclass Service {\n    network: NetworkService;\n    abi: ABIService;\n}\n\nexport const service = new Service();\nservice.abi = new ABIService(config.abiStoreUrl);\n\n\n\n","import { BaseBigNumber, utils } from \"..\";\nimport { HttpRequest } from \"../utils\";\n\nexport class NetworkService {\n    httpRequest: HttpRequest;\n\n    constructor(baseUrl: string) {\n        this.httpRequest = new HttpRequest(baseUrl);\n    }\n\n    private createUrl(network: string, url: string) {\n        return `${network === 'mainnet' ? 'matic' : 'mumbai'}${url}`;\n    }\n\n    getBlockIncluded(network: string, blockNumber: number) {\n\n        const url = this.createUrl(network, `/block-included/${blockNumber}`);\n        return this.httpRequest.get<{\n            start: string;\n            end: string;\n            headerBlockNumber: BaseBigNumber;\n        }>(url).then(result => {\n            const headerBlockNumber = result.headerBlockNumber as any as string;\n            const decimalHeaderBlockNumber = headerBlockNumber.slice(0, 2) === '0x' ? parseInt(\n                headerBlockNumber, 16\n            ) : headerBlockNumber;\n            result.headerBlockNumber = new utils.BN(decimalHeaderBlockNumber);\n            return result;\n        });\n    }\n\n    getProof(network: string, start, end, blockNumber) {\n        const url = this.createUrl(network, `/fast-merkle-proof?start=${start}&end=${end}&number=${blockNumber}`);\n        return this.httpRequest.get<any>(url).then(result => {\n            return result.proof;\n        });\n    }\n}\n","import { BaseBigNumber } from \"../abstracts\";\n\nexport * from \"./pos_erc1155_deposit_param\";\nexport * from \"./pos_erc1155_transfer_param\";\n\nexport type TYPE_AMOUNT = BaseBigNumber | string | number;","import { service } from \"../services\";\nimport { resolve, promiseResolve } from \".\";\n\ntype T_ABI_CACHE = {\n    [networkName: string]: {\n        [version: string]: {\n            address: any,\n            abi: {\n                [bridgeType: string]: {\n                    [contractName: string]: any\n                }\n            }\n        }\n    }\n};\n\nconst cache: T_ABI_CACHE = {};\n\nexport class ABIManager {\n    constructor(public networkName: string, public version: string) {\n\n    }\n\n    init() {\n        return service.abi.getAddress(\n            this.networkName, this.version\n        ).then(result => {\n            cache[this.networkName] = {\n                [this.version]: {\n                    address: result,\n                    abi: {}\n                }\n            };\n        });\n    }\n\n    getConfig(path: string) {\n        return resolve(\n            cache[this.networkName][this.version].address,\n            path\n        );\n    }\n\n    getABI(contractName: string, bridgeType = 'plasma'): Promise<any> {\n        const targetBridgeABICache = cache[this.networkName][this.version].\n            abi[bridgeType];\n\n        if (targetBridgeABICache) {\n            const abiForContract = targetBridgeABICache[contractName];\n            if (abiForContract) {\n                return promiseResolve<any>(abiForContract);\n            }\n        }\n        return service.abi.getABI(\n            this.networkName,\n            this.version,\n            bridgeType,\n            contractName\n        ).then(result => {\n            this.setABI(contractName, bridgeType, result);\n            return result;\n        });\n    }\n\n    setABI(contractName: string, bridgeType: string, abi: any) {\n        const abiStore = cache[this.networkName][this.version].abi;\n        if (!abiStore[bridgeType]) {\n            abiStore[bridgeType] = {};\n        }\n        abiStore[bridgeType][contractName] = abi;\n    }\n}","import { Web3SideChainClient } from \"./web3_side_chain_client\";\nimport { ITransactionRequestConfig, ITransactionOption, IContractInitParam, IPOSClientConfig, IBaseClientConfig, ITransactionWriteResult } from \"../interfaces\";\nimport { BaseContractMethod, BaseContract, BaseWeb3Client } from \"../abstracts\";\nimport { Converter, merge } from \"../utils\";\nimport { promiseResolve } from \"./promise_resolve\";\nimport { ERROR_TYPE } from \"../enums\";\nimport { POSERC1155TransferParam, TYPE_AMOUNT } from \"../types\";\nimport { ErrorHelper } from \"./error_helper\";\n\nexport interface ITransactionConfigParam {\n    txConfig: ITransactionRequestConfig;\n    method?: BaseContractMethod;\n    isWrite?: boolean;\n    isParent?: boolean;\n}\n\nexport class BaseToken<T_CLIENT_CONFIG> {\n\n    private contract_: BaseContract;\n\n    constructor(\n        protected contractParam: IContractInitParam,\n        protected client: Web3SideChainClient<T_CLIENT_CONFIG>,\n    ) {\n    }\n\n\n    getContract(): Promise<BaseContract> {\n        if (this.contract_) {\n            return promiseResolve<BaseContract>(this.contract_ as any);\n        }\n        const contractParam = this.contractParam;\n        return this.client.getABI(\n            contractParam.name,\n            contractParam.bridgeType,\n        ).then(abi => {\n            this.contract_ = this.getContract_({\n                abi,\n                isParent: contractParam.isParent,\n                tokenAddress: contractParam.address\n            });\n            return this.contract_;\n        });\n    }\n\n    protected processWrite(method: BaseContractMethod, option: ITransactionOption = {}): Promise<ITransactionWriteResult> {\n        this.validateTxOption_(option);\n\n        this.client.logger.log(\"process write\");\n        return this.createTransactionConfig(\n            {\n                txConfig: option,\n                isWrite: true,\n                method,\n                isParent: this.contractParam.isParent\n            }).then(config => {\n                this.client.logger.log(\"process write config\");\n                if (option.returnTransaction) {\n                    return merge(config, {\n                        data: method.encodeABI(),\n                        to: method.address\n                    } as ITransactionRequestConfig);\n                }\n                const methodResult = method.write(\n                    config,\n                );\n                return methodResult;\n            });\n    }\n\n    protected sendTransaction(option: ITransactionOption = {}): Promise<ITransactionWriteResult> {\n        this.validateTxOption_(option);\n\n        const isParent = this.contractParam.isParent;\n        const client = this.getClient(isParent);\n        client.logger.log(\"process write\");\n\n        return this.createTransactionConfig(\n            {\n                txConfig: option,\n                isWrite: true,\n                method: null as any,\n                isParent: this.contractParam.isParent\n            }).then(config => {\n                client.logger.log(\"process write config\");\n                if (option.returnTransaction) {\n                    return config as any;\n                }\n                const methodResult = client.write(\n                    config,\n                );\n                return methodResult;\n            });\n    }\n\n    protected readTransaction(option: ITransactionOption = {}): Promise<ITransactionWriteResult> {\n        this.validateTxOption_(option);\n        const isParent = this.contractParam.isParent;\n        const client = this.getClient(isParent);\n        client.logger.log(\"process read\");\n        return this.createTransactionConfig(\n            {\n                txConfig: option,\n                isWrite: true,\n                method: null as any,\n                isParent: this.contractParam.isParent\n            }).then(config => {\n                client.logger.log(\"write tx config created\");\n                if (option.returnTransaction) {\n                    return config as any;\n                }\n                return client.read(\n                    config,\n                );\n            });\n    }\n\n    private validateTxOption_(option: ITransactionOption) {\n        if (typeof option !== 'object' || Array.isArray(option)) {\n            new ErrorHelper(ERROR_TYPE.TransactionOptionNotObject).throw();\n        }\n    }\n\n    protected processRead<T>(method: BaseContractMethod, option: ITransactionOption = {}): Promise<T> {\n        this.validateTxOption_(option);\n        this.client.logger.log(\"process read\");\n        return this.createTransactionConfig(\n            {\n                txConfig: option,\n                isWrite: false,\n                method,\n                isParent: this.contractParam.isParent\n            }).then(config => {\n                this.client.logger.log(\"read tx config created\");\n                if (option.returnTransaction) {\n                    return merge(config, {\n                        data: method.encodeABI(),\n                        to: this.contract_.address\n                    } as ITransactionRequestConfig);\n                }\n                return method.read(\n                    config,\n                );\n            });\n    }\n\n    protected getClient(isParent) {\n        return isParent ? this.client.parent :\n            this.client.child;\n    }\n\n    private getContract_({ isParent, tokenAddress, abi }) {\n        const client = this.getClient(isParent);\n        return client.getContract(tokenAddress, abi);\n    }\n\n    protected get parentDefaultConfig() {\n        const config: IBaseClientConfig = this.client.config as any;\n        return config.parent.defaultConfig;\n    }\n\n    protected get childDefaultConfig() {\n        const config: IBaseClientConfig = this.client.config as any;\n        return config.child.defaultConfig;\n    }\n\n    protected createTransactionConfig({ txConfig, method, isParent, isWrite }: ITransactionConfigParam) {\n        const defaultConfig = isParent ? this.parentDefaultConfig : this.childDefaultConfig;\n        txConfig = merge(defaultConfig, (txConfig || {}));\n        const client = isParent ? this.client.parent :\n            this.client.child;\n        client.logger.log(\"txConfig\", txConfig, \"onRoot\", isParent, \"isWrite\", isWrite);\n        const estimateGas = (config: ITransactionRequestConfig) => {\n            return method ? method.estimateGas(config) :\n                client.estimateGas(config);\n        };\n        // txConfig.chainId = Converter.toHex(txConfig.chainId) as any;\n        if (isWrite) {\n            const { maxFeePerGas, maxPriorityFeePerGas } = txConfig;\n            const isEIP1559Supported = this.client.isEIP1559Supported(isParent);\n            const isMaxFeeProvided = (maxFeePerGas || maxPriorityFeePerGas);\n\n            if (!isEIP1559Supported && isMaxFeeProvided) {\n                client.logger.error(ERROR_TYPE.EIP1559NotSupported, isParent).throw();\n            }\n            // const [gasLimit, nonce, chainId] = \n            return Promise.all([\n                !(txConfig.gasLimit)\n                    ? estimateGas({\n                        from: txConfig.from, value: txConfig.value\n                    })\n                    : txConfig.gasLimit,\n                !txConfig.nonce ?\n                    client.getTransactionCount(txConfig.from, 'pending')\n                    : txConfig.nonce,\n                !txConfig.chainId ?\n                    client.getChainId() : txConfig.chainId\n            ]).then(result => {\n                const [gasLimit, nonce, chainId] = result;\n                client.logger.log(\"options filled\");\n\n                txConfig.gasLimit = Number(gasLimit);\n                txConfig.nonce = nonce;\n                txConfig.chainId = chainId;\n                return txConfig;\n            });\n        }\n        return promiseResolve<ITransactionRequestConfig>(txConfig);\n    }\n\n    protected transferERC20(to: string, amount: TYPE_AMOUNT, option?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"transfer\",\n                to,\n                Converter.toHex(amount)\n            );\n            return this.processWrite(\n                method, option\n            );\n        });\n    }\n\n    protected transferERC721(from: string, to: string, tokenId: string, option: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"transferFrom\",\n                from,\n                to,\n                tokenId\n            );\n            return this.processWrite(\n                method, option\n            );\n        });\n    }\n\n    protected checkForRoot(methodName) {\n        if (!this.contractParam.isParent) {\n            this.client.logger.error(ERROR_TYPE.AllowedOnRoot, methodName).throw();\n        }\n    }\n\n    protected checkForChild(methodName) {\n        if (this.contractParam.isParent) {\n            this.client.logger.error(ERROR_TYPE.AllowedOnChild, methodName).throw();\n        }\n    }\n\n    protected transferERC1155(param: POSERC1155TransferParam, option: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"safeTransferFrom\",\n                param.from,\n                param.to,\n                Converter.toHex(param.tokenId),\n                Converter.toHex(param.amount),\n                param.data || '0x'\n            );\n            return this.processWrite(\n                method, option\n            );\n        });\n    }\n\n}","import { Web3SideChainClient } from \"../utils\";\nimport { ExitUtil } from \"../pos\";\nimport { BaseToken, utils } from \"..\";\n\nexport class BridgeClient<T> {\n\n    client: Web3SideChainClient<T> = new Web3SideChainClient();\n\n    exitUtil: ExitUtil;\n\n    /**\n     * check whether a txHash is checkPointed \n     *\n     * @param {string} txHash\n     * @returns\n     * @memberof BridgeClient\n     */\n    isCheckPointed(txHash: string) {\n        return this.exitUtil.isCheckPointed(\n            txHash\n        );\n    }\n\n    isDeposited(depositTxHash: string) {\n        const client = this.client;\n\n        const token = new BaseToken({\n            address: client.abiManager.getConfig(\"Matic.GenesisContracts.StateReceiver\"),\n            isParent: false,\n            name: 'StateReceiver',\n            bridgeType: 'genesis'\n        }, client);\n\n        return token.getContract().then(contract => {\n            return Promise.all([\n                client.parent.getTransactionReceipt(depositTxHash),\n                token['processRead']<string>(\n                    contract.method(\"lastStateId\")\n                )\n            ]);\n        }).then(result => {\n            const [receipt, lastStateId] = result;\n            const eventSignature = `0x103fed9db65eac19c4d870f49ab7520fe03b99f1838e5996caf47e9e43308392`;\n            const targetLog = receipt.logs.find(q => q.topics[0] === eventSignature);\n            if (!targetLog) {\n                throw new Error(\"StateSynced event not found\");\n            }\n            const rootStateId = client.child.decodeParameters(targetLog.topics[1], ['uint256'])[0];\n            const rootStateIdBN = utils.BN.isBN(rootStateId) ? rootStateId : new utils.BN(rootStateId);\n            return new utils.BN(lastStateId).gte(\n                rootStateIdBN\n            );\n        });\n    }\n\n}","import { BaseBigNumber } from \"../abstracts\";\nimport { utils } from \"../utils\";\n\nexport class Converter {\n    static toHex(amount: BaseBigNumber | string | number) {\n        const dataType = typeof amount;\n        if (dataType === 'number') {\n            amount = new utils.BN(amount);\n        } else if (dataType === 'string') {\n            if ((amount as string).slice(0, 2) === '0x') {\n                return amount;\n            }\n            amount = new utils.BN(amount);\n        }\n        if (utils.BN.isBN(amount)) {\n            return '0x' + amount.toString(16);\n        }\n        else {\n            throw new Error(`Invalid value ${amount}, value is not a number.`);\n        }\n    }\n}","import { ERROR_TYPE } from \"../enums\";\nimport { IError } from \"../interfaces\";\n\nexport class ErrorHelper implements IError {\n    type: ERROR_TYPE;\n    message: string;\n\n    constructor(type: ERROR_TYPE, info?) {\n        this.type = type;\n        this.message = this.getMsg_(info);\n    }\n\n    throw() {\n        throw this.get();\n    }\n\n    get() {\n        return {\n            message: this.message,\n            type: this.type\n        } as IError;\n    }\n\n    private getMsg_(info) {\n        let errMsg: string;\n        switch (this.type) {\n            case ERROR_TYPE.AllowedOnChild:\n                errMsg = `The action ${info} is allowed only on child token.`;\n                break;\n            case ERROR_TYPE.AllowedOnRoot:\n                errMsg = `The action ${info} is allowed only on root token.`;\n                break;\n            case ERROR_TYPE.ProofAPINotSet:\n                errMsg = `Proof api is not set, please set it using \"setProofApi\"`;\n                break;\n            case ERROR_TYPE.BurnTxNotCheckPointed:\n                errMsg = `Burn transaction has not been checkpointed as yet`;\n                break;\n            case ERROR_TYPE.EIP1559NotSupported:\n                errMsg = `${info ? 'Root' : 'Child'} chain doesn't support eip-1559`;\n                break;\n            default:\n                if (!this.type) {\n                    this.type = ERROR_TYPE.Unknown;\n                }\n                errMsg = this.message;\n                break;\n        }\n        return errMsg;\n    }\n}","export interface IEventBusPromise<T> extends Promise<T> {\n    on(event: string, cb: Function);\n    emit(event: string, ...args);\n    destroy();\n}\n\nexport const eventBusPromise = function <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void) {\n    const promise: IEventBusPromise<T> = new Promise(executor) as any;\n    const eventBus = new EventBus();\n    promise.on = eventBus.on.bind(eventBus);\n    promise.emit = eventBus.emit.bind(eventBus);\n    return promise;\n};\n\nexport class EventBus {\n\n    constructor(ctx?) {\n        this._ctx = ctx;\n    }\n\n    private _ctx;\n\n    private _events: {\n        [key: string]: Function[]\n    } = {};\n\n    on(event: string, cb: Function) {\n        if (this._events[event] == null) {\n            this._events[event] = [];\n        }\n        this._events[event].push(cb);\n        return this;\n    }\n\n    off(event: string, cb: Function) {\n        if (this._events[event]) {\n            if (cb) {\n                const index = this._events[event].indexOf(cb);\n                this._events[event].splice(index, 1);\n            }\n            else {\n                this._events[event] = [];\n            }\n        }\n    }\n\n    emit(event: string, ...args) {\n        const events = this._events[event] || [];\n        return Promise.all(\n            events.map(cb => {\n                const result = cb.call(this._ctx, ...args);\n                return result && result.then ? result : Promise.resolve(result);\n            })\n        );\n    }\n\n    destroy() {\n        this._events = null;\n        this._ctx = null;\n    }\n}","const fetch: (input: RequestInfo, init?: RequestInit) => Promise<Response> =\n    (() => {\n        if (process.env.BUILD_ENV === \"node\") {\n            return require('node-fetch').default;\n        }\n        return window.fetch;\n    })();\n\n\nexport class HttpRequest {\n    baseUrl = \"\";\n\n    constructor(option: { baseUrl: string } | string = {} as any) {\n        option = typeof option === \"string\" ? {\n            baseUrl: option\n        } : option;\n\n        if (option.baseUrl) {\n            this.baseUrl = option.baseUrl;\n        }\n    }\n\n    get<T>(url = \"\", query = {}): Promise<T> {\n        url = this.baseUrl + url + Object.keys(query).\n            map(key => `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`).join('&');\n\n        return fetch(url, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json'\n            }\n        }).then(res => {\n            return res.json();\n        });\n    }\n\n    post(url = \"\", body) {\n        url = this.baseUrl + url;\n\n        return fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json'\n            },\n            body: body ? JSON.stringify(body) : null\n        }).then(res => {\n            return res.json();\n        });\n    }\n}","import { BaseWeb3Client, Converter, TYPE_AMOUNT } from \"..\";\nimport { EmptyBigNumber } from \"../implementation\";\n\nexport * from \"./use\";\nexport * from \"./event_bus\";\nexport * from \"./logger\";\nexport * from \"./merge\";\nexport * from \"./map_promise\";\nexport * from \"./proof_util\";\nexport * from \"./http_request\";\nexport * from \"./converter\";\nexport * from \"./web3_side_chain_client\";\nexport * from \"./base_token\";\nexport * from \"./set_proof_api_url\";\nexport * from \"./resolve\";\nexport * from \"./promise_resolve\";\nexport * from \"./bridge_client\";\nexport * from \"./abi_manager\";\nexport * from \"./not_implemented\";\n\n\nexport const utils = {\n    converter: Converter,\n    Web3Client: BaseWeb3Client,\n    BN: EmptyBigNumber\n};","import { ERROR_TYPE } from \"../enums\";\nimport { ErrorHelper } from \"./error_helper\";\n\nexport class Logger {\n\n    private isEnabled: boolean;\n\n    enableLog(value) {\n        this.isEnabled = value ? true : false;\n    }\n\n    log(...message) {\n        if (this.isEnabled) {\n            console.log(...message);\n        }\n    }\n\n    error(type: ERROR_TYPE, info?) {\n        return new ErrorHelper(type, info);\n    }\n}","import { promiseResolve } from '..';\nimport { IMapPromiseOption } from '../interfaces';\n\nconst runPromises = (promises: Array<Promise<any>>, converter: Function) => {\n  const maps = promises.map((val, index) => {\n    return converter(val, index);\n  });\n  return Promise.all(maps);\n};\n\nexport function mapPromise(values: any[], converter: Function, option: IMapPromiseOption = {} as any) {\n  const valuesLength = values.length;\n  const concurrency = option.concurrency || valuesLength;\n\n  let result = [];\n  const limitPromiseRun: () => Promise<any> = () => {\n    const promises = values.splice(0, concurrency);\n    return runPromises(promises, converter).then(promiseResult => {\n      result = result.concat(promiseResult);\n\n      return valuesLength > result.length ?\n        limitPromiseRun() : promiseResolve(result);\n    });\n  };\n\n  return limitPromiseRun();\n}\n","export const merge = (...obj) => {\n    return Object.assign({}, ...obj);\n};","const utils = require('ethereumjs-util');\n// const SafeBuffer = require('safe-buffer').Buffer;\nconst sha3 = utils.keccak256;\n\nimport { Buffer as SafeBuffer } from \"safe-buffer\";\n\nexport class MerkleTree {\n    leaves: any;\n    layers: any;\n\n    constructor(leaves = []) {\n        if (leaves.length < 1) {\n            throw new Error('Atleast 1 leaf needed');\n        }\n\n        const depth = Math.ceil(Math.log(leaves.length) / Math.log(2));\n        if (depth > 20) {\n            throw new Error('Depth must be 20 or less');\n        }\n\n        this.leaves = leaves.concat(\n            Array.from(\n                // tslint:disable-next-line\n                Array(Math.pow(2, depth) - leaves.length),\n                () => utils.zeros(32)\n            )\n        );\n        this.layers = [this.leaves];\n        this.createHashes(this.leaves);\n    }\n\n    createHashes(nodes) {\n        if (nodes.length === 1) {\n            return false;\n        }\n\n\n        const treeLevel = [];\n        for (let i = 0; i < nodes.length; i += 2) {\n            const left = nodes[i];\n            const right = nodes[i + 1];\n\n            const data = SafeBuffer.concat([left, right]);\n            treeLevel.push(sha3(data));\n        }\n\n        // is odd number of nodes\n        if (nodes.length % 2 === 1) {\n            treeLevel.push(nodes[nodes.length - 1]);\n        }\n\n        this.layers.push(treeLevel);\n        this.createHashes(treeLevel);\n    }\n\n    getLeaves() {\n        return this.leaves;\n    }\n\n    getLayers() {\n        return this.layers;\n    }\n\n    getRoot() {\n        return this.layers[this.layers.length - 1][0];\n    }\n\n    getProof(leaf) {\n        let index = -1;\n        for (let i = 0; i < this.leaves.length; i++) {\n            if (SafeBuffer.compare(leaf, this.leaves[i]) === 0) {\n                index = i;\n            }\n        }\n\n        const proof = [];\n        if (index <= this.getLeaves().length) {\n            let siblingIndex;\n            for (let i = 0; i < this.layers.length - 1; i++) {\n                if (index % 2 === 0) {\n                    siblingIndex = index + 1;\n                } else {\n                    siblingIndex = index - 1;\n                }\n                index = Math.floor(index / 2);\n                proof.push(this.layers[i][siblingIndex]);\n            }\n        }\n        return proof;\n    }\n\n    verify(value, index, root, proof) {\n        if (!Array.isArray(proof) || !value || !root) {\n            return false;\n        }\n\n        let hash = value;\n        for (let i = 0; i < proof.length; i++) {\n            const node = proof[i];\n            if (index % 2 === 0) {\n                hash = sha3(SafeBuffer.concat([hash, node]));\n            } else {\n                hash = sha3(SafeBuffer.concat([node, hash]));\n            }\n\n            index = Math.floor(index / 2);\n        }\n\n        return SafeBuffer.compare(hash, root) === 0;\n    }\n}\n\n","export const throwNotImplemented = <T>() => {\n    throw new Error(\"not implemented\");\n    return '' as any as T;\n};","export const promiseResolve = <T>(value?) => {\n    return Promise.resolve<T>(value);\n};","import { BaseWeb3Client } from \"../abstracts\";\nimport { MerkleTree } from \"./merkle_tree\";\nimport ethUtils from \"ethereumjs-util\";\nimport { ITransactionReceipt, IBlock, IBlockWithTransaction } from \"../interfaces\";\nimport { mapPromise } from \"./map_promise\";\nconst TRIE = require('merkle-patricia-tree');\nconst rlp = ethUtils.rlp;\nimport EthereumBlock from 'ethereumjs-block/from-rpc';\nimport { Converter, promiseResolve, utils } from \"..\";\n\n// Implementation adapted from Tom French's `matic-proofs` library used under MIT License\n// https://github.com/TomAFrench/matic-proofs\n\nexport class ProofUtil {\n\n    static async getFastMerkleProof(\n        web3: BaseWeb3Client,\n        blockNumber: number,\n        startBlock: number,\n        endBlock: number\n    ): Promise<string[]> {\n        const merkleTreeDepth = Math.ceil(Math.log2(endBlock - startBlock + 1));\n\n        // We generate the proof root down, whereas we need from leaf up\n        const reversedProof: string[] = [];\n\n        const offset = startBlock;\n        const targetIndex = blockNumber - offset;\n        let leftBound = 0;\n        let rightBound = endBlock - offset;\n        //   console.log(\"Searching for\", targetIndex);\n        for (let depth = 0; depth < merkleTreeDepth; depth += 1) {\n            const nLeaves = 2 ** (merkleTreeDepth - depth);\n\n            // The pivot leaf is the last leaf which is included in the left subtree\n            const pivotLeaf = leftBound + nLeaves / 2 - 1;\n\n            if (targetIndex > pivotLeaf) {\n                // Get the root hash to the merkle subtree to the left\n                const newLeftBound = pivotLeaf + 1;\n                // eslint-disable-next-line no-await-in-loop\n                const subTreeMerkleRoot = await this.queryRootHash(web3, offset + leftBound, offset + pivotLeaf);\n                reversedProof.push(subTreeMerkleRoot);\n                leftBound = newLeftBound;\n            } else {\n                // Things are more complex when querying to the right.\n                // Root hash may come some layers down so we need to build a full tree by padding with zeros\n                // Some trees may be completely empty\n\n                const newRightBound = Math.min(rightBound, pivotLeaf);\n\n                // Expect the merkle tree to have a height one less than the current layer\n                const expectedHeight = merkleTreeDepth - (depth + 1);\n                if (rightBound <= pivotLeaf) {\n                    // Tree is empty so we repeatedly hash zero to correct height\n                    const subTreeMerkleRoot = this.recursiveZeroHash(expectedHeight, web3);\n                    reversedProof.push(subTreeMerkleRoot);\n                } else {\n                    // Height of tree given by RPC node\n                    const subTreeHeight = Math.ceil(Math.log2(rightBound - pivotLeaf));\n\n                    // Find the difference in height between this and the subtree we want\n                    const heightDifference = expectedHeight - subTreeHeight;\n\n                    // For every extra layer we need to fill 2*n leaves filled with the merkle root of a zero-filled Merkle tree\n                    // We need to build a tree which has heightDifference layers\n\n                    // The first leaf will hold the root hash as returned by the RPC\n                    // eslint-disable-next-line no-await-in-loop\n                    const remainingNodesHash = await this.queryRootHash(web3, offset + pivotLeaf + 1, offset + rightBound);\n\n                    // The remaining leaves will hold the merkle root of a zero-filled tree of height subTreeHeight\n                    const leafRoots = this.recursiveZeroHash(subTreeHeight, web3);\n\n                    // Build a merkle tree of correct size for the subtree using these merkle roots\n                    const leaves = Array.from({ length: 2 ** heightDifference }, () => ethUtils.toBuffer(leafRoots));\n                    leaves[0] = remainingNodesHash;\n                    const subTreeMerkleRoot = new MerkleTree(leaves).getRoot();\n                    reversedProof.push(subTreeMerkleRoot);\n                }\n                rightBound = newRightBound;\n            }\n        }\n\n        return reversedProof.reverse();\n    }\n\n    static buildBlockProof(maticWeb3: BaseWeb3Client, startBlock: number, endBlock: number, blockNumber: number) {\n        return ProofUtil.getFastMerkleProof(\n            maticWeb3, blockNumber, startBlock, endBlock\n        ).then(proof => {\n            return ethUtils.bufferToHex(\n                Buffer.concat(\n                    proof.map(p => {\n                        return ethUtils.toBuffer(p);\n                    })\n                )\n            );\n        });\n    }\n\n    static queryRootHash(client: BaseWeb3Client, startBlock: number, endBlock: number) {\n        return client.getRootHash(startBlock, endBlock).then(rootHash => {\n            return ethUtils.toBuffer(`0x${rootHash}`);\n        }).catch(_ => {\n            return null;\n        });\n    }\n\n    static recursiveZeroHash(n: number, client: BaseWeb3Client) {\n        if (n === 0) return '0x0000000000000000000000000000000000000000000000000000000000000000';\n        const subHash = this.recursiveZeroHash(n - 1, client);\n        return ethUtils.keccak256(\n            ethUtils.toBuffer(client.encodeParameters([subHash, subHash], ['bytes32', 'bytes32'],))\n        );\n    }\n\n    static getReceiptProof(receipt: ITransactionReceipt, block: IBlockWithTransaction, web3: BaseWeb3Client, requestConcurrency = Infinity, receiptsVal?: ITransactionReceipt[]) {\n        const stateSyncTxHash = ethUtils.bufferToHex(ProofUtil.getStateSyncTxHash(block));\n        const receiptsTrie = new TRIE();\n        let receiptPromise: Promise<ITransactionReceipt[]>;\n        if (!receiptsVal) {\n            const receiptPromises = [];\n            block.transactions.forEach(tx => {\n                if (tx.transactionHash === stateSyncTxHash) {\n                    // ignore if tx hash is bor state-sync tx\n                    return;\n                }\n                receiptPromises.push(\n                    web3.getTransactionReceipt(tx.transactionHash)\n                );\n            });\n            receiptPromise = mapPromise(\n                receiptPromises,\n                val => {\n                    return val;\n                },\n                {\n                    concurrency: requestConcurrency,\n                }\n            );\n        }\n        else {\n            receiptPromise = promiseResolve(receiptsVal);\n        }\n\n        return receiptPromise.then(receipts => {\n            return Promise.all(\n                receipts.map(siblingReceipt => {\n                    const path = rlp.encode(siblingReceipt.transactionIndex);\n                    const rawReceipt = ProofUtil.getReceiptBytes(siblingReceipt);\n                    return new Promise((resolve, reject) => {\n                        receiptsTrie.put(path, rawReceipt, err => {\n                            if (err) {\n                                reject(err);\n                            } else {\n                                resolve({});\n                            }\n                        });\n                    });\n                })\n            );\n        }).then(_ => {\n            // promise\n            return new Promise((resolve, reject) => {\n                receiptsTrie.findPath(rlp.encode(receipt.transactionIndex), (err, rawReceiptNode, reminder, stack) => {\n                    if (err) {\n                        return reject(err);\n                    }\n\n                    if (reminder.length > 0) {\n                        return reject(new Error('Node does not contain the key'));\n                    }\n\n                    const prf = {\n                        blockHash: ethUtils.toBuffer(receipt.blockHash),\n                        parentNodes: stack.map(s => s.raw),\n                        root: ProofUtil.getRawHeader(block).receiptTrie,\n                        path: rlp.encode(receipt.transactionIndex),\n                        value: ProofUtil.isTypedReceipt(receipt) ? rawReceiptNode.value : rlp.decode(rawReceiptNode.value)\n                    };\n                    resolve(prf);\n                });\n            });\n        });\n    }\n\n    static isTypedReceipt(receipt: ITransactionReceipt) {\n        const hexType = Converter.toHex(receipt.type);\n        return receipt.status != null && hexType !== \"0x0\" && hexType !== \"0x\";\n    }\n\n    // getStateSyncTxHash returns block's tx hash for state-sync receipt\n    // Bor blockchain includes extra receipt/tx for state-sync logs,\n    // but it is not included in transactionRoot or receiptRoot.\n    // So, while calculating proof, we have to exclude them.\n    //\n    // This is derived from block's hash and number\n    // state-sync tx hash = keccak256(\"matic-bor-receipt-\" + block.number + block.hash)\n    static getStateSyncTxHash(block): Buffer {\n        return ethUtils.keccak256(\n            Buffer.concat([\n                ethUtils.toBuffer('matic-bor-receipt-'), // prefix for bor receipt\n                ethUtils.setLengthLeft(ethUtils.toBuffer(block.number), 8), // 8 bytes of block number (BigEndian)\n                ethUtils.toBuffer(block.hash), // block hash\n            ])\n        );\n    }\n\n    static getReceiptBytes(receipt: ITransactionReceipt) {\n        let encodedData = rlp.encode([\n            ethUtils.toBuffer(\n                receipt.status !== undefined && receipt.status != null ? (receipt.status ? '0x1' : '0x') : receipt.root\n            ),\n            ethUtils.toBuffer(receipt.cumulativeGasUsed),\n            ethUtils.toBuffer(receipt.logsBloom),\n            // encoded log array\n            receipt.logs.map(l => {\n                // [address, [topics array], data]\n                return [\n                    ethUtils.toBuffer(l.address), // convert address to buffer\n                    l.topics.map(ethUtils.toBuffer), // convert topics to buffer\n                    ethUtils.toBuffer(l.data), // convert data to buffer\n                ];\n            }),\n        ]);\n        if (ProofUtil.isTypedReceipt(receipt)) {\n            encodedData = Buffer.concat([ethUtils.toBuffer(receipt.type), encodedData]);\n        }\n        return encodedData;\n    }\n\n    static getRawHeader(_block) {\n        if (typeof _block.difficulty !== 'string') {\n            _block.difficulty = '0x' + _block.difficulty.toString(16);\n        }\n        const block = new EthereumBlock(_block);\n        return block.header;\n    }\n}\n","export function resolve(obj, path) {\n    const properties = Array.isArray(path) ? path : path.split(\".\");\n    return properties.reduce((prev, curr) => prev && prev[curr], obj);\n}","import { service, NetworkService } from \"../services\";\n\nexport const setProofApi = (url: string) => {\n    const urlLength = url.length;\n    if (url[urlLength - 1] !== '/') {\n        url += '/';\n    }\n    url += 'api/v1/';\n    service.network = new NetworkService(url);\n};","import { IPlugin } from \"../interfaces\";\nimport { defaultExport } from \"../default\";\n\nexport const use = (plugin, ...payload) => {\n    const pluginInstance: IPlugin = typeof plugin === \"function\" ? new plugin() : plugin;\n    return pluginInstance.setup(defaultExport, ...payload);\n};","import { IBaseClientConfig } from \"../interfaces\";\nimport { BaseWeb3Client } from \"../abstracts\";\nimport { ABIManager } from \"../utils\";\nimport { Logger } from \"./logger\";\nimport { utils } from \"..\";\n\nexport class Web3SideChainClient<T_CONFIG> {\n    parent: BaseWeb3Client;\n    child: BaseWeb3Client;\n\n    config: T_CONFIG;\n\n    abiManager: ABIManager;\n\n    logger = new Logger();\n\n    init(config: IBaseClientConfig) {\n        config = config || {} as any;\n        config.parent.defaultConfig = config.parent.defaultConfig || {} as any;\n        config.child.defaultConfig = config.child.defaultConfig || {} as any;\n        this.config = config as any;\n\n        // tslint:disable-next-line\n        const Web3Client = utils.Web3Client;\n\n        if (!Web3Client) {\n            throw new Error(\"Web3Client is not set\");\n        }\n\n        this.parent = new (Web3Client as any)(config.parent.provider, this.logger);\n        this.child = new (Web3Client as any)(config.child.provider, this.logger);\n\n        this.logger.enableLog(config.log);\n\n        const network = config.network;\n        const version = config.version;\n        const abiManager = this.abiManager =\n            new ABIManager(network, version);\n        this.logger.log(\"init called\", abiManager);\n        return abiManager.init().catch(err => {\n            throw new Error(`network ${network} - ${version} is not supported`);\n        });\n    }\n\n    getABI(name: string, type?: string) {\n        return this.abiManager.getABI(name, type);\n    }\n\n    getConfig(path: string) {\n        return this.abiManager.getConfig(path);\n    }\n\n    get mainPlasmaContracts() {\n        return this.getConfig(\"Main.Contracts\");\n    }\n\n    get mainPOSContracts() {\n        return this.getConfig(\"Main.POSContracts\");\n    }\n\n    isEIP1559Supported(isParent: boolean): boolean {\n        return isParent ? this.getConfig(\"Main.SupportsEIP1559\") :\n            this.getConfig(\"Matic.SupportsEIP1559\");\n    }\n\n\n}\n\n","module.exports = require(\"buffer\");","module.exports = require(\"ethereumjs-tx\");","module.exports = require(\"ethereumjs-util\");","module.exports = require(\"merkle-patricia-tree\");","module.exports = require(\"node-fetch\");"],"sourceRoot":""}