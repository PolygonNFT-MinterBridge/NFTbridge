{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst deepEqual = require(\"fast-deep-equal\");\n\nconst assert = require(\"assert\");\n\nconst field_value_1 = require(\"./field-value\");\n\nconst path_1 = require(\"./path\");\n\nconst reference_1 = require(\"./reference\");\n\nconst types_1 = require(\"./types\");\n\nconst util_1 = require(\"./util\");\n/**\n * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.\n * Invoke `.build()' to assemble the final snapshot.\n *\n * @private\n */\n\n\nclass DocumentSnapshotBuilder {\n  // We include the DocumentReference in the constructor in order to allow the\n  // DocumentSnapshotBuilder to be typed with <T> when it is constructed.\n  constructor(ref) {\n    this.ref = ref;\n  }\n  /**\n   * Builds the DocumentSnapshot.\n   *\n   * @private\n   * @returns Returns either a QueryDocumentSnapshot (if `fieldsProto` was\n   * provided) or a DocumentSnapshot.\n   */\n\n\n  build() {\n    assert(this.fieldsProto !== undefined === (this.createTime !== undefined), 'Create time should be set iff document exists.');\n    assert(this.fieldsProto !== undefined === (this.updateTime !== undefined), 'Update time should be set iff document exists.');\n    return this.fieldsProto ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime) : new DocumentSnapshot(this.ref, undefined, this.readTime);\n  }\n\n}\n\nexports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;\n/**\n * A DocumentSnapshot is an immutable representation for a document in a\n * Firestore database. The data can be extracted with\n * [data()]{@link DocumentSnapshot#data} or\n * [get(fieldPath)]{@link DocumentSnapshot#get} to get a\n * specific field.\n *\n * <p>For a DocumentSnapshot that points to a non-existing document, any data\n * access will return 'undefined'. You can use the\n * [exists]{@link DocumentSnapshot#exists} property to explicitly verify a\n * document's existence.\n *\n * @class DocumentSnapshot\n */\n\nclass DocumentSnapshot {\n  /**\n   * @hideconstructor\n   *\n   * @param ref The reference to the document.\n   * @param _fieldsProto The fields of the Firestore `Document` Protobuf backing\n   * this document (or undefined if the document does not exist).\n   * @param readTime The time when this snapshot was read  (or undefined if\n   * the document exists only locally).\n   * @param createTime The time when the document was created (or undefined if\n   * the document does not exist).\n   * @param updateTime The time when the document was last updated (or undefined\n   * if the document does not exist).\n   */\n  constructor(ref, _fieldsProto, readTime, createTime, updateTime) {\n    this._fieldsProto = _fieldsProto;\n    this._ref = ref;\n    this._serializer = ref.firestore._serializer;\n    this._readTime = readTime;\n    this._createTime = createTime;\n    this._updateTime = updateTime;\n  }\n  /**\n   * Creates a DocumentSnapshot from an object.\n   *\n   * @private\n   * @param ref The reference to the document.\n   * @param obj The object to store in the DocumentSnapshot.\n   * @return The created DocumentSnapshot.\n   */\n\n\n  static fromObject(ref, obj) {\n    const serializer = ref.firestore._serializer;\n    return new DocumentSnapshot(ref, serializer.encodeFields(obj));\n  }\n  /**\n   * Creates a DocumentSnapshot from an UpdateMap.\n   *\n   * This methods expands the top-level field paths in a JavaScript map and\n   * turns { foo.bar : foobar } into { foo { bar : foobar }}\n   *\n   * @private\n   * @param ref The reference to the document.\n   * @param data The field/value map to expand.\n   * @return The created DocumentSnapshot.\n   */\n\n\n  static fromUpdateMap(ref, data) {\n    const serializer = ref.firestore._serializer;\n    /**\n     * Merges 'value' at the field path specified by the path array into\n     * 'target'.\n     */\n\n    function merge(target, value, path, pos) {\n      const key = path[pos];\n      const isLast = pos === path.length - 1;\n\n      if (target[key] === undefined) {\n        if (isLast) {\n          if (value instanceof field_value_1.FieldTransform) {\n            // If there is already data at this path, we need to retain it.\n            // Otherwise, we don't include it in the DocumentSnapshot.\n            return !util_1.isEmpty(target) ? target : null;\n          } // The merge is done.\n\n\n          const leafNode = serializer.encodeValue(value);\n\n          if (leafNode) {\n            target[key] = leafNode;\n          }\n\n          return target;\n        } else {\n          // We need to expand the target object.\n          const childNode = {\n            mapValue: {\n              fields: {}\n            }\n          };\n          const nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);\n\n          if (nestedValue) {\n            childNode.mapValue.fields = nestedValue;\n            target[key] = childNode;\n            return target;\n          } else {\n            return !util_1.isEmpty(target) ? target : null;\n          }\n        }\n      } else {\n        assert(!isLast, \"Can't merge current value into a nested object\");\n        target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);\n        return target;\n      }\n    }\n\n    const res = {};\n\n    for (const [key, value] of data) {\n      const path = key.toArray();\n      merge(res, value, path, 0);\n    }\n\n    return new DocumentSnapshot(ref, res);\n  }\n  /**\n   * True if the document exists.\n   *\n   * @type {boolean}\n   * @name DocumentSnapshot#exists\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then((documentSnapshot) => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(`Data: ${JSON.stringify(documentSnapshot.data())}`);\n   *   }\n   * });\n   */\n\n\n  get exists() {\n    return this._fieldsProto !== undefined;\n  }\n  /**\n   * A [DocumentReference]{@link DocumentReference} for the document\n   * stored in this snapshot.\n   *\n   * @type {DocumentReference}\n   * @name DocumentSnapshot#ref\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then((documentSnapshot) => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(`Found document at '${documentSnapshot.ref.path}'`);\n   *   }\n   * });\n   */\n\n\n  get ref() {\n    return this._ref;\n  }\n  /**\n   * The ID of the document for which this DocumentSnapshot contains data.\n   *\n   * @type {string}\n   * @name DocumentSnapshot#id\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then((documentSnapshot) => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(`Document found with name '${documentSnapshot.id}'`);\n   *   }\n   * });\n   */\n\n\n  get id() {\n    return this._ref.id;\n  }\n  /**\n   * The time the document was created. Undefined for documents that don't\n   * exist.\n   *\n   * @type {Timestamp|undefined}\n   * @name DocumentSnapshot#createTime\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     let createTime = documentSnapshot.createTime;\n   *     console.log(`Document created at '${createTime.toDate()}'`);\n   *   }\n   * });\n   */\n\n\n  get createTime() {\n    return this._createTime;\n  }\n  /**\n   * The time the document was last updated (at the time the snapshot was\n   * generated). Undefined for documents that don't exist.\n   *\n   * @type {Timestamp|undefined}\n   * @name DocumentSnapshot#updateTime\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     let updateTime = documentSnapshot.updateTime;\n   *     console.log(`Document updated at '${updateTime.toDate()}'`);\n   *   }\n   * });\n   */\n\n\n  get updateTime() {\n    return this._updateTime;\n  }\n  /**\n   * The time this snapshot was read.\n   *\n   * @type {Timestamp}\n   * @name DocumentSnapshot#readTime\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   let readTime = documentSnapshot.readTime;\n   *   console.log(`Document read at '${readTime.toDate()}'`);\n   * });\n   */\n\n\n  get readTime() {\n    if (this._readTime === undefined) {\n      throw new Error(\"Called 'readTime' on a local document\");\n    }\n\n    return this._readTime;\n  }\n  /**\n   * Retrieves all fields in the document as an object. Returns 'undefined' if\n   * the document doesn't exist.\n   *\n   * @returns {T|undefined} An object containing all fields in the document or\n   * 'undefined' if the document doesn't exist.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   let data = documentSnapshot.data();\n   *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n   * });\n   */\n\n\n  data() {\n    const fields = this._fieldsProto;\n\n    if (fields === undefined) {\n      return undefined;\n    } // We only want to use the converter and create a new QueryDocumentSnapshot\n    // if a converter has been provided.\n\n\n    if (this.ref._converter !== types_1.defaultConverter()) {\n      const untypedReference = new reference_1.DocumentReference(this.ref.firestore, this.ref._path);\n      return this.ref._converter.fromFirestore(new QueryDocumentSnapshot(untypedReference, this._fieldsProto, this.readTime, this.createTime, this.updateTime));\n    } else {\n      const obj = {};\n\n      for (const prop of Object.keys(fields)) {\n        obj[prop] = this._serializer.decodeValue(fields[prop]);\n      }\n\n      return obj;\n    }\n  }\n  /**\n   * Retrieves the field specified by `field`.\n   *\n   * @param {string|FieldPath} field The field path\n   * (e.g. 'foo' or 'foo.bar') to a specific field.\n   * @returns {*} The data at the specified field location or undefined if no\n   * such field exists.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({ a: { b: 'c' }}).then(() => {\n   *   return documentRef.get();\n   * }).then(documentSnapshot => {\n   *   let field = documentSnapshot.get('a.b');\n   *   console.log(`Retrieved field value: ${field}`);\n   * });\n   */\n  // We deliberately use `any` in the external API to not impose type-checking\n  // on end users.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  get(field) {\n    path_1.validateFieldPath('field', field);\n    const protoField = this.protoField(field);\n\n    if (protoField === undefined) {\n      return undefined;\n    }\n\n    return this._serializer.decodeValue(protoField);\n  }\n  /**\n   * Retrieves the field specified by 'fieldPath' in its Protobuf JS\n   * representation.\n   *\n   * @private\n   * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.\n   * @returns The Protobuf-encoded data at the specified field location or\n   * undefined if no such field exists.\n   */\n\n\n  protoField(field) {\n    let fields = this._fieldsProto;\n\n    if (fields === undefined) {\n      return undefined;\n    }\n\n    const components = path_1.FieldPath.fromArgument(field).toArray();\n\n    while (components.length > 1) {\n      fields = fields[components.shift()];\n\n      if (!fields || !fields.mapValue) {\n        return undefined;\n      }\n\n      fields = fields.mapValue.fields;\n    }\n\n    return fields[components[0]];\n  }\n  /**\n   * Convert a document snapshot to the Firestore 'Write' proto.\n   *\n   * @private\n   */\n\n\n  toWriteProto() {\n    return {\n      update: {\n        name: this._ref.formattedName,\n        fields: this._fieldsProto\n      }\n    };\n  }\n  /**\n   * Convert a document snapshot to the Firestore 'Document' proto.\n   *\n   * @private\n   */\n\n\n  toDocumentProto() {\n    var _a, _b;\n\n    return {\n      name: this._ref.formattedName,\n      createTime: (_a = this.createTime) === null || _a === void 0 ? void 0 : _a.toProto().timestampValue,\n      updateTime: (_b = this.updateTime) === null || _b === void 0 ? void 0 : _b.toProto().timestampValue,\n      fields: this._fieldsProto\n    };\n  }\n  /**\n   * Returns true if the document's data and path in this `DocumentSnapshot` is\n   * equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `DocumentSnapshot` is equal to the provided\n   * value.\n   */\n\n\n  isEqual(other) {\n    // Since the read time is different on every document read, we explicitly\n    // ignore all document metadata in this comparison.\n    return this === other || other instanceof DocumentSnapshot && this._ref.isEqual(other._ref) && deepEqual(this._fieldsProto, other._fieldsProto);\n  }\n\n}\n\nexports.DocumentSnapshot = DocumentSnapshot;\n/**\n * A QueryDocumentSnapshot contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with [data()]{@link QueryDocumentSnapshot#data}\n * or [get()]{@link DocumentSnapshot#get} to get a specific field.\n *\n * A QueryDocumentSnapshot offers the same API surface as a\n * {@link DocumentSnapshot}. Since query results contain only existing\n * documents, the [exists]{@link DocumentSnapshot#exists} property will\n * always be true and [data()]{@link QueryDocumentSnapshot#data} will never\n * return 'undefined'.\n *\n * @class QueryDocumentSnapshot\n * @extends DocumentSnapshot\n */\n\nclass QueryDocumentSnapshot extends DocumentSnapshot {\n  /**\n   * The time the document was created.\n   *\n   * @type {Timestamp}\n   * @name QueryDocumentSnapshot#createTime\n   * @readonly\n   * @override\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.get().forEach(snapshot => {\n   *   console.log(`Document created at '${snapshot.createTime.toDate()}'`);\n   * });\n   */\n  get createTime() {\n    return super.createTime;\n  }\n  /**\n   * The time the document was last updated (at the time the snapshot was\n   * generated).\n   *\n   * @type {Timestamp}\n   * @name QueryDocumentSnapshot#updateTime\n   * @readonly\n   * @override\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.get().forEach(snapshot => {\n   *   console.log(`Document updated at '${snapshot.updateTime.toDate()}'`);\n   * });\n   */\n\n\n  get updateTime() {\n    return super.updateTime;\n  }\n  /**\n   * Retrieves all fields in the document as an object.\n   *\n   * @override\n   *\n   * @returns {T} An object containing all fields in the document.\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.get().forEach(documentSnapshot => {\n   *   let data = documentSnapshot.data();\n   *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n   * });\n   */\n\n\n  data() {\n    const data = super.data();\n\n    if (!data) {\n      throw new Error('The data in a QueryDocumentSnapshot should always exist.');\n    }\n\n    return data;\n  }\n\n}\n\nexports.QueryDocumentSnapshot = QueryDocumentSnapshot;\n/**\n * A Firestore Document Mask contains the field paths affected by an update.\n *\n * @class\n * @private\n */\n\nclass DocumentMask {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param fieldPaths The field paths in this mask.\n   */\n  constructor(fieldPaths) {\n    this._sortedPaths = fieldPaths;\n\n    this._sortedPaths.sort((a, b) => a.compareTo(b));\n  }\n  /**\n   * Creates a document mask with the field paths of a document.\n   *\n   * @private\n   * @param data A map with fields to modify. Only the keys are used to extract\n   * the document mask.\n   */\n\n\n  static fromUpdateMap(data) {\n    const fieldPaths = [];\n    data.forEach((value, key) => {\n      if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) {\n        fieldPaths.push(path_1.FieldPath.fromArgument(key));\n      }\n    });\n    return new DocumentMask(fieldPaths);\n  }\n  /**\n   * Creates a document mask from an array of field paths.\n   *\n   * @private\n   * @param fieldMask A list of field paths.\n   */\n\n\n  static fromFieldMask(fieldMask) {\n    const fieldPaths = [];\n\n    for (const fieldPath of fieldMask) {\n      fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));\n    }\n\n    return new DocumentMask(fieldPaths);\n  }\n  /**\n   * Creates a document mask with the field names of a document.\n   *\n   * @private\n   * @param data An object with fields to modify. Only the keys are used to\n   * extract the document mask.\n   */\n\n\n  static fromObject(data) {\n    const fieldPaths = [];\n\n    function extractFieldPaths(currentData, currentPath) {\n      let isEmpty = true;\n\n      for (const key of Object.keys(currentData)) {\n        isEmpty = false; // We don't split on dots since fromObject is called with\n        // DocumentData.\n\n        const childSegment = new path_1.FieldPath(key);\n        const childPath = currentPath ? currentPath.append(childSegment) : childSegment;\n        const value = currentData[key];\n\n        if (value instanceof field_value_1.FieldTransform) {\n          if (value.includeInDocumentMask) {\n            fieldPaths.push(childPath);\n          }\n        } else if (util_1.isPlainObject(value)) {\n          extractFieldPaths(value, childPath);\n        } else if (value !== undefined) {\n          // If the value is undefined it can never participate in the document\n          // mask. With `ignoreUndefinedProperties` set to false,\n          // `validateDocumentData` will reject an undefined value before even\n          // computing the document mask.\n          fieldPaths.push(childPath);\n        }\n      } // Add a field path for an explicitly updated empty map.\n\n\n      if (currentPath && isEmpty) {\n        fieldPaths.push(currentPath);\n      }\n    }\n\n    extractFieldPaths(data);\n    return new DocumentMask(fieldPaths);\n  }\n  /**\n   * Returns true if this document mask contains no fields.\n   *\n   * @private\n   * @return {boolean} Whether this document mask is empty.\n   */\n\n\n  get isEmpty() {\n    return this._sortedPaths.length === 0;\n  }\n  /**\n   * Removes the specified values from a sorted field path array.\n   *\n   * @private\n   * @param input A sorted array of FieldPaths.\n   * @param values An array of FieldPaths to remove.\n   */\n\n\n  static removeFromSortedArray(input, values) {\n    for (let i = 0; i < input.length;) {\n      let removed = false;\n\n      for (const fieldPath of values) {\n        if (input[i].isEqual(fieldPath)) {\n          input.splice(i, 1);\n          removed = true;\n          break;\n        }\n      }\n\n      if (!removed) {\n        ++i;\n      }\n    }\n  }\n  /**\n   * Removes the field path specified in 'fieldPaths' from this document mask.\n   *\n   * @private\n   * @param fieldPaths An array of FieldPaths.\n   */\n\n\n  removeFields(fieldPaths) {\n    DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);\n  }\n  /**\n   * Returns whether this document mask contains 'fieldPath'.\n   *\n   * @private\n   * @param fieldPath The field path to test.\n   * @return Whether this document mask contains 'fieldPath'.\n   */\n\n\n  contains(fieldPath) {\n    for (const sortedPath of this._sortedPaths) {\n      const cmp = sortedPath.compareTo(fieldPath);\n\n      if (cmp === 0) {\n        return true;\n      } else if (cmp > 0) {\n        return false;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Removes all properties from 'data' that are not contained in this document\n   * mask.\n   *\n   * @private\n   * @param data An object to filter.\n   * @return A shallow copy of the object filtered by this document mask.\n   */\n\n\n  applyTo(data) {\n    /*!\n     * Applies this DocumentMask to 'data' and computes the list of field paths\n     * that were specified in the mask but are not present in 'data'.\n     */\n    const applyDocumentMask = data => {\n      const remainingPaths = this._sortedPaths.slice(0);\n\n      const processObject = (currentData, currentPath) => {\n        let result = null;\n        Object.keys(currentData).forEach(key => {\n          const childPath = currentPath ? currentPath.append(key) : new path_1.FieldPath(key);\n\n          if (this.contains(childPath)) {\n            DocumentMask.removeFromSortedArray(remainingPaths, [childPath]);\n            result = result || {};\n            result[key] = currentData[key];\n          } else if (util_1.isObject(currentData[key])) {\n            const childObject = processObject(currentData[key], childPath);\n\n            if (childObject) {\n              result = result || {};\n              result[key] = childObject;\n            }\n          }\n        });\n        return result;\n      }; // processObject() returns 'null' if the DocumentMask is empty.\n\n\n      const filteredData = processObject(data) || {};\n      return {\n        filteredData,\n        remainingPaths\n      };\n    };\n\n    const result = applyDocumentMask(data);\n\n    if (result.remainingPaths.length !== 0) {\n      throw new Error(`Input data is missing for field \"${result.remainingPaths[0]}\".`);\n    }\n\n    return result.filteredData;\n  }\n  /**\n   * Converts a document mask to the Firestore 'DocumentMask' Proto.\n   *\n   * @private\n   * @returns A Firestore 'DocumentMask' Proto.\n   */\n\n\n  toProto() {\n    if (this.isEmpty) {\n      return {};\n    }\n\n    const encodedPaths = [];\n\n    for (const fieldPath of this._sortedPaths) {\n      encodedPaths.push(fieldPath.formattedName);\n    }\n\n    return {\n      fieldPaths: encodedPaths\n    };\n  }\n\n}\n\nexports.DocumentMask = DocumentMask;\n/**\n * A Firestore Document Transform.\n *\n * A DocumentTransform contains pending server-side transforms and their\n * corresponding field paths.\n *\n * @private\n * @class\n */\n\nclass DocumentTransform {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param ref The DocumentReference for this transform.\n   * @param transforms A Map of FieldPaths to FieldTransforms.\n   */\n  constructor(ref, transforms) {\n    this.ref = ref;\n    this.transforms = transforms;\n  }\n  /**\n   * Generates a DocumentTransform from a JavaScript object.\n   *\n   * @private\n   * @param ref The `DocumentReference` to use for the DocumentTransform.\n   * @param obj The object to extract the transformations from.\n   * @returns The Document Transform.\n   */\n\n\n  static fromObject(ref, obj) {\n    const updateMap = new Map();\n\n    for (const prop of Object.keys(obj)) {\n      updateMap.set(new path_1.FieldPath(prop), obj[prop]);\n    }\n\n    return DocumentTransform.fromUpdateMap(ref, updateMap);\n  }\n  /**\n   * Generates a DocumentTransform from an Update Map.\n   *\n   * @private\n   * @param ref The `DocumentReference` to use for the DocumentTransform.\n   * @param data The update data to extract the transformations from.\n   * @returns The Document Transform.\n   */\n\n\n  static fromUpdateMap(ref, data) {\n    const transforms = new Map();\n\n    function encode_(val, path, allowTransforms) {\n      if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) {\n        if (allowTransforms) {\n          transforms.set(path, val);\n        } else {\n          throw new Error(`${val.methodName}() is not supported inside of array values.`);\n        }\n      } else if (Array.isArray(val)) {\n        for (let i = 0; i < val.length; ++i) {\n          // We need to verify that no array value contains a document transform\n          encode_(val[i], path.append(String(i)), false);\n        }\n      } else if (util_1.isPlainObject(val)) {\n        for (const prop of Object.keys(val)) {\n          encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);\n        }\n      }\n    }\n\n    data.forEach((value, key) => {\n      encode_(value, path_1.FieldPath.fromArgument(key), true);\n    });\n    return new DocumentTransform(ref, transforms);\n  }\n  /**\n   * Whether this DocumentTransform contains any actionable transformations.\n   *\n   * @private\n   */\n\n\n  get isEmpty() {\n    return this.transforms.size === 0;\n  }\n  /**\n   * Returns the array of fields in this DocumentTransform.\n   *\n   * @private\n   */\n\n\n  get fields() {\n    return Array.from(this.transforms.keys());\n  }\n  /**\n   * Validates the user provided field values in this document transform.\n   * @private\n   */\n\n\n  validate() {\n    const allowUndefined = !!this.ref.firestore._settings.ignoreUndefinedProperties;\n    this.transforms.forEach(transform => transform.validate(allowUndefined));\n  }\n  /**\n   * Converts a document transform to the Firestore 'FieldTransform' Proto.\n   *\n   * @private\n   * @param serializer The Firestore serializer\n   * @returns A list of Firestore 'FieldTransform' Protos\n   */\n\n\n  toProto(serializer) {\n    return Array.from(this.transforms, ([path, transform]) => transform.toProto(serializer, path));\n  }\n\n}\n\nexports.DocumentTransform = DocumentTransform;\n/**\n * A Firestore Precondition encapsulates options for database writes.\n *\n * @private\n * @class\n */\n\nclass Precondition {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param options.exists - Whether the referenced document should exist in\n   * Firestore,\n   * @param options.lastUpdateTime - The last update time of the referenced\n   * document in Firestore.\n   * @param options\n   */\n  constructor(options) {\n    if (options !== undefined) {\n      this._exists = options.exists;\n      this._lastUpdateTime = options.lastUpdateTime;\n    }\n  }\n  /**\n   * Generates the Protobuf `Preconditon` object for this precondition.\n   *\n   * @private\n   * @returns The `Preconditon` Protobuf object or 'null' if there are no\n   * preconditions.\n   */\n\n\n  toProto() {\n    if (this.isEmpty) {\n      return null;\n    }\n\n    const proto = {};\n\n    if (this._lastUpdateTime !== undefined) {\n      proto.updateTime = this._lastUpdateTime.toProto().timestampValue;\n    } else {\n      proto.exists = this._exists;\n    }\n\n    return proto;\n  }\n  /**\n   * Whether this DocumentTransform contains any enforcement.\n   *\n   * @private\n   */\n\n\n  get isEmpty() {\n    return this._exists === undefined && !this._lastUpdateTime;\n  }\n\n}\n\nexports.Precondition = Precondition;","map":{"version":3,"sources":["/Users/pulkitmittal/nft-bridge/NFTbridge/node_modules/@google-cloud/firestore/build/src/document.js"],"names":["Object","defineProperty","exports","value","deepEqual","require","assert","field_value_1","path_1","reference_1","types_1","util_1","DocumentSnapshotBuilder","constructor","ref","build","fieldsProto","undefined","createTime","updateTime","QueryDocumentSnapshot","readTime","DocumentSnapshot","_fieldsProto","_ref","_serializer","firestore","_readTime","_createTime","_updateTime","fromObject","obj","serializer","encodeFields","fromUpdateMap","data","merge","target","path","pos","key","isLast","length","FieldTransform","isEmpty","leafNode","encodeValue","childNode","mapValue","fields","nestedValue","res","toArray","exists","id","Error","_converter","defaultConverter","untypedReference","DocumentReference","_path","fromFirestore","prop","keys","decodeValue","get","field","validateFieldPath","protoField","components","FieldPath","fromArgument","shift","toWriteProto","update","name","formattedName","toDocumentProto","_a","_b","toProto","timestampValue","isEqual","other","DocumentMask","fieldPaths","_sortedPaths","sort","a","b","compareTo","forEach","includeInDocumentMask","push","fromFieldMask","fieldMask","fieldPath","extractFieldPaths","currentData","currentPath","childSegment","childPath","append","isPlainObject","removeFromSortedArray","input","values","i","removed","splice","removeFields","contains","sortedPath","cmp","applyTo","applyDocumentMask","remainingPaths","slice","processObject","result","isObject","childObject","filteredData","encodedPaths","DocumentTransform","transforms","updateMap","Map","set","encode_","val","allowTransforms","includeInDocumentTransform","methodName","Array","isArray","String","size","from","validate","allowUndefined","_settings","ignoreUndefinedProperties","transform","Precondition","options","_exists","_lastUpdateTime","lastUpdateTime","proto"],"mappings":"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CA;AACA;;;AACc,MAANE,MAAM,GAAG;AACT,WAAO,KAAK9B,YAAL,KAAsBN,SAA7B;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACW,MAAHH,GAAG,GAAG;AACN,WAAO,KAAKU,IAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACU,MAAF8B,EAAE,GAAG;AACL,WAAO,KAAK9B,IAAL,CAAU8B,EAAjB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACkB,MAAVpC,UAAU,GAAG;AACb,WAAO,KAAKU,WAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACkB,MAAVT,UAAU,GAAG;AACb,WAAO,KAAKU,WAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgB,MAARR,QAAQ,GAAG;AACX,QAAI,KAAKM,SAAL,KAAmBV,SAAvB,EAAkC;AAC9B,YAAM,IAAIsC,KAAJ,CAAU,uCAAV,CAAN;AACH;;AACD,WAAO,KAAK5B,SAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIQ,EAAAA,IAAI,GAAG;AACH,UAAMc,MAAM,GAAG,KAAK1B,YAApB;;AACA,QAAI0B,MAAM,KAAKhC,SAAf,EAA0B;AACtB,aAAOA,SAAP;AACH,KAJE,CAKH;AACA;;;AACA,QAAI,KAAKH,GAAL,CAAS0C,UAAT,KAAwB9C,OAAO,CAAC+C,gBAAR,EAA5B,EAAwD;AACpD,YAAMC,gBAAgB,GAAG,IAAIjD,WAAW,CAACkD,iBAAhB,CAAkC,KAAK7C,GAAL,CAASY,SAA3C,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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst deepEqual = require(\"fast-deep-equal\");\nconst assert = require(\"assert\");\nconst field_value_1 = require(\"./field-value\");\nconst path_1 = require(\"./path\");\nconst reference_1 = require(\"./reference\");\nconst types_1 = require(\"./types\");\nconst util_1 = require(\"./util\");\n/**\n * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.\n * Invoke `.build()' to assemble the final snapshot.\n *\n * @private\n */\nclass DocumentSnapshotBuilder {\n    // We include the DocumentReference in the constructor in order to allow the\n    // DocumentSnapshotBuilder to be typed with <T> when it is constructed.\n    constructor(ref) {\n        this.ref = ref;\n    }\n    /**\n     * Builds the DocumentSnapshot.\n     *\n     * @private\n     * @returns Returns either a QueryDocumentSnapshot (if `fieldsProto` was\n     * provided) or a DocumentSnapshot.\n     */\n    build() {\n        assert((this.fieldsProto !== undefined) === (this.createTime !== undefined), 'Create time should be set iff document exists.');\n        assert((this.fieldsProto !== undefined) === (this.updateTime !== undefined), 'Update time should be set iff document exists.');\n        return this.fieldsProto\n            ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime)\n            : new DocumentSnapshot(this.ref, undefined, this.readTime);\n    }\n}\nexports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;\n/**\n * A DocumentSnapshot is an immutable representation for a document in a\n * Firestore database. The data can be extracted with\n * [data()]{@link DocumentSnapshot#data} or\n * [get(fieldPath)]{@link DocumentSnapshot#get} to get a\n * specific field.\n *\n * <p>For a DocumentSnapshot that points to a non-existing document, any data\n * access will return 'undefined'. You can use the\n * [exists]{@link DocumentSnapshot#exists} property to explicitly verify a\n * document's existence.\n *\n * @class DocumentSnapshot\n */\nclass DocumentSnapshot {\n    /**\n     * @hideconstructor\n     *\n     * @param ref The reference to the document.\n     * @param _fieldsProto The fields of the Firestore `Document` Protobuf backing\n     * this document (or undefined if the document does not exist).\n     * @param readTime The time when this snapshot was read  (or undefined if\n     * the document exists only locally).\n     * @param createTime The time when the document was created (or undefined if\n     * the document does not exist).\n     * @param updateTime The time when the document was last updated (or undefined\n     * if the document does not exist).\n     */\n    constructor(ref, _fieldsProto, readTime, createTime, updateTime) {\n        this._fieldsProto = _fieldsProto;\n        this._ref = ref;\n        this._serializer = ref.firestore._serializer;\n        this._readTime = readTime;\n        this._createTime = createTime;\n        this._updateTime = updateTime;\n    }\n    /**\n     * Creates a DocumentSnapshot from an object.\n     *\n     * @private\n     * @param ref The reference to the document.\n     * @param obj The object to store in the DocumentSnapshot.\n     * @return The created DocumentSnapshot.\n     */\n    static fromObject(ref, obj) {\n        const serializer = ref.firestore._serializer;\n        return new DocumentSnapshot(ref, serializer.encodeFields(obj));\n    }\n    /**\n     * Creates a DocumentSnapshot from an UpdateMap.\n     *\n     * This methods expands the top-level field paths in a JavaScript map and\n     * turns { foo.bar : foobar } into { foo { bar : foobar }}\n     *\n     * @private\n     * @param ref The reference to the document.\n     * @param data The field/value map to expand.\n     * @return The created DocumentSnapshot.\n     */\n    static fromUpdateMap(ref, data) {\n        const serializer = ref.firestore._serializer;\n        /**\n         * Merges 'value' at the field path specified by the path array into\n         * 'target'.\n         */\n        function merge(target, value, path, pos) {\n            const key = path[pos];\n            const isLast = pos === path.length - 1;\n            if (target[key] === undefined) {\n                if (isLast) {\n                    if (value instanceof field_value_1.FieldTransform) {\n                        // If there is already data at this path, we need to retain it.\n                        // Otherwise, we don't include it in the DocumentSnapshot.\n                        return !util_1.isEmpty(target) ? target : null;\n                    }\n                    // The merge is done.\n                    const leafNode = serializer.encodeValue(value);\n                    if (leafNode) {\n                        target[key] = leafNode;\n                    }\n                    return target;\n                }\n                else {\n                    // We need to expand the target object.\n                    const childNode = {\n                        mapValue: {\n                            fields: {},\n                        },\n                    };\n                    const nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);\n                    if (nestedValue) {\n                        childNode.mapValue.fields = nestedValue;\n                        target[key] = childNode;\n                        return target;\n                    }\n                    else {\n                        return !util_1.isEmpty(target) ? target : null;\n                    }\n                }\n            }\n            else {\n                assert(!isLast, \"Can't merge current value into a nested object\");\n                target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);\n                return target;\n            }\n        }\n        const res = {};\n        for (const [key, value] of data) {\n            const path = key.toArray();\n            merge(res, value, path, 0);\n        }\n        return new DocumentSnapshot(ref, res);\n    }\n    /**\n     * True if the document exists.\n     *\n     * @type {boolean}\n     * @name DocumentSnapshot#exists\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Data: ${JSON.stringify(documentSnapshot.data())}`);\n     *   }\n     * });\n     */\n    get exists() {\n        return this._fieldsProto !== undefined;\n    }\n    /**\n     * A [DocumentReference]{@link DocumentReference} for the document\n     * stored in this snapshot.\n     *\n     * @type {DocumentReference}\n     * @name DocumentSnapshot#ref\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Found document at '${documentSnapshot.ref.path}'`);\n     *   }\n     * });\n     */\n    get ref() {\n        return this._ref;\n    }\n    /**\n     * The ID of the document for which this DocumentSnapshot contains data.\n     *\n     * @type {string}\n     * @name DocumentSnapshot#id\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Document found with name '${documentSnapshot.id}'`);\n     *   }\n     * });\n     */\n    get id() {\n        return this._ref.id;\n    }\n    /**\n     * The time the document was created. Undefined for documents that don't\n     * exist.\n     *\n     * @type {Timestamp|undefined}\n     * @name DocumentSnapshot#createTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     let createTime = documentSnapshot.createTime;\n     *     console.log(`Document created at '${createTime.toDate()}'`);\n     *   }\n     * });\n     */\n    get createTime() {\n        return this._createTime;\n    }\n    /**\n     * The time the document was last updated (at the time the snapshot was\n     * generated). Undefined for documents that don't exist.\n     *\n     * @type {Timestamp|undefined}\n     * @name DocumentSnapshot#updateTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     let updateTime = documentSnapshot.updateTime;\n     *     console.log(`Document updated at '${updateTime.toDate()}'`);\n     *   }\n     * });\n     */\n    get updateTime() {\n        return this._updateTime;\n    }\n    /**\n     * The time this snapshot was read.\n     *\n     * @type {Timestamp}\n     * @name DocumentSnapshot#readTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   let readTime = documentSnapshot.readTime;\n     *   console.log(`Document read at '${readTime.toDate()}'`);\n     * });\n     */\n    get readTime() {\n        if (this._readTime === undefined) {\n            throw new Error(\"Called 'readTime' on a local document\");\n        }\n        return this._readTime;\n    }\n    /**\n     * Retrieves all fields in the document as an object. Returns 'undefined' if\n     * the document doesn't exist.\n     *\n     * @returns {T|undefined} An object containing all fields in the document or\n     * 'undefined' if the document doesn't exist.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   let data = documentSnapshot.data();\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n     * });\n     */\n    data() {\n        const fields = this._fieldsProto;\n        if (fields === undefined) {\n            return undefined;\n        }\n        // We only want to use the converter and create a new QueryDocumentSnapshot\n        // if a converter has been provided.\n        if (this.ref._converter !== types_1.defaultConverter()) {\n            const untypedReference = new reference_1.DocumentReference(this.ref.firestore, this.ref._path);\n            return this.ref._converter.fromFirestore(new QueryDocumentSnapshot(untypedReference, this._fieldsProto, this.readTime, this.createTime, this.updateTime));\n        }\n        else {\n            const obj = {};\n            for (const prop of Object.keys(fields)) {\n                obj[prop] = this._serializer.decodeValue(fields[prop]);\n            }\n            return obj;\n        }\n    }\n    /**\n     * Retrieves the field specified by `field`.\n     *\n     * @param {string|FieldPath} field The field path\n     * (e.g. 'foo' or 'foo.bar') to a specific field.\n     * @returns {*} The data at the specified field location or undefined if no\n     * such field exists.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({ a: { b: 'c' }}).then(() => {\n     *   return documentRef.get();\n     * }).then(documentSnapshot => {\n     *   let field = documentSnapshot.get('a.b');\n     *   console.log(`Retrieved field value: ${field}`);\n     * });\n     */\n    // We deliberately use `any` in the external API to not impose type-checking\n    // on end users.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(field) {\n        path_1.validateFieldPath('field', field);\n        const protoField = this.protoField(field);\n        if (protoField === undefined) {\n            return undefined;\n        }\n        return this._serializer.decodeValue(protoField);\n    }\n    /**\n     * Retrieves the field specified by 'fieldPath' in its Protobuf JS\n     * representation.\n     *\n     * @private\n     * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.\n     * @returns The Protobuf-encoded data at the specified field location or\n     * undefined if no such field exists.\n     */\n    protoField(field) {\n        let fields = this._fieldsProto;\n        if (fields === undefined) {\n            return undefined;\n        }\n        const components = path_1.FieldPath.fromArgument(field).toArray();\n        while (components.length > 1) {\n            fields = fields[components.shift()];\n            if (!fields || !fields.mapValue) {\n                return undefined;\n            }\n            fields = fields.mapValue.fields;\n        }\n        return fields[components[0]];\n    }\n    /**\n     * Convert a document snapshot to the Firestore 'Write' proto.\n     *\n     * @private\n     */\n    toWriteProto() {\n        return {\n            update: {\n                name: this._ref.formattedName,\n                fields: this._fieldsProto,\n            },\n        };\n    }\n    /**\n     * Convert a document snapshot to the Firestore 'Document' proto.\n     *\n     * @private\n     */\n    toDocumentProto() {\n        var _a, _b;\n        return {\n            name: this._ref.formattedName,\n            createTime: (_a = this.createTime) === null || _a === void 0 ? void 0 : _a.toProto().timestampValue,\n            updateTime: (_b = this.updateTime) === null || _b === void 0 ? void 0 : _b.toProto().timestampValue,\n            fields: this._fieldsProto,\n        };\n    }\n    /**\n     * Returns true if the document's data and path in this `DocumentSnapshot` is\n     * equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `DocumentSnapshot` is equal to the provided\n     * value.\n     */\n    isEqual(other) {\n        // Since the read time is different on every document read, we explicitly\n        // ignore all document metadata in this comparison.\n        return (this === other ||\n            (other instanceof DocumentSnapshot &&\n                this._ref.isEqual(other._ref) &&\n                deepEqual(this._fieldsProto, other._fieldsProto)));\n    }\n}\nexports.DocumentSnapshot = DocumentSnapshot;\n/**\n * A QueryDocumentSnapshot contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with [data()]{@link QueryDocumentSnapshot#data}\n * or [get()]{@link DocumentSnapshot#get} to get a specific field.\n *\n * A QueryDocumentSnapshot offers the same API surface as a\n * {@link DocumentSnapshot}. Since query results contain only existing\n * documents, the [exists]{@link DocumentSnapshot#exists} property will\n * always be true and [data()]{@link QueryDocumentSnapshot#data} will never\n * return 'undefined'.\n *\n * @class QueryDocumentSnapshot\n * @extends DocumentSnapshot\n */\nclass QueryDocumentSnapshot extends DocumentSnapshot {\n    /**\n     * The time the document was created.\n     *\n     * @type {Timestamp}\n     * @name QueryDocumentSnapshot#createTime\n     * @readonly\n     * @override\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(snapshot => {\n     *   console.log(`Document created at '${snapshot.createTime.toDate()}'`);\n     * });\n     */\n    get createTime() {\n        return super.createTime;\n    }\n    /**\n     * The time the document was last updated (at the time the snapshot was\n     * generated).\n     *\n     * @type {Timestamp}\n     * @name QueryDocumentSnapshot#updateTime\n     * @readonly\n     * @override\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(snapshot => {\n     *   console.log(`Document updated at '${snapshot.updateTime.toDate()}'`);\n     * });\n     */\n    get updateTime() {\n        return super.updateTime;\n    }\n    /**\n     * Retrieves all fields in the document as an object.\n     *\n     * @override\n     *\n     * @returns {T} An object containing all fields in the document.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(documentSnapshot => {\n     *   let data = documentSnapshot.data();\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n     * });\n     */\n    data() {\n        const data = super.data();\n        if (!data) {\n            throw new Error('The data in a QueryDocumentSnapshot should always exist.');\n        }\n        return data;\n    }\n}\nexports.QueryDocumentSnapshot = QueryDocumentSnapshot;\n/**\n * A Firestore Document Mask contains the field paths affected by an update.\n *\n * @class\n * @private\n */\nclass DocumentMask {\n    /**\n     * @private\n     * @hideconstructor\n     *\n     * @param fieldPaths The field paths in this mask.\n     */\n    constructor(fieldPaths) {\n        this._sortedPaths = fieldPaths;\n        this._sortedPaths.sort((a, b) => a.compareTo(b));\n    }\n    /**\n     * Creates a document mask with the field paths of a document.\n     *\n     * @private\n     * @param data A map with fields to modify. Only the keys are used to extract\n     * the document mask.\n     */\n    static fromUpdateMap(data) {\n        const fieldPaths = [];\n        data.forEach((value, key) => {\n            if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) {\n                fieldPaths.push(path_1.FieldPath.fromArgument(key));\n            }\n        });\n        return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Creates a document mask from an array of field paths.\n     *\n     * @private\n     * @param fieldMask A list of field paths.\n     */\n    static fromFieldMask(fieldMask) {\n        const fieldPaths = [];\n        for (const fieldPath of fieldMask) {\n            fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));\n        }\n        return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Creates a document mask with the field names of a document.\n     *\n     * @private\n     * @param data An object with fields to modify. Only the keys are used to\n     * extract the document mask.\n     */\n    static fromObject(data) {\n        const fieldPaths = [];\n        function extractFieldPaths(currentData, currentPath) {\n            let isEmpty = true;\n            for (const key of Object.keys(currentData)) {\n                isEmpty = false;\n                // We don't split on dots since fromObject is called with\n                // DocumentData.\n                const childSegment = new path_1.FieldPath(key);\n                const childPath = currentPath\n                    ? currentPath.append(childSegment)\n                    : childSegment;\n                const value = currentData[key];\n                if (value instanceof field_value_1.FieldTransform) {\n                    if (value.includeInDocumentMask) {\n                        fieldPaths.push(childPath);\n                    }\n                }\n                else if (util_1.isPlainObject(value)) {\n                    extractFieldPaths(value, childPath);\n                }\n                else if (value !== undefined) {\n                    // If the value is undefined it can never participate in the document\n                    // mask. With `ignoreUndefinedProperties` set to false,\n                    // `validateDocumentData` will reject an undefined value before even\n                    // computing the document mask.\n                    fieldPaths.push(childPath);\n                }\n            }\n            // Add a field path for an explicitly updated empty map.\n            if (currentPath && isEmpty) {\n                fieldPaths.push(currentPath);\n            }\n        }\n        extractFieldPaths(data);\n        return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Returns true if this document mask contains no fields.\n     *\n     * @private\n     * @return {boolean} Whether this document mask is empty.\n     */\n    get isEmpty() {\n        return this._sortedPaths.length === 0;\n    }\n    /**\n     * Removes the specified values from a sorted field path array.\n     *\n     * @private\n     * @param input A sorted array of FieldPaths.\n     * @param values An array of FieldPaths to remove.\n     */\n    static removeFromSortedArray(input, values) {\n        for (let i = 0; i < input.length;) {\n            let removed = false;\n            for (const fieldPath of values) {\n                if (input[i].isEqual(fieldPath)) {\n                    input.splice(i, 1);\n                    removed = true;\n                    break;\n                }\n            }\n            if (!removed) {\n                ++i;\n            }\n        }\n    }\n    /**\n     * Removes the field path specified in 'fieldPaths' from this document mask.\n     *\n     * @private\n     * @param fieldPaths An array of FieldPaths.\n     */\n    removeFields(fieldPaths) {\n        DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);\n    }\n    /**\n     * Returns whether this document mask contains 'fieldPath'.\n     *\n     * @private\n     * @param fieldPath The field path to test.\n     * @return Whether this document mask contains 'fieldPath'.\n     */\n    contains(fieldPath) {\n        for (const sortedPath of this._sortedPaths) {\n            const cmp = sortedPath.compareTo(fieldPath);\n            if (cmp === 0) {\n                return true;\n            }\n            else if (cmp > 0) {\n                return false;\n            }\n        }\n        return false;\n    }\n    /**\n     * Removes all properties from 'data' that are not contained in this document\n     * mask.\n     *\n     * @private\n     * @param data An object to filter.\n     * @return A shallow copy of the object filtered by this document mask.\n     */\n    applyTo(data) {\n        /*!\n         * Applies this DocumentMask to 'data' and computes the list of field paths\n         * that were specified in the mask but are not present in 'data'.\n         */\n        const applyDocumentMask = data => {\n            const remainingPaths = this._sortedPaths.slice(0);\n            const processObject = (currentData, currentPath) => {\n                let result = null;\n                Object.keys(currentData).forEach(key => {\n                    const childPath = currentPath\n                        ? currentPath.append(key)\n                        : new path_1.FieldPath(key);\n                    if (this.contains(childPath)) {\n                        DocumentMask.removeFromSortedArray(remainingPaths, [childPath]);\n                        result = result || {};\n                        result[key] = currentData[key];\n                    }\n                    else if (util_1.isObject(currentData[key])) {\n                        const childObject = processObject(currentData[key], childPath);\n                        if (childObject) {\n                            result = result || {};\n                            result[key] = childObject;\n                        }\n                    }\n                });\n                return result;\n            };\n            // processObject() returns 'null' if the DocumentMask is empty.\n            const filteredData = processObject(data) || {};\n            return {\n                filteredData,\n                remainingPaths,\n            };\n        };\n        const result = applyDocumentMask(data);\n        if (result.remainingPaths.length !== 0) {\n            throw new Error(`Input data is missing for field \"${result.remainingPaths[0]}\".`);\n        }\n        return result.filteredData;\n    }\n    /**\n     * Converts a document mask to the Firestore 'DocumentMask' Proto.\n     *\n     * @private\n     * @returns A Firestore 'DocumentMask' Proto.\n     */\n    toProto() {\n        if (this.isEmpty) {\n            return {};\n        }\n        const encodedPaths = [];\n        for (const fieldPath of this._sortedPaths) {\n            encodedPaths.push(fieldPath.formattedName);\n        }\n        return {\n            fieldPaths: encodedPaths,\n        };\n    }\n}\nexports.DocumentMask = DocumentMask;\n/**\n * A Firestore Document Transform.\n *\n * A DocumentTransform contains pending server-side transforms and their\n * corresponding field paths.\n *\n * @private\n * @class\n */\nclass DocumentTransform {\n    /**\n     * @private\n     * @hideconstructor\n     *\n     * @param ref The DocumentReference for this transform.\n     * @param transforms A Map of FieldPaths to FieldTransforms.\n     */\n    constructor(ref, transforms) {\n        this.ref = ref;\n        this.transforms = transforms;\n    }\n    /**\n     * Generates a DocumentTransform from a JavaScript object.\n     *\n     * @private\n     * @param ref The `DocumentReference` to use for the DocumentTransform.\n     * @param obj The object to extract the transformations from.\n     * @returns The Document Transform.\n     */\n    static fromObject(ref, obj) {\n        const updateMap = new Map();\n        for (const prop of Object.keys(obj)) {\n            updateMap.set(new path_1.FieldPath(prop), obj[prop]);\n        }\n        return DocumentTransform.fromUpdateMap(ref, updateMap);\n    }\n    /**\n     * Generates a DocumentTransform from an Update Map.\n     *\n     * @private\n     * @param ref The `DocumentReference` to use for the DocumentTransform.\n     * @param data The update data to extract the transformations from.\n     * @returns The Document Transform.\n     */\n    static fromUpdateMap(ref, data) {\n        const transforms = new Map();\n        function encode_(val, path, allowTransforms) {\n            if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) {\n                if (allowTransforms) {\n                    transforms.set(path, val);\n                }\n                else {\n                    throw new Error(`${val.methodName}() is not supported inside of array values.`);\n                }\n            }\n            else if (Array.isArray(val)) {\n                for (let i = 0; i < val.length; ++i) {\n                    // We need to verify that no array value contains a document transform\n                    encode_(val[i], path.append(String(i)), false);\n                }\n            }\n            else if (util_1.isPlainObject(val)) {\n                for (const prop of Object.keys(val)) {\n                    encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);\n                }\n            }\n        }\n        data.forEach((value, key) => {\n            encode_(value, path_1.FieldPath.fromArgument(key), true);\n        });\n        return new DocumentTransform(ref, transforms);\n    }\n    /**\n     * Whether this DocumentTransform contains any actionable transformations.\n     *\n     * @private\n     */\n    get isEmpty() {\n        return this.transforms.size === 0;\n    }\n    /**\n     * Returns the array of fields in this DocumentTransform.\n     *\n     * @private\n     */\n    get fields() {\n        return Array.from(this.transforms.keys());\n    }\n    /**\n     * Validates the user provided field values in this document transform.\n     * @private\n     */\n    validate() {\n        const allowUndefined = !!this.ref.firestore._settings\n            .ignoreUndefinedProperties;\n        this.transforms.forEach(transform => transform.validate(allowUndefined));\n    }\n    /**\n     * Converts a document transform to the Firestore 'FieldTransform' Proto.\n     *\n     * @private\n     * @param serializer The Firestore serializer\n     * @returns A list of Firestore 'FieldTransform' Protos\n     */\n    toProto(serializer) {\n        return Array.from(this.transforms, ([path, transform]) => transform.toProto(serializer, path));\n    }\n}\nexports.DocumentTransform = DocumentTransform;\n/**\n * A Firestore Precondition encapsulates options for database writes.\n *\n * @private\n * @class\n */\nclass Precondition {\n    /**\n     * @private\n     * @hideconstructor\n     *\n     * @param options.exists - Whether the referenced document should exist in\n     * Firestore,\n     * @param options.lastUpdateTime - The last update time of the referenced\n     * document in Firestore.\n     * @param options\n     */\n    constructor(options) {\n        if (options !== undefined) {\n            this._exists = options.exists;\n            this._lastUpdateTime = options.lastUpdateTime;\n        }\n    }\n    /**\n     * Generates the Protobuf `Preconditon` object for this precondition.\n     *\n     * @private\n     * @returns The `Preconditon` Protobuf object or 'null' if there are no\n     * preconditions.\n     */\n    toProto() {\n        if (this.isEmpty) {\n            return null;\n        }\n        const proto = {};\n        if (this._lastUpdateTime !== undefined) {\n            proto.updateTime = this._lastUpdateTime.toProto().timestampValue;\n        }\n        else {\n            proto.exists = this._exists;\n        }\n        return proto;\n    }\n    /**\n     * Whether this DocumentTransform contains any enforcement.\n     *\n     * @private\n     */\n    get isEmpty() {\n        return this._exists === undefined && !this._lastUpdateTime;\n    }\n}\nexports.Precondition = Precondition;\n//# sourceMappingURL=document.js.map"]},"metadata":{},"sourceType":"script"}