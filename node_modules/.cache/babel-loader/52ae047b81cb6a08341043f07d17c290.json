{"ast":null,"code":"var WritableStream = require('stream').Writable,\n    inherits = require('util').inherits;\n\nvar StreamSearch = require('streamsearch');\n\nvar PartStream = require('./PartStream'),\n    HeaderParser = require('./HeaderParser');\n\nvar DASH = 45,\n    B_ONEDASH = Buffer.from('-'),\n    B_CRLF = Buffer.from('\\r\\n'),\n    EMPTY_FN = function () {};\n\nfunction Dicer(cfg) {\n  if (!(this instanceof Dicer)) return new Dicer(cfg);\n  WritableStream.call(this, cfg);\n  if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== 'string') throw new TypeError('Boundary required');\n  if (typeof cfg.boundary === 'string') this.setBoundary(cfg.boundary);else this._bparser = undefined;\n  this._headerFirst = cfg.headerFirst;\n  var self = this;\n  this._dashes = 0;\n  this._parts = 0;\n  this._finished = false;\n  this._realFinish = false;\n  this._isPreamble = true;\n  this._justMatched = false;\n  this._firstWrite = true;\n  this._inHeader = true;\n  this._part = undefined;\n  this._cb = undefined;\n  this._ignoreData = false;\n  this._partOpts = typeof cfg.partHwm === 'number' ? {\n    highWaterMark: cfg.partHwm\n  } : {};\n  this._pause = false;\n  this._hparser = new HeaderParser(cfg);\n\n  this._hparser.on('header', function (header) {\n    self._inHeader = false;\n\n    self._part.emit('header', header);\n  });\n}\n\ninherits(Dicer, WritableStream);\n\nDicer.prototype.emit = function (ev) {\n  if (ev === 'finish' && !this._realFinish) {\n    if (!this._finished) {\n      var self = this;\n      process.nextTick(function () {\n        self.emit('error', new Error('Unexpected end of multipart data'));\n\n        if (self._part && !self._ignoreData) {\n          var type = self._isPreamble ? 'Preamble' : 'Part';\n\n          self._part.emit('error', new Error(type + ' terminated early due to unexpected end of multipart data'));\n\n          self._part.push(null);\n\n          process.nextTick(function () {\n            self._realFinish = true;\n            self.emit('finish');\n            self._realFinish = false;\n          });\n          return;\n        }\n\n        self._realFinish = true;\n        self.emit('finish');\n        self._realFinish = false;\n      });\n    }\n  } else WritableStream.prototype.emit.apply(this, arguments);\n};\n\nDicer.prototype._write = function (data, encoding, cb) {\n  // ignore unexpected data (e.g. extra trailer data after finished)\n  if (!this._hparser && !this._bparser) return cb();\n\n  if (this._headerFirst && this._isPreamble) {\n    if (!this._part) {\n      this._part = new PartStream(this._partOpts);\n      if (this._events.preamble) this.emit('preamble', this._part);else this._ignore();\n    }\n\n    var r = this._hparser.push(data);\n\n    if (!this._inHeader && r !== undefined && r < data.length) data = data.slice(r);else return cb();\n  } // allows for \"easier\" testing\n\n\n  if (this._firstWrite) {\n    this._bparser.push(B_CRLF);\n\n    this._firstWrite = false;\n  }\n\n  this._bparser.push(data);\n\n  if (this._pause) this._cb = cb;else cb();\n};\n\nDicer.prototype.reset = function () {\n  this._part = undefined;\n  this._bparser = undefined;\n  this._hparser = undefined;\n};\n\nDicer.prototype.setBoundary = function (boundary) {\n  var self = this;\n  this._bparser = new StreamSearch('\\r\\n--' + boundary);\n\n  this._bparser.on('info', function (isMatch, data, start, end) {\n    self._oninfo(isMatch, data, start, end);\n  });\n};\n\nDicer.prototype._ignore = function () {\n  if (this._part && !this._ignoreData) {\n    this._ignoreData = true;\n\n    this._part.on('error', EMPTY_FN); // we must perform some kind of read on the stream even though we are\n    // ignoring the data, otherwise node's Readable stream will not emit 'end'\n    // after pushing null to the stream\n\n\n    this._part.resume();\n  }\n};\n\nDicer.prototype._oninfo = function (isMatch, data, start, end) {\n  var buf,\n      self = this,\n      i = 0,\n      r,\n      ev,\n      shouldWriteMore = true;\n\n  if (!this._part && this._justMatched && data) {\n    while (this._dashes < 2 && start + i < end) {\n      if (data[start + i] === DASH) {\n        ++i;\n        ++this._dashes;\n      } else {\n        if (this._dashes) buf = B_ONEDASH;\n        this._dashes = 0;\n        break;\n      }\n    }\n\n    if (this._dashes === 2) {\n      if (start + i < end && this._events.trailer) this.emit('trailer', data.slice(start + i, end));\n      this.reset();\n      this._finished = true; // no more parts will be added\n\n      if (self._parts === 0) {\n        self._realFinish = true;\n        self.emit('finish');\n        self._realFinish = false;\n      }\n    }\n\n    if (this._dashes) return;\n  }\n\n  if (this._justMatched) this._justMatched = false;\n\n  if (!this._part) {\n    this._part = new PartStream(this._partOpts);\n\n    this._part._read = function (n) {\n      self._unpause();\n    };\n\n    ev = this._isPreamble ? 'preamble' : 'part';\n    if (this._events[ev]) this.emit(ev, this._part);else this._ignore();\n    if (!this._isPreamble) this._inHeader = true;\n  }\n\n  if (data && start < end && !this._ignoreData) {\n    if (this._isPreamble || !this._inHeader) {\n      if (buf) shouldWriteMore = this._part.push(buf);\n      shouldWriteMore = this._part.push(data.slice(start, end));\n      if (!shouldWriteMore) this._pause = true;\n    } else if (!this._isPreamble && this._inHeader) {\n      if (buf) this._hparser.push(buf);\n      r = this._hparser.push(data.slice(start, end));\n      if (!this._inHeader && r !== undefined && r < end) this._oninfo(false, data, start + r, end);\n    }\n  }\n\n  if (isMatch) {\n    this._hparser.reset();\n\n    if (this._isPreamble) this._isPreamble = false;else {\n      ++this._parts;\n\n      this._part.on('end', function () {\n        if (--self._parts === 0) {\n          if (self._finished) {\n            self._realFinish = true;\n            self.emit('finish');\n            self._realFinish = false;\n          } else {\n            self._unpause();\n          }\n        }\n      });\n    }\n\n    this._part.push(null);\n\n    this._part = undefined;\n    this._ignoreData = false;\n    this._justMatched = true;\n    this._dashes = 0;\n  }\n};\n\nDicer.prototype._unpause = function () {\n  if (!this._pause) return;\n  this._pause = false;\n\n  if (this._cb) {\n    var cb = this._cb;\n    this._cb = undefined;\n    cb();\n  }\n};\n\nmodule.exports = Dicer;","map":{"version":3,"sources":["/Users/piyushmaheshwari/Downloads/github/Bridgeorg/node_modules/dicer/lib/Dicer.js"],"names":["WritableStream","require","Writable","inherits","StreamSearch","PartStream","HeaderParser","DASH","B_ONEDASH","Buffer","from","B_CRLF","EMPTY_FN","Dicer","cfg","call","headerFirst","boundary","TypeError","setBoundary","_bparser","undefined","_headerFirst","self","_dashes","_parts","_finished","_realFinish","_isPreamble","_justMatched","_firstWrite","_inHeader","_part","_cb","_ignoreData","_partOpts","partHwm","highWaterMark","_pause","_hparser","on","header","emit","prototype","ev","process","nextTick","Error","type","push","apply","arguments","_write","data","encoding","cb","_events","preamble","_ignore","r","length","slice","reset","isMatch","start","end","_oninfo","resume","buf","i","shouldWriteMore","trailer","_read","n","_unpause","module","exports"],"mappings":"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","sourcesContent":["var WritableStream = require('stream').Writable,\n    inherits = require('util').inherits;\n\nvar StreamSearch = require('streamsearch');\n\nvar PartStream = require('./PartStream'),\n    HeaderParser = require('./HeaderParser');\n\nvar DASH = 45,\n    B_ONEDASH = Buffer.from('-'),\n    B_CRLF = Buffer.from('\\r\\n'),\n    EMPTY_FN = function() {};\n\nfunction Dicer(cfg) {\n  if (!(this instanceof Dicer))\n    return new Dicer(cfg);\n  WritableStream.call(this, cfg);\n\n  if (!cfg || (!cfg.headerFirst && typeof cfg.boundary !== 'string'))\n    throw new TypeError('Boundary required');\n\n  if (typeof cfg.boundary === 'string')\n    this.setBoundary(cfg.boundary);\n  else\n    this._bparser = undefined;\n\n  this._headerFirst = cfg.headerFirst;\n\n  var self = this;\n\n  this._dashes = 0;\n  this._parts = 0;\n  this._finished = false;\n  this._realFinish = false;\n  this._isPreamble = true;\n  this._justMatched = false;\n  this._firstWrite = true;\n  this._inHeader = true;\n  this._part = undefined;\n  this._cb = undefined;\n  this._ignoreData = false;\n  this._partOpts = (typeof cfg.partHwm === 'number'\n                    ? { highWaterMark: cfg.partHwm }\n                    : {});\n  this._pause = false;\n\n  this._hparser = new HeaderParser(cfg);\n  this._hparser.on('header', function(header) {\n    self._inHeader = false;\n    self._part.emit('header', header);\n  });\n\n}\ninherits(Dicer, WritableStream);\n\nDicer.prototype.emit = function(ev) {\n  if (ev === 'finish' && !this._realFinish) {\n    if (!this._finished) {\n      var self = this;\n      process.nextTick(function() {\n        self.emit('error', new Error('Unexpected end of multipart data'));\n        if (self._part && !self._ignoreData) {\n          var type = (self._isPreamble ? 'Preamble' : 'Part');\n          self._part.emit('error', new Error(type + ' terminated early due to unexpected end of multipart data'));\n          self._part.push(null);\n          process.nextTick(function() {\n            self._realFinish = true;\n            self.emit('finish');\n            self._realFinish = false;\n          });\n          return;\n        }\n        self._realFinish = true;\n        self.emit('finish');\n        self._realFinish = false;\n      });\n    }\n  } else\n    WritableStream.prototype.emit.apply(this, arguments);\n};\n\nDicer.prototype._write = function(data, encoding, cb) {\n  // ignore unexpected data (e.g. extra trailer data after finished)\n  if (!this._hparser && !this._bparser)\n    return cb();\n\n  if (this._headerFirst && this._isPreamble) {\n    if (!this._part) {\n      this._part = new PartStream(this._partOpts);\n      if (this._events.preamble)\n        this.emit('preamble', this._part);\n      else\n        this._ignore();\n    }\n    var r = this._hparser.push(data);\n    if (!this._inHeader && r !== undefined && r < data.length)\n      data = data.slice(r);\n    else\n      return cb();\n  }\n\n  // allows for \"easier\" testing\n  if (this._firstWrite) {\n    this._bparser.push(B_CRLF);\n    this._firstWrite = false;\n  }\n\n  this._bparser.push(data);\n\n  if (this._pause)\n    this._cb = cb;\n  else\n    cb();\n};\n\nDicer.prototype.reset = function() {\n  this._part = undefined;\n  this._bparser = undefined;\n  this._hparser = undefined;\n};\n\nDicer.prototype.setBoundary = function(boundary) {\n  var self = this;\n  this._bparser = new StreamSearch('\\r\\n--' + boundary);\n  this._bparser.on('info', function(isMatch, data, start, end) {\n    self._oninfo(isMatch, data, start, end);\n  });\n};\n\nDicer.prototype._ignore = function() {\n  if (this._part && !this._ignoreData) {\n    this._ignoreData = true;\n    this._part.on('error', EMPTY_FN);\n    // we must perform some kind of read on the stream even though we are\n    // ignoring the data, otherwise node's Readable stream will not emit 'end'\n    // after pushing null to the stream\n    this._part.resume();\n  }\n};\n\nDicer.prototype._oninfo = function(isMatch, data, start, end) {\n  var buf, self = this, i = 0, r, ev, shouldWriteMore = true;\n\n  if (!this._part && this._justMatched && data) {\n    while (this._dashes < 2 && (start + i) < end) {\n      if (data[start + i] === DASH) {\n        ++i;\n        ++this._dashes;\n      } else {\n        if (this._dashes)\n          buf = B_ONEDASH;\n        this._dashes = 0;\n        break;\n      }\n    }\n    if (this._dashes === 2) {\n      if ((start + i) < end && this._events.trailer)\n        this.emit('trailer', data.slice(start + i, end));\n      this.reset();\n      this._finished = true;\n      // no more parts will be added\n      if (self._parts === 0) {\n        self._realFinish = true;\n        self.emit('finish');\n        self._realFinish = false;\n      }\n    }\n    if (this._dashes)\n      return;\n  }\n  if (this._justMatched)\n    this._justMatched = false;\n  if (!this._part) {\n    this._part = new PartStream(this._partOpts);\n    this._part._read = function(n) {\n      self._unpause();\n    };\n    ev = this._isPreamble ? 'preamble' : 'part';\n    if (this._events[ev])\n      this.emit(ev, this._part);\n    else\n      this._ignore();\n    if (!this._isPreamble)\n      this._inHeader = true;\n  }\n  if (data && start < end && !this._ignoreData) {\n    if (this._isPreamble || !this._inHeader) {\n      if (buf)\n        shouldWriteMore = this._part.push(buf);\n      shouldWriteMore = this._part.push(data.slice(start, end));\n      if (!shouldWriteMore)\n        this._pause = true;\n    } else if (!this._isPreamble && this._inHeader) {\n      if (buf)\n        this._hparser.push(buf);\n      r = this._hparser.push(data.slice(start, end));\n      if (!this._inHeader && r !== undefined && r < end)\n        this._oninfo(false, data, start + r, end);\n    }\n  }\n  if (isMatch) {\n    this._hparser.reset();\n    if (this._isPreamble)\n      this._isPreamble = false;\n    else {\n      ++this._parts;\n      this._part.on('end', function() {\n        if (--self._parts === 0) {\n          if (self._finished) {\n            self._realFinish = true;\n            self.emit('finish');\n            self._realFinish = false;\n          } else {\n            self._unpause();\n          }\n        }\n      });\n    }\n    this._part.push(null);\n    this._part = undefined;\n    this._ignoreData = false;\n    this._justMatched = true;\n    this._dashes = 0;\n  }\n};\n\nDicer.prototype._unpause = function() {\n  if (!this._pause)\n    return;\n\n  this._pause = false;\n  if (this._cb) {\n    var cb = this._cb;\n    this._cb = undefined;\n    cb();\n  }\n};\n\nmodule.exports = Dicer;\n"]},"metadata":{},"sourceType":"script"}