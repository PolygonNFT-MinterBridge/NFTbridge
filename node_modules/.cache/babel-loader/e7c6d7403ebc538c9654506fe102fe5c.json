{"ast":null,"code":"\"use strict\";\n\nmodule.exports = codegen;\n/**\r\n * Begins generating a function.\r\n * @memberof util\r\n * @param {string[]} functionParams Function parameter names\r\n * @param {string} [functionName] Function name if not anonymous\r\n * @returns {Codegen} Appender that appends code to the function's body\r\n */\n\nfunction codegen(functionParams, functionName) {\n  /* istanbul ignore if */\n  if (typeof functionParams === \"string\") {\n    functionName = functionParams;\n    functionParams = undefined;\n  }\n\n  var body = [];\n  /**\r\n   * Appends code to the function's body or finishes generation.\r\n   * @typedef Codegen\r\n   * @type {function}\r\n   * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any\r\n   * @param {...*} [formatParams] Format parameters\r\n   * @returns {Codegen|Function} Itself or the generated function if finished\r\n   * @throws {Error} If format parameter counts do not match\r\n   */\n\n  function Codegen(formatStringOrScope) {\n    // note that explicit array handling below makes this ~50% faster\n    // finish the function\n    if (typeof formatStringOrScope !== \"string\") {\n      var source = toString();\n      if (codegen.verbose) console.log(\"codegen: \" + source); // eslint-disable-line no-console\n\n      source = \"return \" + source;\n\n      if (formatStringOrScope) {\n        var scopeKeys = Object.keys(formatStringOrScope),\n            scopeParams = new Array(scopeKeys.length + 1),\n            scopeValues = new Array(scopeKeys.length),\n            scopeOffset = 0;\n\n        while (scopeOffset < scopeKeys.length) {\n          scopeParams[scopeOffset] = scopeKeys[scopeOffset];\n          scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];\n        }\n\n        scopeParams[scopeOffset] = source;\n        return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func\n      }\n\n      return Function(source)(); // eslint-disable-line no-new-func\n    } // otherwise append to body\n\n\n    var formatParams = new Array(arguments.length - 1),\n        formatOffset = 0;\n\n    while (formatOffset < formatParams.length) formatParams[formatOffset] = arguments[++formatOffset];\n\n    formatOffset = 0;\n    formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {\n      var value = formatParams[formatOffset++];\n\n      switch ($1) {\n        case \"d\":\n        case \"f\":\n          return String(Number(value));\n\n        case \"i\":\n          return String(Math.floor(value));\n\n        case \"j\":\n          return JSON.stringify(value);\n\n        case \"s\":\n          return String(value);\n      }\n\n      return \"%\";\n    });\n    if (formatOffset !== formatParams.length) throw Error(\"parameter count mismatch\");\n    body.push(formatStringOrScope);\n    return Codegen;\n  }\n\n  function toString(functionNameOverride) {\n    return \"function \" + (functionNameOverride || functionName || \"\") + \"(\" + (functionParams && functionParams.join(\",\") || \"\") + \"){\\n  \" + body.join(\"\\n  \") + \"\\n}\";\n  }\n\n  Codegen.toString = toString;\n  return Codegen;\n}\n/**\r\n * Begins generating a function.\r\n * @memberof util\r\n * @function codegen\r\n * @param {string} [functionName] Function name if not anonymous\r\n * @returns {Codegen} Appender that appends code to the function's body\r\n * @variation 2\r\n */\n\n/**\r\n * When set to `true`, codegen will log generated code to console. Useful for debugging.\r\n * @name util.codegen.verbose\r\n * @type {boolean}\r\n */\n\n\ncodegen.verbose = false;","map":{"version":3,"sources":["/Users/piyushmaheshwari/Downloads/github/Bridgeorg/node_modules/@protobufjs/codegen/index.js"],"names":["module","exports","codegen","functionParams","functionName","undefined","body","Codegen","formatStringOrScope","source","toString","verbose","console","log","scopeKeys","Object","keys","scopeParams","Array","length","scopeValues","scopeOffset","Function","apply","formatParams","arguments","formatOffset","replace","$0","$1","value","String","Number","Math","floor","JSON","stringify","Error","push","functionNameOverride","join"],"mappings":"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","sourcesContent":["\"use strict\";\r\nmodule.exports = codegen;\r\n\r\n/**\r\n * Begins generating a function.\r\n * @memberof util\r\n * @param {string[]} functionParams Function parameter names\r\n * @param {string} [functionName] Function name if not anonymous\r\n * @returns {Codegen} Appender that appends code to the function's body\r\n */\r\nfunction codegen(functionParams, functionName) {\r\n\r\n    /* istanbul ignore if */\r\n    if (typeof functionParams === \"string\") {\r\n        functionName = functionParams;\r\n        functionParams = undefined;\r\n    }\r\n\r\n    var body = [];\r\n\r\n    /**\r\n     * Appends code to the function's body or finishes generation.\r\n     * @typedef Codegen\r\n     * @type {function}\r\n     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any\r\n     * @param {...*} [formatParams] Format parameters\r\n     * @returns {Codegen|Function} Itself or the generated function if finished\r\n     * @throws {Error} If format parameter counts do not match\r\n     */\r\n\r\n    function Codegen(formatStringOrScope) {\r\n        // note that explicit array handling below makes this ~50% faster\r\n\r\n        // finish the function\r\n        if (typeof formatStringOrScope !== \"string\") {\r\n            var source = toString();\r\n            if (codegen.verbose)\r\n                console.log(\"codegen: \" + source); // eslint-disable-line no-console\r\n            source = \"return \" + source;\r\n            if (formatStringOrScope) {\r\n                var scopeKeys   = Object.keys(formatStringOrScope),\r\n                    scopeParams = new Array(scopeKeys.length + 1),\r\n                    scopeValues = new Array(scopeKeys.length),\r\n                    scopeOffset = 0;\r\n                while (scopeOffset < scopeKeys.length) {\r\n                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];\r\n                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];\r\n                }\r\n                scopeParams[scopeOffset] = source;\r\n                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func\r\n            }\r\n            return Function(source)(); // eslint-disable-line no-new-func\r\n        }\r\n\r\n        // otherwise append to body\r\n        var formatParams = new Array(arguments.length - 1),\r\n            formatOffset = 0;\r\n        while (formatOffset < formatParams.length)\r\n            formatParams[formatOffset] = arguments[++formatOffset];\r\n        formatOffset = 0;\r\n        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {\r\n            var value = formatParams[formatOffset++];\r\n            switch ($1) {\r\n                case \"d\": case \"f\": return String(Number(value));\r\n                case \"i\": return String(Math.floor(value));\r\n                case \"j\": return JSON.stringify(value);\r\n                case \"s\": return String(value);\r\n            }\r\n            return \"%\";\r\n        });\r\n        if (formatOffset !== formatParams.length)\r\n            throw Error(\"parameter count mismatch\");\r\n        body.push(formatStringOrScope);\r\n        return Codegen;\r\n    }\r\n\r\n    function toString(functionNameOverride) {\r\n        return \"function \" + (functionNameOverride || functionName || \"\") + \"(\" + (functionParams && functionParams.join(\",\") || \"\") + \"){\\n  \" + body.join(\"\\n  \") + \"\\n}\";\r\n    }\r\n\r\n    Codegen.toString = toString;\r\n    return Codegen;\r\n}\r\n\r\n/**\r\n * Begins generating a function.\r\n * @memberof util\r\n * @function codegen\r\n * @param {string} [functionName] Function name if not anonymous\r\n * @returns {Codegen} Appender that appends code to the function's body\r\n * @variation 2\r\n */\r\n\r\n/**\r\n * When set to `true`, codegen will log generated code to console. Useful for debugging.\r\n * @name util.codegen.verbose\r\n * @type {boolean}\r\n */\r\ncodegen.verbose = false;\r\n"]},"metadata":{},"sourceType":"script"}