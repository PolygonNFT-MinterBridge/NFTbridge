{"ast":null,"code":"'use strict';\n/**\n * @param typeMap [Object] Map of MIME type -> Array[extensions]\n * @param ...\n */\n\nfunction Mime() {\n  this._types = Object.create(null);\n  this._extensions = Object.create(null);\n\n  for (let i = 0; i < arguments.length; i++) {\n    this.define(arguments[i]);\n  }\n\n  this.define = this.define.bind(this);\n  this.getType = this.getType.bind(this);\n  this.getExtension = this.getExtension.bind(this);\n}\n/**\n * Define mimetype -> extension mappings.  Each key is a mime-type that maps\n * to an array of extensions associated with the type.  The first extension is\n * used as the default extension for the type.\n *\n * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});\n *\n * If a type declares an extension that has already been defined, an error will\n * be thrown.  To suppress this error and force the extension to be associated\n * with the new type, pass `force`=true.  Alternatively, you may prefix the\n * extension with \"*\" to map the type to extension, without mapping the\n * extension to the type.\n *\n * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});\n *\n *\n * @param map (Object) type definitions\n * @param force (Boolean) if true, force overriding of existing definitions\n */\n\n\nMime.prototype.define = function (typeMap, force) {\n  for (let type in typeMap) {\n    let extensions = typeMap[type].map(function (t) {\n      return t.toLowerCase();\n    });\n    type = type.toLowerCase();\n\n    for (let i = 0; i < extensions.length; i++) {\n      const ext = extensions[i]; // '*' prefix = not the preferred type for this extension.  So fixup the\n      // extension, and skip it.\n\n      if (ext[0] === '*') {\n        continue;\n      }\n\n      if (!force && ext in this._types) {\n        throw new Error('Attempt to change mapping for \"' + ext + '\" extension from \"' + this._types[ext] + '\" to \"' + type + '\". Pass `force=true` to allow this, otherwise remove \"' + ext + '\" from the list of extensions for \"' + type + '\".');\n      }\n\n      this._types[ext] = type;\n    } // Use first extension as default\n\n\n    if (force || !this._extensions[type]) {\n      const ext = extensions[0];\n      this._extensions[type] = ext[0] !== '*' ? ext : ext.substr(1);\n    }\n  }\n};\n/**\n * Lookup a mime type based on extension\n */\n\n\nMime.prototype.getType = function (path) {\n  path = String(path);\n  let last = path.replace(/^.*[/\\\\]/, '').toLowerCase();\n  let ext = last.replace(/^.*\\./, '').toLowerCase();\n  let hasPath = last.length < path.length;\n  let hasDot = ext.length < last.length - 1;\n  return (hasDot || !hasPath) && this._types[ext] || null;\n};\n/**\n * Return file extension associated with a mime type\n */\n\n\nMime.prototype.getExtension = function (type) {\n  type = /^\\s*([^;\\s]*)/.test(type) && RegExp.$1;\n  return type && this._extensions[type.toLowerCase()] || null;\n};\n\nmodule.exports = Mime;","map":{"version":3,"sources":["/Users/pulkitmittal/nft-bridge/NFTbridge/node_modules/mime/Mime.js"],"names":["Mime","_types","Object","create","_extensions","i","arguments","length","define","bind","getType","getExtension","prototype","typeMap","force","type","extensions","map","t","toLowerCase","ext","Error","substr","path","String","last","replace","hasPath","hasDot","test","RegExp","$1","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * @param typeMap [Object] Map of MIME type -> Array[extensions]\n * @param ...\n */\nfunction Mime() {\n  this._types = Object.create(null);\n  this._extensions = Object.create(null);\n\n  for (let i = 0; i < arguments.length; i++) {\n    this.define(arguments[i]);\n  }\n\n  this.define = this.define.bind(this);\n  this.getType = this.getType.bind(this);\n  this.getExtension = this.getExtension.bind(this);\n}\n\n/**\n * Define mimetype -> extension mappings.  Each key is a mime-type that maps\n * to an array of extensions associated with the type.  The first extension is\n * used as the default extension for the type.\n *\n * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});\n *\n * If a type declares an extension that has already been defined, an error will\n * be thrown.  To suppress this error and force the extension to be associated\n * with the new type, pass `force`=true.  Alternatively, you may prefix the\n * extension with \"*\" to map the type to extension, without mapping the\n * extension to the type.\n *\n * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});\n *\n *\n * @param map (Object) type definitions\n * @param force (Boolean) if true, force overriding of existing definitions\n */\nMime.prototype.define = function(typeMap, force) {\n  for (let type in typeMap) {\n    let extensions = typeMap[type].map(function(t) {\n      return t.toLowerCase();\n    });\n    type = type.toLowerCase();\n\n    for (let i = 0; i < extensions.length; i++) {\n      const ext = extensions[i];\n\n      // '*' prefix = not the preferred type for this extension.  So fixup the\n      // extension, and skip it.\n      if (ext[0] === '*') {\n        continue;\n      }\n\n      if (!force && (ext in this._types)) {\n        throw new Error(\n          'Attempt to change mapping for \"' + ext +\n          '\" extension from \"' + this._types[ext] + '\" to \"' + type +\n          '\". Pass `force=true` to allow this, otherwise remove \"' + ext +\n          '\" from the list of extensions for \"' + type + '\".'\n        );\n      }\n\n      this._types[ext] = type;\n    }\n\n    // Use first extension as default\n    if (force || !this._extensions[type]) {\n      const ext = extensions[0];\n      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);\n    }\n  }\n};\n\n/**\n * Lookup a mime type based on extension\n */\nMime.prototype.getType = function(path) {\n  path = String(path);\n  let last = path.replace(/^.*[/\\\\]/, '').toLowerCase();\n  let ext = last.replace(/^.*\\./, '').toLowerCase();\n\n  let hasPath = last.length < path.length;\n  let hasDot = ext.length < last.length - 1;\n\n  return (hasDot || !hasPath) && this._types[ext] || null;\n};\n\n/**\n * Return file extension associated with a mime type\n */\nMime.prototype.getExtension = function(type) {\n  type = /^\\s*([^;\\s]*)/.test(type) && RegExp.$1;\n  return type && this._extensions[type.toLowerCase()] || null;\n};\n\nmodule.exports = Mime;\n"]},"metadata":{},"sourceType":"script"}