{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address = void 0;\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar externals_1 = require(\"./externals\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar account_1 = require(\"./account\");\n\nvar Address =\n/** @class */\nfunction () {\n  function Address(buf) {\n    (0, assert_1.default)(buf.length === 20, 'Invalid address length');\n    this.buf = buf;\n  }\n  /**\n   * Returns the zero address.\n   */\n\n\n  Address.zero = function () {\n    return new Address((0, bytes_1.zeros)(20));\n  };\n  /**\n   * Returns an Address object from a hex-encoded string.\n   * @param str - Hex-encoded address\n   */\n\n\n  Address.fromString = function (str) {\n    (0, assert_1.default)((0, account_1.isValidAddress)(str), 'Invalid address');\n    return new Address((0, bytes_1.toBuffer)(str));\n  };\n  /**\n   * Returns an address for a given public key.\n   * @param pubKey The two points of an uncompressed key\n   */\n\n\n  Address.fromPublicKey = function (pubKey) {\n    (0, assert_1.default)(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\n    var buf = (0, account_1.pubToAddress)(pubKey);\n    return new Address(buf);\n  };\n  /**\n   * Returns an address for a given private key.\n   * @param privateKey A private key must be 256 bits wide\n   */\n\n\n  Address.fromPrivateKey = function (privateKey) {\n    (0, assert_1.default)(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\n    var buf = (0, account_1.privateToAddress)(privateKey);\n    return new Address(buf);\n  };\n  /**\n   * Generates an address for a newly created contract.\n   * @param from The address which is creating this new address\n   * @param nonce The nonce of the from account\n   */\n\n\n  Address.generate = function (from, nonce) {\n    (0, assert_1.default)(externals_1.BN.isBN(nonce));\n    return new Address((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));\n  };\n  /**\n   * Generates an address for a contract created using CREATE2.\n   * @param from The address which is creating this new address\n   * @param salt A salt\n   * @param initCode The init code of the contract being created\n   */\n\n\n  Address.generate2 = function (from, salt, initCode) {\n    (0, assert_1.default)(Buffer.isBuffer(salt));\n    (0, assert_1.default)(Buffer.isBuffer(initCode));\n    return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n  };\n  /**\n   * Is address equal to another.\n   */\n\n\n  Address.prototype.equals = function (address) {\n    return this.buf.equals(address.buf);\n  };\n  /**\n   * Is address zero.\n   */\n\n\n  Address.prototype.isZero = function () {\n    return this.equals(Address.zero());\n  };\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n\n\n  Address.prototype.isPrecompileOrSystemAddress = function () {\n    var addressBN = new externals_1.BN(this.buf);\n    var rangeMin = new externals_1.BN(0);\n    var rangeMax = new externals_1.BN('ffff', 'hex');\n    return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\n  };\n  /**\n   * Returns hex encoding of address.\n   */\n\n\n  Address.prototype.toString = function () {\n    return '0x' + this.buf.toString('hex');\n  };\n  /**\n   * Returns Buffer representation of address.\n   */\n\n\n  Address.prototype.toBuffer = function () {\n    return Buffer.from(this.buf);\n  };\n\n  return Address;\n}();\n\nexports.Address = Address;","map":{"version":3,"sources":["../src/address.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Address = void 0;\nvar assert_1 = __importDefault(require(\"assert\"));\nvar externals_1 = require(\"./externals\");\nvar bytes_1 = require(\"./bytes\");\nvar account_1 = require(\"./account\");\nvar Address = /** @class */ (function () {\n    function Address(buf) {\n        (0, assert_1.default)(buf.length === 20, 'Invalid address length');\n        this.buf = buf;\n    }\n    /**\n     * Returns the zero address.\n     */\n    Address.zero = function () {\n        return new Address((0, bytes_1.zeros)(20));\n    };\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */\n    Address.fromString = function (str) {\n        (0, assert_1.default)((0, account_1.isValidAddress)(str), 'Invalid address');\n        return new Address((0, bytes_1.toBuffer)(str));\n    };\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */\n    Address.fromPublicKey = function (pubKey) {\n        (0, assert_1.default)(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\n        var buf = (0, account_1.pubToAddress)(pubKey);\n        return new Address(buf);\n    };\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */\n    Address.fromPrivateKey = function (privateKey) {\n        (0, assert_1.default)(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\n        var buf = (0, account_1.privateToAddress)(privateKey);\n        return new Address(buf);\n    };\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */\n    Address.generate = function (from, nonce) {\n        (0, assert_1.default)(externals_1.BN.isBN(nonce));\n        return new Address((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));\n    };\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */\n    Address.generate2 = function (from, salt, initCode) {\n        (0, assert_1.default)(Buffer.isBuffer(salt));\n        (0, assert_1.default)(Buffer.isBuffer(initCode));\n        return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n    };\n    /**\n     * Is address equal to another.\n     */\n    Address.prototype.equals = function (address) {\n        return this.buf.equals(address.buf);\n    };\n    /**\n     * Is address zero.\n     */\n    Address.prototype.isZero = function () {\n        return this.equals(Address.zero());\n    };\n    /**\n     * True if address is in the address range defined\n     * by EIP-1352\n     */\n    Address.prototype.isPrecompileOrSystemAddress = function () {\n        var addressBN = new externals_1.BN(this.buf);\n        var rangeMin = new externals_1.BN(0);\n        var rangeMax = new externals_1.BN('ffff', 'hex');\n        return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\n    };\n    /**\n     * Returns hex encoding of address.\n     */\n    Address.prototype.toString = function () {\n        return '0x' + this.buf.toString('hex');\n    };\n    /**\n     * Returns Buffer representation of address.\n     */\n    Address.prototype.toBuffer = function () {\n        return Buffer.from(this.buf);\n    };\n    return Address;\n}());\nexports.Address = Address;\n//# sourceMappingURL=address.js.map"]},"metadata":{},"sourceType":"script"}