{"ast":null,"code":"/*! firebase-admin v9.6.0 */\n\"use strict\";\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UserImportBuilder = exports.convertMultiFactorInfoToServerFormat = void 0;\n\nvar deep_copy_1 = require(\"../utils/deep-copy\");\n\nvar utils = require(\"../utils\");\n\nvar validator = require(\"../utils/validator\");\n\nvar error_1 = require(\"../utils/error\");\n/**\n * Converts a client format second factor object to server format.\n * @param multiFactorInfo The client format second factor.\n * @return The corresponding AuthFactorInfo server request format.\n */\n\n\nfunction convertMultiFactorInfoToServerFormat(multiFactorInfo) {\n  var enrolledAt;\n\n  if (typeof multiFactorInfo.enrollmentTime !== 'undefined') {\n    if (validator.isUTCDateString(multiFactorInfo.enrollmentTime)) {\n      // Convert from UTC date string (client side format) to ISO date string (server side format).\n      enrolledAt = new Date(multiFactorInfo.enrollmentTime).toISOString();\n    } else {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, \"The second factor \\\"enrollmentTime\\\" for \\\"\" + multiFactorInfo.uid + \"\\\" must be a valid \" + 'UTC date string.');\n    }\n  } // Currently only phone second factors are supported.\n\n\n  if (isPhoneFactor(multiFactorInfo)) {\n    // If any required field is missing or invalid, validation will still fail later.\n    var authFactorInfo = {\n      mfaEnrollmentId: multiFactorInfo.uid,\n      displayName: multiFactorInfo.displayName,\n      // Required for all phone second factors.\n      phoneInfo: multiFactorInfo.phoneNumber,\n      enrolledAt: enrolledAt\n    };\n\n    for (var objKey in authFactorInfo) {\n      if (typeof authFactorInfo[objKey] === 'undefined') {\n        delete authFactorInfo[objKey];\n      }\n    }\n\n    return authFactorInfo;\n  } else {\n    // Unsupported second factor.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.UNSUPPORTED_SECOND_FACTOR, \"Unsupported second factor \\\"\" + JSON.stringify(multiFactorInfo) + \"\\\" provided.\");\n  }\n}\n\nexports.convertMultiFactorInfoToServerFormat = convertMultiFactorInfoToServerFormat;\n\nfunction isPhoneFactor(multiFactorInfo) {\n  return multiFactorInfo.factorId === 'phone';\n}\n/**\n * @param {any} obj The object to check for number field within.\n * @param {string} key The entry key.\n * @return {number} The corresponding number if available. Otherwise, NaN.\n */\n\n\nfunction getNumberField(obj, key) {\n  if (typeof obj[key] !== 'undefined' && obj[key] !== null) {\n    return parseInt(obj[key].toString(), 10);\n  }\n\n  return NaN;\n}\n/**\n * Converts a UserImportRecord to a UploadAccountUser object. Throws an error when invalid\n * fields are provided.\n * @param {UserImportRecord} user The UserImportRecord to conver to UploadAccountUser.\n * @param {ValidatorFunction=} userValidator The user validator function.\n * @return {UploadAccountUser} The corresponding UploadAccountUser to return.\n */\n\n\nfunction populateUploadAccountUser(user, userValidator) {\n  var result = {\n    localId: user.uid,\n    email: user.email,\n    emailVerified: user.emailVerified,\n    displayName: user.displayName,\n    disabled: user.disabled,\n    photoUrl: user.photoURL,\n    phoneNumber: user.phoneNumber,\n    providerUserInfo: [],\n    mfaInfo: [],\n    tenantId: user.tenantId,\n    customAttributes: user.customClaims && JSON.stringify(user.customClaims)\n  };\n\n  if (typeof user.passwordHash !== 'undefined') {\n    if (!validator.isBuffer(user.passwordHash)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\n    }\n\n    result.passwordHash = utils.toWebSafeBase64(user.passwordHash);\n  }\n\n  if (typeof user.passwordSalt !== 'undefined') {\n    if (!validator.isBuffer(user.passwordSalt)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\n    }\n\n    result.salt = utils.toWebSafeBase64(user.passwordSalt);\n  }\n\n  if (validator.isNonNullObject(user.metadata)) {\n    if (validator.isNonEmptyString(user.metadata.creationTime)) {\n      result.createdAt = new Date(user.metadata.creationTime).getTime();\n    }\n\n    if (validator.isNonEmptyString(user.metadata.lastSignInTime)) {\n      result.lastLoginAt = new Date(user.metadata.lastSignInTime).getTime();\n    }\n  }\n\n  if (validator.isArray(user.providerData)) {\n    user.providerData.forEach(function (providerData) {\n      result.providerUserInfo.push({\n        providerId: providerData.providerId,\n        rawId: providerData.uid,\n        email: providerData.email,\n        displayName: providerData.displayName,\n        photoUrl: providerData.photoURL\n      });\n    });\n  } // Convert user.multiFactor.enrolledFactors to server format.\n\n\n  if (validator.isNonNullObject(user.multiFactor) && validator.isNonEmptyArray(user.multiFactor.enrolledFactors)) {\n    user.multiFactor.enrolledFactors.forEach(function (multiFactorInfo) {\n      result.mfaInfo.push(convertMultiFactorInfoToServerFormat(multiFactorInfo));\n    });\n  } // Remove blank fields.\n\n\n  var key;\n\n  for (key in result) {\n    if (typeof result[key] === 'undefined') {\n      delete result[key];\n    }\n  }\n\n  if (result.providerUserInfo.length === 0) {\n    delete result.providerUserInfo;\n  }\n\n  if (result.mfaInfo.length === 0) {\n    delete result.mfaInfo;\n  } // Validate the constructured user individual request. This will throw if an error\n  // is detected.\n\n\n  if (typeof userValidator === 'function') {\n    userValidator(result);\n  }\n\n  return result;\n}\n/**\n * Class that provides a helper for building/validating uploadAccount requests and\n * UserImportResult responses.\n */\n\n\nvar UserImportBuilder =\n/** @class */\nfunction () {\n  /**\n   * @param {UserImportRecord[]} users The list of user records to import.\n   * @param {UserImportOptions=} options The import options which includes hashing\n   *     algorithm details.\n   * @param {ValidatorFunction=} userRequestValidator The user request validator function.\n   * @constructor\n   */\n  function UserImportBuilder(users, options, userRequestValidator) {\n    this.requiresHashOptions = false;\n    this.validatedUsers = [];\n    this.userImportResultErrors = [];\n    this.indexMap = {};\n    this.validatedUsers = this.populateUsers(users, userRequestValidator);\n    this.validatedOptions = this.populateOptions(options, this.requiresHashOptions);\n  }\n  /**\n   * Returns the corresponding constructed uploadAccount request.\n   * @return {UploadAccountRequest} The constructed uploadAccount request.\n   */\n\n\n  UserImportBuilder.prototype.buildRequest = function () {\n    var users = this.validatedUsers.map(function (user) {\n      return deep_copy_1.deepCopy(user);\n    });\n    return deep_copy_1.deepExtend({\n      users: users\n    }, deep_copy_1.deepCopy(this.validatedOptions));\n  };\n  /**\n   * Populates the UserImportResult using the client side detected errors and the server\n   * side returned errors.\n   * @return {UserImportResult} The user import result based on the returned failed\n   *     uploadAccount response.\n   */\n\n\n  UserImportBuilder.prototype.buildResponse = function (failedUploads) {\n    var _this = this; // Initialize user import result.\n\n\n    var importResult = {\n      successCount: this.validatedUsers.length,\n      failureCount: this.userImportResultErrors.length,\n      errors: deep_copy_1.deepCopy(this.userImportResultErrors)\n    };\n    importResult.failureCount += failedUploads.length;\n    importResult.successCount -= failedUploads.length;\n    failedUploads.forEach(function (failedUpload) {\n      importResult.errors.push({\n        // Map backend request index to original developer provided array index.\n        index: _this.indexMap[failedUpload.index],\n        error: new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_USER_IMPORT, failedUpload.message)\n      });\n    }); // Sort errors by index.\n\n    importResult.errors.sort(function (a, b) {\n      return a.index - b.index;\n    }); // Return sorted result.\n\n    return importResult;\n  };\n  /**\n   * Validates and returns the hashing options of the uploadAccount request.\n   * Throws an error whenever an invalid or missing options is detected.\n   * @param {UserImportOptions} options The UserImportOptions.\n   * @param {boolean} requiresHashOptions Whether to require hash options.\n   * @return {UploadAccountOptions} The populated UploadAccount options.\n   */\n\n\n  UserImportBuilder.prototype.populateOptions = function (options, requiresHashOptions) {\n    var populatedOptions;\n\n    if (!requiresHashOptions) {\n      return {};\n    }\n\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"UserImportOptions\" are required when importing users with passwords.');\n    }\n\n    if (!validator.isNonNullObject(options.hash)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_HASH_ALGORITHM, '\"hash.algorithm\" is missing from the provided \"UserImportOptions\".');\n    }\n\n    if (typeof options.hash.algorithm === 'undefined' || !validator.isNonEmptyString(options.hash.algorithm)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, '\"hash.algorithm\" must be a string matching the list of supported algorithms.');\n    }\n\n    var rounds;\n\n    switch (options.hash.algorithm) {\n      case 'HMAC_SHA512':\n      case 'HMAC_SHA256':\n      case 'HMAC_SHA1':\n      case 'HMAC_MD5':\n        if (!validator.isBuffer(options.hash.key)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, 'A non-empty \"hash.key\" byte buffer must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm,\n          signerKey: utils.toWebSafeBase64(options.hash.key)\n        };\n        break;\n\n      case 'MD5':\n      case 'SHA1':\n      case 'SHA256':\n      case 'SHA512':\n        {\n          // MD5 is [0,8192] but SHA1, SHA256, and SHA512 are [1,8192]\n          rounds = getNumberField(options.hash, 'rounds');\n          var minRounds = options.hash.algorithm === 'MD5' ? 0 : 1;\n\n          if (isNaN(rounds) || rounds < minRounds || rounds > 8192) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, \"A valid \\\"hash.rounds\\\" number between \" + minRounds + \" and 8192 must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n          }\n\n          populatedOptions = {\n            hashAlgorithm: options.hash.algorithm,\n            rounds: rounds\n          };\n          break;\n        }\n\n      case 'PBKDF_SHA1':\n      case 'PBKDF2_SHA256':\n        rounds = getNumberField(options.hash, 'rounds');\n\n        if (isNaN(rounds) || rounds < 0 || rounds > 120000) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, 'A valid \"hash.rounds\" number between 0 and 120000 must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm,\n          rounds: rounds\n        };\n        break;\n\n      case 'SCRYPT':\n        {\n          if (!validator.isBuffer(options.hash.key)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, 'A \"hash.key\" byte buffer must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n          }\n\n          rounds = getNumberField(options.hash, 'rounds');\n\n          if (isNaN(rounds) || rounds <= 0 || rounds > 8) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, 'A valid \"hash.rounds\" number between 1 and 8 must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n          }\n\n          var memoryCost = getNumberField(options.hash, 'memoryCost');\n\n          if (isNaN(memoryCost) || memoryCost <= 0 || memoryCost > 14) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, 'A valid \"hash.memoryCost\" number between 1 and 14 must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n          }\n\n          if (typeof options.hash.saltSeparator !== 'undefined' && !validator.isBuffer(options.hash.saltSeparator)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR, '\"hash.saltSeparator\" must be a byte buffer.');\n          }\n\n          populatedOptions = {\n            hashAlgorithm: options.hash.algorithm,\n            signerKey: utils.toWebSafeBase64(options.hash.key),\n            rounds: rounds,\n            memoryCost: memoryCost,\n            saltSeparator: utils.toWebSafeBase64(options.hash.saltSeparator || Buffer.from(''))\n          };\n          break;\n        }\n\n      case 'BCRYPT':\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm\n        };\n        break;\n\n      case 'STANDARD_SCRYPT':\n        {\n          var cpuMemCost = getNumberField(options.hash, 'memoryCost');\n\n          if (isNaN(cpuMemCost)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, 'A valid \"hash.memoryCost\" number must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n          }\n\n          var parallelization = getNumberField(options.hash, 'parallelization');\n\n          if (isNaN(parallelization)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_PARALLELIZATION, 'A valid \"hash.parallelization\" number must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n          }\n\n          var blockSize = getNumberField(options.hash, 'blockSize');\n\n          if (isNaN(blockSize)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE, 'A valid \"hash.blockSize\" number must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n          }\n\n          var dkLen = getNumberField(options.hash, 'derivedKeyLength');\n\n          if (isNaN(dkLen)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH, 'A valid \"hash.derivedKeyLength\" number must be provided for ' + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n          }\n\n          populatedOptions = {\n            hashAlgorithm: options.hash.algorithm,\n            cpuMemCost: cpuMemCost,\n            parallelization: parallelization,\n            blockSize: blockSize,\n            dkLen: dkLen\n          };\n          break;\n        }\n\n      default:\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, \"Unsupported hash algorithm provider \\\"\" + options.hash.algorithm + \"\\\".\");\n    }\n\n    return populatedOptions;\n  };\n  /**\n   * Validates and returns the users list of the uploadAccount request.\n   * Whenever a user with an error is detected, the error is cached and will later be\n   * merged into the user import result. This allows the processing of valid users without\n   * failing early on the first error detected.\n   * @param {UserImportRecord[]} users The UserImportRecords to convert to UnploadAccountUser\n   *     objects.\n   * @param {ValidatorFunction=} userValidator The user validator function.\n   * @return {UploadAccountUser[]} The populated uploadAccount users.\n   */\n\n\n  UserImportBuilder.prototype.populateUsers = function (users, userValidator) {\n    var _this = this;\n\n    var populatedUsers = [];\n    users.forEach(function (user, index) {\n      try {\n        var result = populateUploadAccountUser(user, userValidator);\n\n        if (typeof result.passwordHash !== 'undefined') {\n          _this.requiresHashOptions = true;\n        } // Only users that pass client screening will be passed to backend for processing.\n\n\n        populatedUsers.push(result); // Map user's index (the one to be sent to backend) to original developer provided array.\n\n        _this.indexMap[populatedUsers.length - 1] = index;\n      } catch (error) {\n        // Save the client side error with respect to the developer provided array.\n        _this.userImportResultErrors.push({\n          index: index,\n          error: error\n        });\n      }\n    });\n    return populatedUsers;\n  };\n\n  return UserImportBuilder;\n}();\n\nexports.UserImportBuilder = UserImportBuilder;","map":{"version":3,"sources":["/Users/pulkitmittal/nft-bridge/NFTbridge/node_modules/firebase-admin/lib/auth/user-import-builder.js"],"names":["Object","defineProperty","exports","value","UserImportBuilder","convertMultiFactorInfoToServerFormat","deep_copy_1","require","utils","validator","error_1","multiFactorInfo","enrolledAt","enrollmentTime","isUTCDateString","Date","toISOString","FirebaseAuthError","AuthClientErrorCode","INVALID_ENROLLMENT_TIME","uid","isPhoneFactor","authFactorInfo","mfaEnrollmentId","displayName","phoneInfo","phoneNumber","objKey","UNSUPPORTED_SECOND_FACTOR","JSON","stringify","factorId","getNumberField","obj","key","parseInt","toString","NaN","populateUploadAccountUser","user","userValidator","result","localId","email","emailVerified","disabled","photoUrl","photoURL","providerUserInfo","mfaInfo","tenantId","customAttributes","customClaims","passwordHash","isBuffer","INVALID_PASSWORD_HASH","toWebSafeBase64","passwordSalt","INVALID_PASSWORD_SALT","salt","isNonNullObject","metadata","isNonEmptyString","creationTime","createdAt","getTime","lastSignInTime","lastLoginAt","isArray","providerData","forEach","push","providerId","rawId","multiFactor","isNonEmptyArray","enrolledFactors","length","users","options","userRequestValidator","requiresHashOptions","validatedUsers","userImportResultErrors","indexMap","populateUsers","validatedOptions","populateOptions","prototype","buildRequest","map","deepCopy","deepExtend","buildResponse","failedUploads","_this","importResult","successCount","failureCount","errors","failedUpload","index","error","INVALID_USER_IMPORT","message","sort","a","b","populatedOptions","INVALID_ARGUMENT","hash","MISSING_HASH_ALGORITHM","algorithm","INVALID_HASH_ALGORITHM","rounds","INVALID_HASH_KEY","hashAlgorithm","signerKey","minRounds","isNaN","INVALID_HASH_ROUNDS","memoryCost","INVALID_HASH_MEMORY_COST","saltSeparator","INVALID_HASH_SALT_SEPARATOR","Buffer","from","cpuMemCost","parallelization","INVALID_HASH_PARALLELIZATION","blockSize","INVALID_HASH_BLOCK_SIZE","dkLen","INVALID_HASH_DERIVED_KEY_LENGTH","populatedUsers"],"mappings":"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","sourcesContent":["/*! firebase-admin v9.6.0 */\n\"use strict\";\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UserImportBuilder = exports.convertMultiFactorInfoToServerFormat = void 0;\nvar deep_copy_1 = require(\"../utils/deep-copy\");\nvar utils = require(\"../utils\");\nvar validator = require(\"../utils/validator\");\nvar error_1 = require(\"../utils/error\");\n/**\n * Converts a client format second factor object to server format.\n * @param multiFactorInfo The client format second factor.\n * @return The corresponding AuthFactorInfo server request format.\n */\nfunction convertMultiFactorInfoToServerFormat(multiFactorInfo) {\n    var enrolledAt;\n    if (typeof multiFactorInfo.enrollmentTime !== 'undefined') {\n        if (validator.isUTCDateString(multiFactorInfo.enrollmentTime)) {\n            // Convert from UTC date string (client side format) to ISO date string (server side format).\n            enrolledAt = new Date(multiFactorInfo.enrollmentTime).toISOString();\n        }\n        else {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, \"The second factor \\\"enrollmentTime\\\" for \\\"\" + multiFactorInfo.uid + \"\\\" must be a valid \" +\n                'UTC date string.');\n        }\n    }\n    // Currently only phone second factors are supported.\n    if (isPhoneFactor(multiFactorInfo)) {\n        // If any required field is missing or invalid, validation will still fail later.\n        var authFactorInfo = {\n            mfaEnrollmentId: multiFactorInfo.uid,\n            displayName: multiFactorInfo.displayName,\n            // Required for all phone second factors.\n            phoneInfo: multiFactorInfo.phoneNumber,\n            enrolledAt: enrolledAt,\n        };\n        for (var objKey in authFactorInfo) {\n            if (typeof authFactorInfo[objKey] === 'undefined') {\n                delete authFactorInfo[objKey];\n            }\n        }\n        return authFactorInfo;\n    }\n    else {\n        // Unsupported second factor.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.UNSUPPORTED_SECOND_FACTOR, \"Unsupported second factor \\\"\" + JSON.stringify(multiFactorInfo) + \"\\\" provided.\");\n    }\n}\nexports.convertMultiFactorInfoToServerFormat = convertMultiFactorInfoToServerFormat;\nfunction isPhoneFactor(multiFactorInfo) {\n    return multiFactorInfo.factorId === 'phone';\n}\n/**\n * @param {any} obj The object to check for number field within.\n * @param {string} key The entry key.\n * @return {number} The corresponding number if available. Otherwise, NaN.\n */\nfunction getNumberField(obj, key) {\n    if (typeof obj[key] !== 'undefined' && obj[key] !== null) {\n        return parseInt(obj[key].toString(), 10);\n    }\n    return NaN;\n}\n/**\n * Converts a UserImportRecord to a UploadAccountUser object. Throws an error when invalid\n * fields are provided.\n * @param {UserImportRecord} user The UserImportRecord to conver to UploadAccountUser.\n * @param {ValidatorFunction=} userValidator The user validator function.\n * @return {UploadAccountUser} The corresponding UploadAccountUser to return.\n */\nfunction populateUploadAccountUser(user, userValidator) {\n    var result = {\n        localId: user.uid,\n        email: user.email,\n        emailVerified: user.emailVerified,\n        displayName: user.displayName,\n        disabled: user.disabled,\n        photoUrl: user.photoURL,\n        phoneNumber: user.phoneNumber,\n        providerUserInfo: [],\n        mfaInfo: [],\n        tenantId: user.tenantId,\n        customAttributes: user.customClaims && JSON.stringify(user.customClaims),\n    };\n    if (typeof user.passwordHash !== 'undefined') {\n        if (!validator.isBuffer(user.passwordHash)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\n        }\n        result.passwordHash = utils.toWebSafeBase64(user.passwordHash);\n    }\n    if (typeof user.passwordSalt !== 'undefined') {\n        if (!validator.isBuffer(user.passwordSalt)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\n        }\n        result.salt = utils.toWebSafeBase64(user.passwordSalt);\n    }\n    if (validator.isNonNullObject(user.metadata)) {\n        if (validator.isNonEmptyString(user.metadata.creationTime)) {\n            result.createdAt = new Date(user.metadata.creationTime).getTime();\n        }\n        if (validator.isNonEmptyString(user.metadata.lastSignInTime)) {\n            result.lastLoginAt = new Date(user.metadata.lastSignInTime).getTime();\n        }\n    }\n    if (validator.isArray(user.providerData)) {\n        user.providerData.forEach(function (providerData) {\n            result.providerUserInfo.push({\n                providerId: providerData.providerId,\n                rawId: providerData.uid,\n                email: providerData.email,\n                displayName: providerData.displayName,\n                photoUrl: providerData.photoURL,\n            });\n        });\n    }\n    // Convert user.multiFactor.enrolledFactors to server format.\n    if (validator.isNonNullObject(user.multiFactor) &&\n        validator.isNonEmptyArray(user.multiFactor.enrolledFactors)) {\n        user.multiFactor.enrolledFactors.forEach(function (multiFactorInfo) {\n            result.mfaInfo.push(convertMultiFactorInfoToServerFormat(multiFactorInfo));\n        });\n    }\n    // Remove blank fields.\n    var key;\n    for (key in result) {\n        if (typeof result[key] === 'undefined') {\n            delete result[key];\n        }\n    }\n    if (result.providerUserInfo.length === 0) {\n        delete result.providerUserInfo;\n    }\n    if (result.mfaInfo.length === 0) {\n        delete result.mfaInfo;\n    }\n    // Validate the constructured user individual request. This will throw if an error\n    // is detected.\n    if (typeof userValidator === 'function') {\n        userValidator(result);\n    }\n    return result;\n}\n/**\n * Class that provides a helper for building/validating uploadAccount requests and\n * UserImportResult responses.\n */\nvar UserImportBuilder = /** @class */ (function () {\n    /**\n     * @param {UserImportRecord[]} users The list of user records to import.\n     * @param {UserImportOptions=} options The import options which includes hashing\n     *     algorithm details.\n     * @param {ValidatorFunction=} userRequestValidator The user request validator function.\n     * @constructor\n     */\n    function UserImportBuilder(users, options, userRequestValidator) {\n        this.requiresHashOptions = false;\n        this.validatedUsers = [];\n        this.userImportResultErrors = [];\n        this.indexMap = {};\n        this.validatedUsers = this.populateUsers(users, userRequestValidator);\n        this.validatedOptions = this.populateOptions(options, this.requiresHashOptions);\n    }\n    /**\n     * Returns the corresponding constructed uploadAccount request.\n     * @return {UploadAccountRequest} The constructed uploadAccount request.\n     */\n    UserImportBuilder.prototype.buildRequest = function () {\n        var users = this.validatedUsers.map(function (user) {\n            return deep_copy_1.deepCopy(user);\n        });\n        return deep_copy_1.deepExtend({ users: users }, deep_copy_1.deepCopy(this.validatedOptions));\n    };\n    /**\n     * Populates the UserImportResult using the client side detected errors and the server\n     * side returned errors.\n     * @return {UserImportResult} The user import result based on the returned failed\n     *     uploadAccount response.\n     */\n    UserImportBuilder.prototype.buildResponse = function (failedUploads) {\n        var _this = this;\n        // Initialize user import result.\n        var importResult = {\n            successCount: this.validatedUsers.length,\n            failureCount: this.userImportResultErrors.length,\n            errors: deep_copy_1.deepCopy(this.userImportResultErrors),\n        };\n        importResult.failureCount += failedUploads.length;\n        importResult.successCount -= failedUploads.length;\n        failedUploads.forEach(function (failedUpload) {\n            importResult.errors.push({\n                // Map backend request index to original developer provided array index.\n                index: _this.indexMap[failedUpload.index],\n                error: new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_USER_IMPORT, failedUpload.message),\n            });\n        });\n        // Sort errors by index.\n        importResult.errors.sort(function (a, b) {\n            return a.index - b.index;\n        });\n        // Return sorted result.\n        return importResult;\n    };\n    /**\n     * Validates and returns the hashing options of the uploadAccount request.\n     * Throws an error whenever an invalid or missing options is detected.\n     * @param {UserImportOptions} options The UserImportOptions.\n     * @param {boolean} requiresHashOptions Whether to require hash options.\n     * @return {UploadAccountOptions} The populated UploadAccount options.\n     */\n    UserImportBuilder.prototype.populateOptions = function (options, requiresHashOptions) {\n        var populatedOptions;\n        if (!requiresHashOptions) {\n            return {};\n        }\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"UserImportOptions\" are required when importing users with passwords.');\n        }\n        if (!validator.isNonNullObject(options.hash)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_HASH_ALGORITHM, '\"hash.algorithm\" is missing from the provided \"UserImportOptions\".');\n        }\n        if (typeof options.hash.algorithm === 'undefined' ||\n            !validator.isNonEmptyString(options.hash.algorithm)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, '\"hash.algorithm\" must be a string matching the list of supported algorithms.');\n        }\n        var rounds;\n        switch (options.hash.algorithm) {\n            case 'HMAC_SHA512':\n            case 'HMAC_SHA256':\n            case 'HMAC_SHA1':\n            case 'HMAC_MD5':\n                if (!validator.isBuffer(options.hash.key)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, 'A non-empty \"hash.key\" byte buffer must be provided for ' +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    signerKey: utils.toWebSafeBase64(options.hash.key),\n                };\n                break;\n            case 'MD5':\n            case 'SHA1':\n            case 'SHA256':\n            case 'SHA512': {\n                // MD5 is [0,8192] but SHA1, SHA256, and SHA512 are [1,8192]\n                rounds = getNumberField(options.hash, 'rounds');\n                var minRounds = options.hash.algorithm === 'MD5' ? 0 : 1;\n                if (isNaN(rounds) || rounds < minRounds || rounds > 8192) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, \"A valid \\\"hash.rounds\\\" number between \" + minRounds + \" and 8192 must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    rounds: rounds,\n                };\n                break;\n            }\n            case 'PBKDF_SHA1':\n            case 'PBKDF2_SHA256':\n                rounds = getNumberField(options.hash, 'rounds');\n                if (isNaN(rounds) || rounds < 0 || rounds > 120000) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, 'A valid \"hash.rounds\" number between 0 and 120000 must be provided for ' +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    rounds: rounds,\n                };\n                break;\n            case 'SCRYPT': {\n                if (!validator.isBuffer(options.hash.key)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, 'A \"hash.key\" byte buffer must be provided for ' +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                rounds = getNumberField(options.hash, 'rounds');\n                if (isNaN(rounds) || rounds <= 0 || rounds > 8) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, 'A valid \"hash.rounds\" number between 1 and 8 must be provided for ' +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                var memoryCost = getNumberField(options.hash, 'memoryCost');\n                if (isNaN(memoryCost) || memoryCost <= 0 || memoryCost > 14) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, 'A valid \"hash.memoryCost\" number between 1 and 14 must be provided for ' +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                if (typeof options.hash.saltSeparator !== 'undefined' &&\n                    !validator.isBuffer(options.hash.saltSeparator)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR, '\"hash.saltSeparator\" must be a byte buffer.');\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    signerKey: utils.toWebSafeBase64(options.hash.key),\n                    rounds: rounds,\n                    memoryCost: memoryCost,\n                    saltSeparator: utils.toWebSafeBase64(options.hash.saltSeparator || Buffer.from('')),\n                };\n                break;\n            }\n            case 'BCRYPT':\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                };\n                break;\n            case 'STANDARD_SCRYPT': {\n                var cpuMemCost = getNumberField(options.hash, 'memoryCost');\n                if (isNaN(cpuMemCost)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, 'A valid \"hash.memoryCost\" number must be provided for ' +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                var parallelization = getNumberField(options.hash, 'parallelization');\n                if (isNaN(parallelization)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_PARALLELIZATION, 'A valid \"hash.parallelization\" number must be provided for ' +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                var blockSize = getNumberField(options.hash, 'blockSize');\n                if (isNaN(blockSize)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE, 'A valid \"hash.blockSize\" number must be provided for ' +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                var dkLen = getNumberField(options.hash, 'derivedKeyLength');\n                if (isNaN(dkLen)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH, 'A valid \"hash.derivedKeyLength\" number must be provided for ' +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    cpuMemCost: cpuMemCost,\n                    parallelization: parallelization,\n                    blockSize: blockSize,\n                    dkLen: dkLen,\n                };\n                break;\n            }\n            default:\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, \"Unsupported hash algorithm provider \\\"\" + options.hash.algorithm + \"\\\".\");\n        }\n        return populatedOptions;\n    };\n    /**\n     * Validates and returns the users list of the uploadAccount request.\n     * Whenever a user with an error is detected, the error is cached and will later be\n     * merged into the user import result. This allows the processing of valid users without\n     * failing early on the first error detected.\n     * @param {UserImportRecord[]} users The UserImportRecords to convert to UnploadAccountUser\n     *     objects.\n     * @param {ValidatorFunction=} userValidator The user validator function.\n     * @return {UploadAccountUser[]} The populated uploadAccount users.\n     */\n    UserImportBuilder.prototype.populateUsers = function (users, userValidator) {\n        var _this = this;\n        var populatedUsers = [];\n        users.forEach(function (user, index) {\n            try {\n                var result = populateUploadAccountUser(user, userValidator);\n                if (typeof result.passwordHash !== 'undefined') {\n                    _this.requiresHashOptions = true;\n                }\n                // Only users that pass client screening will be passed to backend for processing.\n                populatedUsers.push(result);\n                // Map user's index (the one to be sent to backend) to original developer provided array.\n                _this.indexMap[populatedUsers.length - 1] = index;\n            }\n            catch (error) {\n                // Save the client side error with respect to the developer provided array.\n                _this.userImportResultErrors.push({\n                    index: index,\n                    error: error,\n                });\n            }\n        });\n        return populatedUsers;\n    };\n    return UserImportBuilder;\n}());\nexports.UserImportBuilder = UserImportBuilder;\n"]},"metadata":{},"sourceType":"script"}