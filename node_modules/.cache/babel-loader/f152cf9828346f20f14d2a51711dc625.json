{"ast":null,"code":"\"use strict\";\n/* eslint-disable prefer-rest-params */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.callbackifyAll = exports.callbackify = exports.promisifyAll = exports.promisify = void 0;\n/**\n * Wraps a callback style function to conditionally return a promise.\n *\n * @param {function} originalMethod - The method to promisify.\n * @param {object=} options - Promise options.\n * @param {boolean} options.singular - Resolve the promise with single arg instead of an array.\n * @return {function} wrapped\n */\n\nfunction promisify(originalMethod, options) {\n  if (originalMethod.promisified_) {\n    return originalMethod;\n  }\n\n  options = options || {};\n  const slice = Array.prototype.slice; // tslint:disable-next-line:no-any\n\n  const wrapper = function () {\n    let last;\n\n    for (last = arguments.length - 1; last >= 0; last--) {\n      const arg = arguments[last];\n\n      if (typeof arg === 'undefined') {\n        continue; // skip trailing undefined.\n      }\n\n      if (typeof arg !== 'function') {\n        break; // non-callback last argument found.\n      }\n\n      return originalMethod.apply(this, arguments);\n    } // peel trailing undefined.\n\n\n    const args = slice.call(arguments, 0, last + 1); // tslint:disable-next-line:variable-name\n\n    let PromiseCtor = Promise; // Because dedupe will likely create a single install of\n    // @google-cloud/common to be shared amongst all modules, we need to\n    // localize it at the Service level.\n\n    if (this && this.Promise) {\n      PromiseCtor = this.Promise;\n    }\n\n    return new PromiseCtor((resolve, reject) => {\n      // tslint:disable-next-line:no-any\n      args.push((...args) => {\n        const callbackArgs = slice.call(args);\n        const err = callbackArgs.shift();\n\n        if (err) {\n          return reject(err);\n        }\n\n        if (options.singular && callbackArgs.length === 1) {\n          resolve(callbackArgs[0]);\n        } else {\n          resolve(callbackArgs);\n        }\n      });\n      originalMethod.apply(this, args);\n    });\n  };\n\n  wrapper.promisified_ = true;\n  return wrapper;\n}\n\nexports.promisify = promisify;\n/**\n * Promisifies certain Class methods. This will not promisify private or\n * streaming methods.\n *\n * @param {module:common/service} Class - Service class.\n * @param {object=} options - Configuration object.\n */\n// tslint:disable-next-line:variable-name\n\nfunction promisifyAll(Class, options) {\n  const exclude = options && options.exclude || [];\n  const ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);\n  const methods = ownPropertyNames.filter(methodName => {\n    // clang-format off\n    return !exclude.includes(methodName) && typeof Class.prototype[methodName] === 'function' && // is it a function?\n    !/(^_|(Stream|_)|promise$)|^constructor$/.test(methodName) // is it promisable?\n    ; // clang-format on\n  });\n  methods.forEach(methodName => {\n    const originalMethod = Class.prototype[methodName];\n\n    if (!originalMethod.promisified_) {\n      Class.prototype[methodName] = exports.promisify(originalMethod, options);\n    }\n  });\n}\n\nexports.promisifyAll = promisifyAll;\n/**\n * Wraps a promisy type function to conditionally call a callback function.\n *\n * @param {function} originalMethod - The method to callbackify.\n * @param {object=} options - Callback options.\n * @param {boolean} options.singular - Pass to the callback a single arg instead of an array.\n * @return {function} wrapped\n */\n\nfunction callbackify(originalMethod) {\n  if (originalMethod.callbackified_) {\n    return originalMethod;\n  } // tslint:disable-next-line:no-any\n\n\n  const wrapper = function () {\n    if (typeof arguments[arguments.length - 1] !== 'function') {\n      return originalMethod.apply(this, arguments);\n    }\n\n    const cb = Array.prototype.pop.call(arguments);\n    originalMethod.apply(this, arguments).then( // tslint:disable-next-line:no-any\n    res => {\n      res = Array.isArray(res) ? res : [res];\n      cb(null, ...res);\n    }, err => cb(err));\n  };\n\n  wrapper.callbackified_ = true;\n  return wrapper;\n}\n\nexports.callbackify = callbackify;\n/**\n * Callbackifies certain Class methods. This will not callbackify private or\n * streaming methods.\n *\n * @param {module:common/service} Class - Service class.\n * @param {object=} options - Configuration object.\n */\n\nfunction callbackifyAll( // tslint:disable-next-line:variable-name\nClass, options) {\n  const exclude = options && options.exclude || [];\n  const ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);\n  const methods = ownPropertyNames.filter(methodName => {\n    // clang-format off\n    return !exclude.includes(methodName) && typeof Class.prototype[methodName] === 'function' && // is it a function?\n    !/^_|(Stream|_)|^constructor$/.test(methodName) // is it callbackifyable?\n    ; // clang-format on\n  });\n  methods.forEach(methodName => {\n    const originalMethod = Class.prototype[methodName];\n\n    if (!originalMethod.callbackified_) {\n      Class.prototype[methodName] = exports.callbackify(originalMethod);\n    }\n  });\n}\n\nexports.callbackifyAll = callbackifyAll;","map":{"version":3,"sources":["/Users/pulkitmittal/nft-bridge/NFTbridge/node_modules/@google-cloud/promisify/build/src/index.js"],"names":["Object","defineProperty","exports","value","callbackifyAll","callbackify","promisifyAll","promisify","originalMethod","options","promisified_","slice","Array","prototype","wrapper","last","arguments","length","arg","apply","args","call","PromiseCtor","Promise","resolve","reject","push","callbackArgs","err","shift","singular","Class","exclude","ownPropertyNames","getOwnPropertyNames","methods","filter","methodName","includes","test","forEach","callbackified_","cb","pop","then","res","isArray"],"mappings":"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","sourcesContent":["\"use strict\";\n/* eslint-disable prefer-rest-params */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.callbackifyAll = exports.callbackify = exports.promisifyAll = exports.promisify = void 0;\n/**\n * Wraps a callback style function to conditionally return a promise.\n *\n * @param {function} originalMethod - The method to promisify.\n * @param {object=} options - Promise options.\n * @param {boolean} options.singular - Resolve the promise with single arg instead of an array.\n * @return {function} wrapped\n */\nfunction promisify(originalMethod, options) {\n    if (originalMethod.promisified_) {\n        return originalMethod;\n    }\n    options = options || {};\n    const slice = Array.prototype.slice;\n    // tslint:disable-next-line:no-any\n    const wrapper = function () {\n        let last;\n        for (last = arguments.length - 1; last >= 0; last--) {\n            const arg = arguments[last];\n            if (typeof arg === 'undefined') {\n                continue; // skip trailing undefined.\n            }\n            if (typeof arg !== 'function') {\n                break; // non-callback last argument found.\n            }\n            return originalMethod.apply(this, arguments);\n        }\n        // peel trailing undefined.\n        const args = slice.call(arguments, 0, last + 1);\n        // tslint:disable-next-line:variable-name\n        let PromiseCtor = Promise;\n        // Because dedupe will likely create a single install of\n        // @google-cloud/common to be shared amongst all modules, we need to\n        // localize it at the Service level.\n        if (this && this.Promise) {\n            PromiseCtor = this.Promise;\n        }\n        return new PromiseCtor((resolve, reject) => {\n            // tslint:disable-next-line:no-any\n            args.push((...args) => {\n                const callbackArgs = slice.call(args);\n                const err = callbackArgs.shift();\n                if (err) {\n                    return reject(err);\n                }\n                if (options.singular && callbackArgs.length === 1) {\n                    resolve(callbackArgs[0]);\n                }\n                else {\n                    resolve(callbackArgs);\n                }\n            });\n            originalMethod.apply(this, args);\n        });\n    };\n    wrapper.promisified_ = true;\n    return wrapper;\n}\nexports.promisify = promisify;\n/**\n * Promisifies certain Class methods. This will not promisify private or\n * streaming methods.\n *\n * @param {module:common/service} Class - Service class.\n * @param {object=} options - Configuration object.\n */\n// tslint:disable-next-line:variable-name\nfunction promisifyAll(Class, options) {\n    const exclude = (options && options.exclude) || [];\n    const ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);\n    const methods = ownPropertyNames.filter(methodName => {\n        // clang-format off\n        return (!exclude.includes(methodName) &&\n            typeof Class.prototype[methodName] === 'function' && // is it a function?\n            !/(^_|(Stream|_)|promise$)|^constructor$/.test(methodName) // is it promisable?\n        );\n        // clang-format on\n    });\n    methods.forEach(methodName => {\n        const originalMethod = Class.prototype[methodName];\n        if (!originalMethod.promisified_) {\n            Class.prototype[methodName] = exports.promisify(originalMethod, options);\n        }\n    });\n}\nexports.promisifyAll = promisifyAll;\n/**\n * Wraps a promisy type function to conditionally call a callback function.\n *\n * @param {function} originalMethod - The method to callbackify.\n * @param {object=} options - Callback options.\n * @param {boolean} options.singular - Pass to the callback a single arg instead of an array.\n * @return {function} wrapped\n */\nfunction callbackify(originalMethod) {\n    if (originalMethod.callbackified_) {\n        return originalMethod;\n    }\n    // tslint:disable-next-line:no-any\n    const wrapper = function () {\n        if (typeof arguments[arguments.length - 1] !== 'function') {\n            return originalMethod.apply(this, arguments);\n        }\n        const cb = Array.prototype.pop.call(arguments);\n        originalMethod.apply(this, arguments).then(\n        // tslint:disable-next-line:no-any\n        (res) => {\n            res = Array.isArray(res) ? res : [res];\n            cb(null, ...res);\n        }, (err) => cb(err));\n    };\n    wrapper.callbackified_ = true;\n    return wrapper;\n}\nexports.callbackify = callbackify;\n/**\n * Callbackifies certain Class methods. This will not callbackify private or\n * streaming methods.\n *\n * @param {module:common/service} Class - Service class.\n * @param {object=} options - Configuration object.\n */\nfunction callbackifyAll(\n// tslint:disable-next-line:variable-name\nClass, options) {\n    const exclude = (options && options.exclude) || [];\n    const ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);\n    const methods = ownPropertyNames.filter(methodName => {\n        // clang-format off\n        return (!exclude.includes(methodName) &&\n            typeof Class.prototype[methodName] === 'function' && // is it a function?\n            !/^_|(Stream|_)|^constructor$/.test(methodName) // is it callbackifyable?\n        );\n        // clang-format on\n    });\n    methods.forEach(methodName => {\n        const originalMethod = Class.prototype[methodName];\n        if (!originalMethod.callbackified_) {\n            Class.prototype[methodName] = exports.callbackify(originalMethod);\n        }\n    });\n}\nexports.callbackifyAll = callbackifyAll;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}