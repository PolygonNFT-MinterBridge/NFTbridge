{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert = require(\"assert\");\n\nconst logger_1 = require(\"./logger\");\n\nconst util_1 = require(\"./util\");\n\nexports.CLIENT_TERMINATED_ERROR_MSG = 'The client has already been terminated';\n/**\n * An auto-resizing pool that distributes concurrent operations over multiple\n * clients of type `T`.\n *\n * ClientPool is used within Firestore to manage a pool of GAPIC clients and\n * automatically initializes multiple clients if we issue more than 100\n * concurrent operations.\n *\n * @private\n */\n\nclass ClientPool {\n  /**\n   * @param concurrentOperationLimit The number of operations that each client\n   * can handle.\n   * @param maxIdleClients The maximum number of idle clients to keep before\n   * garbage collecting.\n   * @param clientFactory A factory function called as needed when new clients\n   * are required.\n   * @param clientDestructor A cleanup function that is called when a client is\n   * disposed of.\n   */\n  constructor(concurrentOperationLimit, maxIdleClients, clientFactory, clientDestructor = () => Promise.resolve()) {\n    this.concurrentOperationLimit = concurrentOperationLimit;\n    this.maxIdleClients = maxIdleClients;\n    this.clientFactory = clientFactory;\n    this.clientDestructor = clientDestructor;\n    /**\n     * Stores each active clients and how many operations it has outstanding.\n     */\n\n    this.activeClients = new Map();\n    /**\n     * A set of clients that have seen RST_STREAM errors (see\n     * https://github.com/googleapis/nodejs-firestore/issues/1023) and should\n     * no longer be used.\n     */\n\n    this.failedClients = new Set();\n    /**\n     * Whether the Firestore instance has been terminated. Once terminated, the\n     * ClientPool can longer schedule new operations.\n     */\n\n    this.terminated = false;\n    /**\n     * Deferred promise that is resolved when there are no active operations on\n     * the client pool after terminate() has been called.\n     */\n\n    this.terminateDeferred = new util_1.Deferred();\n  }\n  /**\n   * Returns an already existing client if it has less than the maximum number\n   * of concurrent operations or initializes and returns a new client.\n   *\n   * @private\n   */\n\n\n  acquire(requestTag) {\n    let selectedClient = null;\n    let selectedClientRequestCount = -1;\n\n    for (const [client, requestCount] of this.activeClients) {\n      // Use the \"most-full\" client that can still accommodate the request\n      // in order to maximize the number of idle clients as operations start to\n      // complete.\n      if (!this.failedClients.has(client) && requestCount > selectedClientRequestCount && requestCount < this.concurrentOperationLimit) {\n        selectedClient = client;\n        selectedClientRequestCount = requestCount;\n      }\n    }\n\n    if (selectedClient) {\n      logger_1.logger('ClientPool.acquire', requestTag, 'Re-using existing client with %s remaining operations', this.concurrentOperationLimit - selectedClientRequestCount);\n    } else {\n      logger_1.logger('ClientPool.acquire', requestTag, 'Creating a new client');\n      selectedClient = this.clientFactory();\n      selectedClientRequestCount = 0;\n      assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');\n    }\n\n    this.activeClients.set(selectedClient, selectedClientRequestCount + 1);\n    return selectedClient;\n  }\n  /**\n   * Reduces the number of operations for the provided client, potentially\n   * removing it from the pool of active clients.\n   * @private\n   */\n\n\n  async release(requestTag, client) {\n    const requestCount = this.activeClients.get(client) || 0;\n    assert(requestCount > 0, 'No active requests');\n    this.activeClients.set(client, requestCount - 1);\n\n    if (this.terminated && this.opCount === 0) {\n      this.terminateDeferred.resolve();\n    }\n\n    if (this.shouldGarbageCollectClient(client)) {\n      this.activeClients.delete(client);\n      this.failedClients.delete(client);\n      await this.clientDestructor(client);\n      logger_1.logger('ClientPool.release', requestTag, 'Garbage collected 1 client');\n    }\n  }\n  /**\n   * Given the current operation counts, determines if the given client should\n   * be garbage collected.\n   * @private\n   */\n\n\n  shouldGarbageCollectClient(client) {\n    // Don't garbage collect clients that have active requests.\n    if (this.activeClients.get(client) !== 0) {\n      return false;\n    } // Idle clients that have received RST_STREAM errors are always garbage\n    // collected.\n\n\n    if (this.failedClients.has(client)) {\n      return true;\n    } // Otherwise, only garbage collect if we have too much idle capacity (e.g.\n    // more than 100 idle capacity with default settings) .\n\n\n    let idleCapacityCount = 0;\n\n    for (const [, count] of this.activeClients) {\n      idleCapacityCount += this.concurrentOperationLimit - count;\n    }\n\n    return idleCapacityCount > this.maxIdleClients * this.concurrentOperationLimit;\n  }\n  /**\n   * The number of currently registered clients.\n   *\n   * @return Number of currently registered clients.\n   * @private\n   */\n  // Visible for testing.\n\n\n  get size() {\n    return this.activeClients.size;\n  }\n  /**\n   * The number of currently active operations.\n   *\n   * @return Number of currently active operations.\n   * @private\n   */\n  // Visible for testing.\n\n\n  get opCount() {\n    let activeOperationCount = 0;\n    this.activeClients.forEach(count => activeOperationCount += count);\n    return activeOperationCount;\n  }\n  /**\n   * Runs the provided operation in this pool. This function may create an\n   * additional client if all existing clients already operate at the concurrent\n   * operation limit.\n   *\n   * @param requestTag A unique client-assigned identifier for this operation.\n   * @param op A callback function that returns a Promise. The client T will\n   * be returned to the pool when callback finishes.\n   * @return A Promise that resolves with the result of `op`.\n   * @private\n   */\n\n\n  run(requestTag, op) {\n    if (this.terminated) {\n      return Promise.reject(new Error(exports.CLIENT_TERMINATED_ERROR_MSG));\n    }\n\n    const client = this.acquire(requestTag);\n    return op(client).catch(async err => {\n      var _a;\n\n      if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.match(/RST_STREAM/)) {\n        // Once a client has seen a RST_STREAM error, the GRPC channel can\n        // no longer be used. We mark the client as failed, which ensures that\n        // we open a new GRPC channel for the next request.\n        this.failedClients.add(client);\n      }\n\n      await this.release(requestTag, client);\n      return Promise.reject(err);\n    }).then(async res => {\n      await this.release(requestTag, client);\n      return res;\n    });\n  }\n\n  async terminate() {\n    this.terminated = true; // Wait for all pending operations to complete before terminating.\n\n    if (this.opCount > 0) {\n      logger_1.logger('ClientPool.terminate',\n      /* requestTag= */\n      null, 'Waiting for %s pending operations to complete before terminating', this.opCount);\n      await this.terminateDeferred.promise;\n    }\n\n    for (const [client] of this.activeClients) {\n      this.activeClients.delete(client);\n      await this.clientDestructor(client);\n    }\n  }\n\n}\n\nexports.ClientPool = ClientPool;","map":{"version":3,"sources":["/Users/pulkitmittal/nft-bridge/NFTbridge/node_modules/@google-cloud/firestore/build/src/pool.js"],"names":["Object","defineProperty","exports","value","assert","require","logger_1","util_1","CLIENT_TERMINATED_ERROR_MSG","ClientPool","constructor","concurrentOperationLimit","maxIdleClients","clientFactory","clientDestructor","Promise","resolve","activeClients","Map","failedClients","Set","terminated","terminateDeferred","Deferred","acquire","requestTag","selectedClient","selectedClientRequestCount","client","requestCount","has","logger","set","release","get","opCount","shouldGarbageCollectClient","delete","idleCapacityCount","count","size","activeOperationCount","forEach","run","op","reject","Error","catch","err","_a","message","match","add","then","res","terminate","promise"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nconst logger_1 = require(\"./logger\");\nconst util_1 = require(\"./util\");\nexports.CLIENT_TERMINATED_ERROR_MSG = 'The client has already been terminated';\n/**\n * An auto-resizing pool that distributes concurrent operations over multiple\n * clients of type `T`.\n *\n * ClientPool is used within Firestore to manage a pool of GAPIC clients and\n * automatically initializes multiple clients if we issue more than 100\n * concurrent operations.\n *\n * @private\n */\nclass ClientPool {\n    /**\n     * @param concurrentOperationLimit The number of operations that each client\n     * can handle.\n     * @param maxIdleClients The maximum number of idle clients to keep before\n     * garbage collecting.\n     * @param clientFactory A factory function called as needed when new clients\n     * are required.\n     * @param clientDestructor A cleanup function that is called when a client is\n     * disposed of.\n     */\n    constructor(concurrentOperationLimit, maxIdleClients, clientFactory, clientDestructor = () => Promise.resolve()) {\n        this.concurrentOperationLimit = concurrentOperationLimit;\n        this.maxIdleClients = maxIdleClients;\n        this.clientFactory = clientFactory;\n        this.clientDestructor = clientDestructor;\n        /**\n         * Stores each active clients and how many operations it has outstanding.\n         */\n        this.activeClients = new Map();\n        /**\n         * A set of clients that have seen RST_STREAM errors (see\n         * https://github.com/googleapis/nodejs-firestore/issues/1023) and should\n         * no longer be used.\n         */\n        this.failedClients = new Set();\n        /**\n         * Whether the Firestore instance has been terminated. Once terminated, the\n         * ClientPool can longer schedule new operations.\n         */\n        this.terminated = false;\n        /**\n         * Deferred promise that is resolved when there are no active operations on\n         * the client pool after terminate() has been called.\n         */\n        this.terminateDeferred = new util_1.Deferred();\n    }\n    /**\n     * Returns an already existing client if it has less than the maximum number\n     * of concurrent operations or initializes and returns a new client.\n     *\n     * @private\n     */\n    acquire(requestTag) {\n        let selectedClient = null;\n        let selectedClientRequestCount = -1;\n        for (const [client, requestCount] of this.activeClients) {\n            // Use the \"most-full\" client that can still accommodate the request\n            // in order to maximize the number of idle clients as operations start to\n            // complete.\n            if (!this.failedClients.has(client) &&\n                requestCount > selectedClientRequestCount &&\n                requestCount < this.concurrentOperationLimit) {\n                selectedClient = client;\n                selectedClientRequestCount = requestCount;\n            }\n        }\n        if (selectedClient) {\n            logger_1.logger('ClientPool.acquire', requestTag, 'Re-using existing client with %s remaining operations', this.concurrentOperationLimit - selectedClientRequestCount);\n        }\n        else {\n            logger_1.logger('ClientPool.acquire', requestTag, 'Creating a new client');\n            selectedClient = this.clientFactory();\n            selectedClientRequestCount = 0;\n            assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');\n        }\n        this.activeClients.set(selectedClient, selectedClientRequestCount + 1);\n        return selectedClient;\n    }\n    /**\n     * Reduces the number of operations for the provided client, potentially\n     * removing it from the pool of active clients.\n     * @private\n     */\n    async release(requestTag, client) {\n        const requestCount = this.activeClients.get(client) || 0;\n        assert(requestCount > 0, 'No active requests');\n        this.activeClients.set(client, requestCount - 1);\n        if (this.terminated && this.opCount === 0) {\n            this.terminateDeferred.resolve();\n        }\n        if (this.shouldGarbageCollectClient(client)) {\n            this.activeClients.delete(client);\n            this.failedClients.delete(client);\n            await this.clientDestructor(client);\n            logger_1.logger('ClientPool.release', requestTag, 'Garbage collected 1 client');\n        }\n    }\n    /**\n     * Given the current operation counts, determines if the given client should\n     * be garbage collected.\n     * @private\n     */\n    shouldGarbageCollectClient(client) {\n        // Don't garbage collect clients that have active requests.\n        if (this.activeClients.get(client) !== 0) {\n            return false;\n        }\n        // Idle clients that have received RST_STREAM errors are always garbage\n        // collected.\n        if (this.failedClients.has(client)) {\n            return true;\n        }\n        // Otherwise, only garbage collect if we have too much idle capacity (e.g.\n        // more than 100 idle capacity with default settings) .\n        let idleCapacityCount = 0;\n        for (const [, count] of this.activeClients) {\n            idleCapacityCount += this.concurrentOperationLimit - count;\n        }\n        return (idleCapacityCount > this.maxIdleClients * this.concurrentOperationLimit);\n    }\n    /**\n     * The number of currently registered clients.\n     *\n     * @return Number of currently registered clients.\n     * @private\n     */\n    // Visible for testing.\n    get size() {\n        return this.activeClients.size;\n    }\n    /**\n     * The number of currently active operations.\n     *\n     * @return Number of currently active operations.\n     * @private\n     */\n    // Visible for testing.\n    get opCount() {\n        let activeOperationCount = 0;\n        this.activeClients.forEach(count => (activeOperationCount += count));\n        return activeOperationCount;\n    }\n    /**\n     * Runs the provided operation in this pool. This function may create an\n     * additional client if all existing clients already operate at the concurrent\n     * operation limit.\n     *\n     * @param requestTag A unique client-assigned identifier for this operation.\n     * @param op A callback function that returns a Promise. The client T will\n     * be returned to the pool when callback finishes.\n     * @return A Promise that resolves with the result of `op`.\n     * @private\n     */\n    run(requestTag, op) {\n        if (this.terminated) {\n            return Promise.reject(new Error(exports.CLIENT_TERMINATED_ERROR_MSG));\n        }\n        const client = this.acquire(requestTag);\n        return op(client)\n            .catch(async (err) => {\n            var _a;\n            if ((_a = err.message) === null || _a === void 0 ? void 0 : _a.match(/RST_STREAM/)) {\n                // Once a client has seen a RST_STREAM error, the GRPC channel can\n                // no longer be used. We mark the client as failed, which ensures that\n                // we open a new GRPC channel for the next request.\n                this.failedClients.add(client);\n            }\n            await this.release(requestTag, client);\n            return Promise.reject(err);\n        })\n            .then(async (res) => {\n            await this.release(requestTag, client);\n            return res;\n        });\n    }\n    async terminate() {\n        this.terminated = true;\n        // Wait for all pending operations to complete before terminating.\n        if (this.opCount > 0) {\n            logger_1.logger('ClientPool.terminate', \n            /* requestTag= */ null, 'Waiting for %s pending operations to complete before terminating', this.opCount);\n            await this.terminateDeferred.promise;\n        }\n        for (const [client] of this.activeClients) {\n            this.activeClients.delete(client);\n            await this.clientDestructor(client);\n        }\n    }\n}\nexports.ClientPool = ClientPool;\n//# sourceMappingURL=pool.js.map"]},"metadata":{},"sourceType":"script"}