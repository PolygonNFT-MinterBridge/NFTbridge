{"ast":null,"code":"\"use strict\";\n\nmodule.exports = encoder;\n\nvar Enum = require(\"./enum\"),\n    types = require(\"./types\"),\n    util = require(\"./util\");\n/**\n * Generates a partial message type encoder.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\n\n\nfunction genTypePartial(gen, field, fieldIndex, ref) {\n  return field.resolvedType.group ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n/**\n * Generates an encoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\n\n\nfunction encoder(mtype) {\n  /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n  var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")(\"if(!w)\")(\"w=Writer.create()\");\n  var i, ref; // \"when a message is serialized its known fields should be written sequentially by field number\"\n\n  var fields =\n  /* initializes */\n  mtype.fieldsArray.slice().sort(util.compareFieldsById);\n\n  for (var i = 0; i < fields.length; ++i) {\n    var field = fields[i].resolve(),\n        index = mtype._fieldsArray.indexOf(field),\n        type = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n        wireType = types.basic[type];\n\n    ref = \"m\" + util.safeProp(field.name); // Map fields\n\n    if (field.map) {\n      gen(\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n      (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)(\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n      if (wireType === undefined) gen(\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n      else gen(\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n      gen(\"}\")(\"}\"); // Repeated fields\n    } else if (field.repeated) {\n      gen(\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n      // Packed repeated\n\n      if (field.packed && types.packed[type] !== undefined) {\n        gen(\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)(\"for(var i=0;i<%s.length;++i)\", ref)(\"w.%s(%s[i])\", type, ref)(\"w.ldelim()\"); // Non-packed\n      } else {\n        gen(\"for(var i=0;i<%s.length;++i)\", ref);\n        if (wireType === undefined) genTypePartial(gen, field, index, ref + \"[i]\");else gen(\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n      }\n\n      gen(\"}\"); // Non-repeated\n    } else {\n      if (field.optional) gen(\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n\n      if (wireType === undefined) genTypePartial(gen, field, index, ref);else gen(\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n    }\n  }\n\n  return gen(\"return w\");\n  /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}","map":{"version":3,"sources":["/Users/piyushmaheshwari/Downloads/github/Bridgeorg/node_modules/protobufjs/src/encoder.js"],"names":["module","exports","encoder","Enum","require","types","util","genTypePartial","gen","field","fieldIndex","ref","resolvedType","group","id","mtype","codegen","name","i","fields","fieldsArray","slice","sort","compareFieldsById","length","resolve","index","_fieldsArray","indexOf","type","wireType","basic","safeProp","map","mapKey","keyType","undefined","repeated","packed","optional"],"mappings":"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","sourcesContent":["\"use strict\";\nmodule.exports = encoder;\n\nvar Enum     = require(\"./enum\"),\n    types    = require(\"./types\"),\n    util     = require(\"./util\");\n\n/**\n * Generates a partial message type encoder.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */\nfunction genTypePartial(gen, field, fieldIndex, ref) {\n    return field.resolvedType.group\n        ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)\n        : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n\n/**\n * Generates an encoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction encoder(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */\n    var gen = util.codegen([\"m\", \"w\"], mtype.name + \"$encode\")\n    (\"if(!w)\")\n        (\"w=Writer.create()\");\n\n    var i, ref;\n\n    // \"when a message is serialized its known fields should be written sequentially by field number\"\n    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);\n\n    for (var i = 0; i < fields.length; ++i) {\n        var field    = fields[i].resolve(),\n            index    = mtype._fieldsArray.indexOf(field),\n            type     = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n            wireType = types.basic[type];\n            ref      = \"m\" + util.safeProp(field.name);\n\n        // Map fields\n        if (field.map) {\n            gen\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n        (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)\n            (\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n            if (wireType === undefined) gen\n            (\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n            else gen\n            (\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n            gen\n        (\"}\")\n    (\"}\");\n\n            // Repeated fields\n        } else if (field.repeated) { gen\n    (\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n\n            // Packed repeated\n            if (field.packed && types.packed[type] !== undefined) { gen\n\n        (\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)\n        (\"for(var i=0;i<%s.length;++i)\", ref)\n            (\"w.%s(%s[i])\", type, ref)\n        (\"w.ldelim()\");\n\n            // Non-packed\n            } else { gen\n\n        (\"for(var i=0;i<%s.length;++i)\", ref);\n                if (wireType === undefined)\n            genTypePartial(gen, field, index, ref + \"[i]\");\n                else gen\n            (\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n            } gen\n    (\"}\");\n\n        // Non-repeated\n        } else {\n            if (field.optional) gen\n    (\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n\n            if (wireType === undefined)\n        genTypePartial(gen, field, index, ref);\n            else gen\n        (\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n\n        }\n    }\n\n    return gen\n    (\"return w\");\n    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */\n}\n"]},"metadata":{},"sourceType":"script"}