{"ast":null,"code":"\"use strict\";\n\nmodule.exports = fetch;\n\nvar asPromise = require(\"@protobufjs/aspromise\"),\n    inquire = require(\"@protobufjs/inquire\");\n\nvar fs = inquire(\"fs\");\n/**\r\n * Node-style callback as used by {@link util.fetch}.\r\n * @typedef FetchCallback\r\n * @type {function}\r\n * @param {?Error} error Error, if any, otherwise `null`\r\n * @param {string} [contents] File contents, if there hasn't been an error\r\n * @returns {undefined}\r\n */\n\n/**\r\n * Options as used by {@link util.fetch}.\r\n * @typedef FetchOptions\r\n * @type {Object}\r\n * @property {boolean} [binary=false] Whether expecting a binary response\r\n * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest\r\n */\n\n/**\r\n * Fetches the contents of a file.\r\n * @memberof util\r\n * @param {string} filename File path or url\r\n * @param {FetchOptions} options Fetch options\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n */\n\nfunction fetch(filename, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  } else if (!options) options = {};\n\n  if (!callback) return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this\n  // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.\n\n  if (!options.xhr && fs && fs.readFile) return fs.readFile(filename, function fetchReadFileCallback(err, contents) {\n    return err && typeof XMLHttpRequest !== \"undefined\" ? fetch.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString(\"utf8\"));\n  }); // use the XHR version otherwise.\n\n  return fetch.xhr(filename, options, callback);\n}\n/**\r\n * Fetches the contents of a file.\r\n * @name util.fetch\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n * @variation 2\r\n */\n\n/**\r\n * Fetches the contents of a file.\r\n * @name util.fetch\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchOptions} [options] Fetch options\r\n * @returns {Promise<string|Uint8Array>} Promise\r\n * @variation 3\r\n */\n\n/**/\n\n\nfetch.xhr = function fetch_xhr(filename, options, callback) {\n  var xhr = new XMLHttpRequest();\n\n  xhr.onreadystatechange\n  /* works everywhere */\n  = function fetchOnReadyStateChange() {\n    if (xhr.readyState !== 4) return undefined; // local cors security errors return status 0 / empty string, too. afaik this cannot be\n    // reliably distinguished from an actually empty file for security reasons. feel free\n    // to send a pull request if you are aware of a solution.\n\n    if (xhr.status !== 0 && xhr.status !== 200) return callback(Error(\"status \" + xhr.status)); // if binary data is expected, make sure that some sort of array is returned, even if\n    // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.\n\n    if (options.binary) {\n      var buffer = xhr.response;\n\n      if (!buffer) {\n        buffer = [];\n\n        for (var i = 0; i < xhr.responseText.length; ++i) buffer.push(xhr.responseText.charCodeAt(i) & 255);\n      }\n\n      return callback(null, typeof Uint8Array !== \"undefined\" ? new Uint8Array(buffer) : buffer);\n    }\n\n    return callback(null, xhr.responseText);\n  };\n\n  if (options.binary) {\n    // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers\n    if (\"overrideMimeType\" in xhr) xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n    xhr.responseType = \"arraybuffer\";\n  }\n\n  xhr.open(\"GET\", filename);\n  xhr.send();\n};","map":{"version":3,"sources":["/Users/pulkitmittal/nft-bridge/NFTbridge/node_modules/@protobufjs/fetch/index.js"],"names":["module","exports","fetch","asPromise","require","inquire","fs","filename","options","callback","xhr","readFile","fetchReadFileCallback","err","contents","XMLHttpRequest","binary","toString","fetch_xhr","onreadystatechange","fetchOnReadyStateChange","readyState","undefined","status","Error","buffer","response","i","responseText","length","push","charCodeAt","Uint8Array","overrideMimeType","responseType","open","send"],"mappings":"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","sourcesContent":["\"use strict\";\r\nmodule.exports = fetch;\r\n\r\nvar asPromise = require(\"@protobufjs/aspromise\"),\r\n    inquire   = require(\"@protobufjs/inquire\");\r\n\r\nvar fs = inquire(\"fs\");\r\n\r\n/**\r\n * Node-style callback as used by {@link util.fetch}.\r\n * @typedef FetchCallback\r\n * @type {function}\r\n * @param {?Error} error Error, if any, otherwise `null`\r\n * @param {string} [contents] File contents, if there hasn't been an error\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Options as used by {@link util.fetch}.\r\n * @typedef FetchOptions\r\n * @type {Object}\r\n * @property {boolean} [binary=false] Whether expecting a binary response\r\n * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest\r\n */\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @memberof util\r\n * @param {string} filename File path or url\r\n * @param {FetchOptions} options Fetch options\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n */\r\nfunction fetch(filename, options, callback) {\r\n    if (typeof options === \"function\") {\r\n        callback = options;\r\n        options = {};\r\n    } else if (!options)\r\n        options = {};\r\n\r\n    if (!callback)\r\n        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this\r\n\r\n    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.\r\n    if (!options.xhr && fs && fs.readFile)\r\n        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {\r\n            return err && typeof XMLHttpRequest !== \"undefined\"\r\n                ? fetch.xhr(filename, options, callback)\r\n                : err\r\n                ? callback(err)\r\n                : callback(null, options.binary ? contents : contents.toString(\"utf8\"));\r\n        });\r\n\r\n    // use the XHR version otherwise.\r\n    return fetch.xhr(filename, options, callback);\r\n}\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @name util.fetch\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchCallback} callback Callback function\r\n * @returns {undefined}\r\n * @variation 2\r\n */\r\n\r\n/**\r\n * Fetches the contents of a file.\r\n * @name util.fetch\r\n * @function\r\n * @param {string} path File path or url\r\n * @param {FetchOptions} [options] Fetch options\r\n * @returns {Promise<string|Uint8Array>} Promise\r\n * @variation 3\r\n */\r\n\r\n/**/\r\nfetch.xhr = function fetch_xhr(filename, options, callback) {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {\r\n\r\n        if (xhr.readyState !== 4)\r\n            return undefined;\r\n\r\n        // local cors security errors return status 0 / empty string, too. afaik this cannot be\r\n        // reliably distinguished from an actually empty file for security reasons. feel free\r\n        // to send a pull request if you are aware of a solution.\r\n        if (xhr.status !== 0 && xhr.status !== 200)\r\n            return callback(Error(\"status \" + xhr.status));\r\n\r\n        // if binary data is expected, make sure that some sort of array is returned, even if\r\n        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.\r\n        if (options.binary) {\r\n            var buffer = xhr.response;\r\n            if (!buffer) {\r\n                buffer = [];\r\n                for (var i = 0; i < xhr.responseText.length; ++i)\r\n                    buffer.push(xhr.responseText.charCodeAt(i) & 255);\r\n            }\r\n            return callback(null, typeof Uint8Array !== \"undefined\" ? new Uint8Array(buffer) : buffer);\r\n        }\r\n        return callback(null, xhr.responseText);\r\n    };\r\n\r\n    if (options.binary) {\r\n        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers\r\n        if (\"overrideMimeType\" in xhr)\r\n            xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\r\n        xhr.responseType = \"arraybuffer\";\r\n    }\r\n\r\n    xhr.open(\"GET\", filename);\r\n    xhr.send();\r\n};\r\n"]},"metadata":{},"sourceType":"script"}