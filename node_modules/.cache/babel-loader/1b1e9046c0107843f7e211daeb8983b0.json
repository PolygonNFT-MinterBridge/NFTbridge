{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert = require(\"assert\");\n\nconst rbtree = require(\"functional-red-black-tree\");\n\nconst google_gax_1 = require(\"google-gax\");\n\nconst backoff_1 = require(\"./backoff\");\n\nconst document_1 = require(\"./document\");\n\nconst document_change_1 = require(\"./document-change\");\n\nconst logger_1 = require(\"./logger\");\n\nconst path_1 = require(\"./path\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst types_1 = require(\"./types\");\n\nconst util_1 = require(\"./util\");\n/*!\n * Target ID used by watch. Watch uses a fixed target id since we only support\n * one target per stream.\n * @type {number}\n */\n\n\nconst WATCH_TARGET_ID = 0x1;\n/*!\n * Idle timeout used to detect Watch streams that stall (see\n * https://github.com/googleapis/nodejs-firestore/issues/1057, b/156308554).\n * Under normal load, the Watch backend will send a TARGET_CHANGE message\n * roughly every 30 seconds. As discussed with the backend team, we reset the\n * Watch stream if we do not receive any message within 120 seconds.\n */\n\nexports.WATCH_IDLE_TIMEOUT_MS = 120 * 1000;\n/*!\n * Sentinel value for a document remove.\n */\n\nconst REMOVED = {};\n/*!\n * The change type for document change events.\n */\n// tslint:disable-next-line:variable-name\n\nconst ChangeType = {\n  added: 'added',\n  modified: 'modified',\n  removed: 'removed'\n};\n/*!\n * The comparator used for document watches (which should always get called with\n * the same document).\n */\n\nconst DOCUMENT_WATCH_COMPARATOR = (doc1, doc2) => {\n  assert(doc1 === doc2, 'Document watches only support one document.');\n  return 0;\n};\n\nconst EMPTY_FUNCTION = () => {};\n/**\n * Watch provides listen functionality and exposes the 'onSnapshot' observer. It\n * can be used with a valid Firestore Listen target.\n *\n * @class\n * @private\n */\n\n\nclass Watch {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param firestore The Firestore Database client.\n   */\n  constructor(firestore, _converter = types_1.defaultConverter()) {\n    this._converter = _converter;\n    /**\n     * Indicates whether we are interested in data from the stream. Set to false in the\n     * 'unsubscribe()' callback.\n     * @private\n     */\n\n    this.isActive = true;\n    /**\n     * The current stream to the backend.\n     * @private\n     */\n\n    this.currentStream = null;\n    /**\n     * The server assigns and updates the resume token.\n     * @private\n     */\n\n    this.resumeToken = undefined;\n    /**\n     * A map of document names to QueryDocumentSnapshots for the last sent snapshot.\n     * @private\n     */\n\n    this.docMap = new Map();\n    /**\n     * The accumulated map of document changes (keyed by document name) for the\n     * current snapshot.\n     * @private\n     */\n\n    this.changeMap = new Map();\n    /**\n     * The current state of the query results. *\n     * @private\n     */\n\n    this.current = false;\n    /**\n     * We need this to track whether we've pushed an initial set of changes,\n     * since we should push those even when there are no changes, if there\n     * aren't docs.\n     * @private\n     */\n\n    this.hasPushed = false;\n    this.firestore = firestore;\n    this.backoff = new backoff_1.ExponentialBackoff();\n    this.requestTag = util_1.requestTag();\n    this.onNext = EMPTY_FUNCTION;\n    this.onError = EMPTY_FUNCTION;\n  }\n  /**\n   * Starts a watch and attaches a listener for document change events.\n   *\n   * @private\n   * @param onNext A callback to be called every time a new snapshot is\n   * available.\n   * @param onError A callback to be called if the listen fails or is cancelled.\n   * No further callbacks will occur.\n   *\n   * @returns An unsubscribe function that can be called to cancel the snapshot\n   * listener.\n   */\n\n\n  onSnapshot(onNext, onError) {\n    assert(this.onNext === EMPTY_FUNCTION, 'onNext should not already be defined.');\n    assert(this.onError === EMPTY_FUNCTION, 'onError should not already be defined.');\n    assert(this.docTree === undefined, 'docTree should not already be defined.');\n    this.onNext = onNext;\n    this.onError = onError;\n    this.docTree = rbtree(this.getComparator());\n    this.initStream();\n\n    const unsubscribe = () => {\n      logger_1.logger('Watch.onSnapshot', this.requestTag, 'Unsubscribe called'); // Prevent further callbacks.\n\n      this.onNext = () => {};\n\n      this.onError = () => {};\n\n      this.shutdown();\n    };\n\n    this.firestore.registerListener();\n    return unsubscribe;\n  }\n  /**\n   * Returns the current count of all documents, including the changes from\n   * the current changeMap.\n   * @private\n   */\n\n\n  currentSize() {\n    const changes = this.extractCurrentChanges(timestamp_1.Timestamp.now());\n    return this.docMap.size + changes.adds.length - changes.deletes.length;\n  }\n  /**\n   * Splits up document changes into removals, additions, and updates.\n   * @private\n   */\n\n\n  extractCurrentChanges(readTime) {\n    const deletes = [];\n    const adds = [];\n    const updates = [];\n    this.changeMap.forEach((value, name) => {\n      if (value === REMOVED) {\n        if (this.docMap.has(name)) {\n          deletes.push(name);\n        }\n      } else if (this.docMap.has(name)) {\n        value.readTime = readTime;\n        updates.push(value.build());\n      } else {\n        value.readTime = readTime;\n        adds.push(value.build());\n      }\n    });\n    return {\n      deletes,\n      adds,\n      updates\n    };\n  }\n  /**\n   * Helper to clear the docs on RESET or filter mismatch.\n   * @private\n   */\n\n\n  resetDocs() {\n    logger_1.logger('Watch.resetDocs', this.requestTag, 'Resetting documents');\n    this.changeMap.clear();\n    this.resumeToken = undefined;\n    this.docTree.forEach(snapshot => {\n      // Mark each document as deleted. If documents are not deleted, they\n      // will be send again by the server.\n      this.changeMap.set(snapshot.ref.path, REMOVED);\n    });\n    this.current = false;\n  }\n  /**\n   * Closes the stream and calls onError() if the stream is still active.\n   * @private\n   */\n\n\n  closeStream(err) {\n    if (this.isActive) {\n      logger_1.logger('Watch.closeStream', this.requestTag, 'Invoking onError: ', err);\n      this.onError(err);\n    }\n\n    this.shutdown();\n  }\n  /**\n   * Re-opens the stream unless the specified error is considered permanent.\n   * Clears the change map.\n   * @private\n   */\n\n\n  maybeReopenStream(err) {\n    if (this.isActive && !this.isPermanentWatchError(err)) {\n      logger_1.logger('Watch.maybeReopenStream', this.requestTag, 'Stream ended, re-opening after retryable error:', err);\n      this.changeMap.clear();\n\n      if (this.isResourceExhaustedError(err)) {\n        this.backoff.resetToMax();\n      }\n\n      this.initStream();\n    } else {\n      this.closeStream(err);\n    }\n  }\n  /**\n   * Cancels the current idle timeout and reschedules a new timer.\n   *\n   * @private\n   */\n\n\n  resetIdleTimeout() {\n    if (this.idleTimeoutHandle) {\n      clearTimeout(this.idleTimeoutHandle);\n    }\n\n    this.idleTimeoutHandle = backoff_1.delayExecution(() => {\n      var _a;\n\n      logger_1.logger('Watch.resetIdleTimeout', this.requestTag, 'Resetting stream after idle timeout');\n      (_a = this.currentStream) === null || _a === void 0 ? void 0 : _a.end();\n      this.currentStream = null;\n      const error = new google_gax_1.GoogleError('Watch stream idle timeout');\n      error.code = google_gax_1.Status.UNKNOWN;\n      this.maybeReopenStream(error);\n    }, exports.WATCH_IDLE_TIMEOUT_MS);\n  }\n  /**\n   * Helper to restart the outgoing stream to the backend.\n   * @private\n   */\n\n\n  resetStream() {\n    logger_1.logger('Watch.resetStream', this.requestTag, 'Restarting stream');\n\n    if (this.currentStream) {\n      this.currentStream.end();\n      this.currentStream = null;\n    }\n\n    this.initStream();\n  }\n  /**\n   * Initializes a new stream to the backend with backoff.\n   * @private\n   */\n\n\n  initStream() {\n    this.backoff.backoffAndWait().then(async () => {\n      if (!this.isActive) {\n        logger_1.logger('Watch.initStream', this.requestTag, 'Not initializing inactive stream');\n        return;\n      }\n\n      await this.firestore.initializeIfNeeded(this.requestTag);\n      const request = {};\n      request.database = this.firestore.formattedName;\n      request.addTarget = this.getTarget(this.resumeToken); // Note that we need to call the internal _listen API to pass additional\n      // header values in readWriteStream.\n\n      return this.firestore.requestStream('listen', request, this.requestTag).then(backendStream => {\n        if (!this.isActive) {\n          logger_1.logger('Watch.initStream', this.requestTag, 'Closing inactive stream');\n          backendStream.emit('end');\n          return;\n        }\n\n        logger_1.logger('Watch.initStream', this.requestTag, 'Opened new stream');\n        this.currentStream = backendStream;\n        this.resetIdleTimeout();\n        this.currentStream.on('data', proto => {\n          this.resetIdleTimeout();\n          this.onData(proto);\n        }).on('error', err => {\n          if (this.currentStream === backendStream) {\n            this.currentStream = null;\n            this.maybeReopenStream(err);\n          }\n        }).on('end', () => {\n          if (this.currentStream === backendStream) {\n            this.currentStream = null;\n            const err = new google_gax_1.GoogleError('Stream ended unexpectedly');\n            err.code = google_gax_1.Status.UNKNOWN;\n            this.maybeReopenStream(err);\n          }\n        });\n        this.currentStream.resume();\n      });\n    }).catch(err => {\n      this.closeStream(err);\n    });\n  }\n  /**\n   * Handles 'data' events and closes the stream if the response type is\n   * invalid.\n   * @private\n   */\n\n\n  onData(proto) {\n    if (proto.targetChange) {\n      logger_1.logger('Watch.onData', this.requestTag, 'Processing target change');\n      const change = proto.targetChange;\n      const noTargetIds = !change.targetIds || change.targetIds.length === 0;\n\n      if (change.targetChangeType === 'NO_CHANGE') {\n        if (noTargetIds && change.readTime && this.current) {\n          // This means everything is up-to-date, so emit the current\n          // set of docs as a snapshot, if there were changes.\n          this.pushSnapshot(timestamp_1.Timestamp.fromProto(change.readTime), change.resumeToken);\n        }\n      } else if (change.targetChangeType === 'ADD') {\n        if (WATCH_TARGET_ID !== change.targetIds[0]) {\n          this.closeStream(Error('Unexpected target ID sent by server'));\n        }\n      } else if (change.targetChangeType === 'REMOVE') {\n        let code = google_gax_1.Status.INTERNAL;\n        let message = 'internal error';\n\n        if (change.cause) {\n          code = change.cause.code;\n          message = change.cause.message;\n        } // @todo: Surface a .code property on the exception.\n\n\n        this.closeStream(new Error('Error ' + code + ': ' + message));\n      } else if (change.targetChangeType === 'RESET') {\n        // Whatever changes have happened so far no longer matter.\n        this.resetDocs();\n      } else if (change.targetChangeType === 'CURRENT') {\n        this.current = true;\n      } else {\n        this.closeStream(new Error('Unknown target change type: ' + JSON.stringify(change)));\n      }\n\n      if (change.resumeToken && this.affectsTarget(change.targetIds, WATCH_TARGET_ID)) {\n        this.backoff.reset();\n      }\n    } else if (proto.documentChange) {\n      logger_1.logger('Watch.onData', this.requestTag, 'Processing change event'); // No other targetIds can show up here, but we still need to see\n      // if the targetId was in the added list or removed list.\n\n      const targetIds = proto.documentChange.targetIds || [];\n      const removedTargetIds = proto.documentChange.removedTargetIds || [];\n      let changed = false;\n      let removed = false;\n\n      for (let i = 0; i < targetIds.length; i++) {\n        if (targetIds[i] === WATCH_TARGET_ID) {\n          changed = true;\n        }\n      }\n\n      for (let i = 0; i < removedTargetIds.length; i++) {\n        if (removedTargetIds[i] === WATCH_TARGET_ID) {\n          removed = true;\n        }\n      }\n\n      const document = proto.documentChange.document;\n      const name = document.name;\n      const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name).relativeName;\n\n      if (changed) {\n        logger_1.logger('Watch.onData', this.requestTag, 'Received document change');\n        const ref = this.firestore.doc(relativeName);\n        const snapshot = new document_1.DocumentSnapshotBuilder(ref.withConverter(this._converter));\n        snapshot.fieldsProto = document.fields || {};\n        snapshot.createTime = timestamp_1.Timestamp.fromProto(document.createTime);\n        snapshot.updateTime = timestamp_1.Timestamp.fromProto(document.updateTime);\n        this.changeMap.set(relativeName, snapshot);\n      } else if (removed) {\n        logger_1.logger('Watch.onData', this.requestTag, 'Received document remove');\n        this.changeMap.set(relativeName, REMOVED);\n      }\n    } else if (proto.documentDelete || proto.documentRemove) {\n      logger_1.logger('Watch.onData', this.requestTag, 'Processing remove event');\n      const name = (proto.documentDelete || proto.documentRemove).document;\n      const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name).relativeName;\n      this.changeMap.set(relativeName, REMOVED);\n    } else if (proto.filter) {\n      logger_1.logger('Watch.onData', this.requestTag, 'Processing filter update');\n\n      if (proto.filter.count !== this.currentSize()) {\n        // We need to remove all the current results.\n        this.resetDocs(); // The filter didn't match, so re-issue the query.\n\n        this.resetStream();\n      }\n    } else {\n      this.closeStream(new Error('Unknown listen response type: ' + JSON.stringify(proto)));\n    }\n  }\n  /**\n   * Checks if the current target id is included in the list of target ids.\n   * If no targetIds are provided, returns true.\n   * @private\n   */\n\n\n  affectsTarget(targetIds, currentId) {\n    if (targetIds === undefined || targetIds.length === 0) {\n      return true;\n    }\n\n    for (const targetId of targetIds) {\n      if (targetId === currentId) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Assembles a new snapshot from the current set of changes and invokes the\n   * user's callback. Clears the current changes on completion.\n   * @private\n   */\n\n\n  pushSnapshot(readTime, nextResumeToken) {\n    const appliedChanges = this.computeSnapshot(readTime);\n\n    if (!this.hasPushed || appliedChanges.length > 0) {\n      logger_1.logger('Watch.pushSnapshot', this.requestTag, 'Sending snapshot with %d changes and %d documents', String(appliedChanges.length), this.docTree.length); // We pass the current set of changes, even if `docTree` is modified later.\n\n      const currentTree = this.docTree;\n      this.onNext(readTime, currentTree.length, () => currentTree.keys, () => appliedChanges);\n      this.hasPushed = true;\n    }\n\n    this.changeMap.clear();\n    this.resumeToken = nextResumeToken;\n  }\n  /**\n   * Applies a document delete to the document tree and the document map.\n   * Returns the corresponding DocumentChange event.\n   * @private\n   */\n\n\n  deleteDoc(name) {\n    assert(this.docMap.has(name), 'Document to delete does not exist');\n    const oldDocument = this.docMap.get(name);\n    const existing = this.docTree.find(oldDocument);\n    const oldIndex = existing.index;\n    this.docTree = existing.remove();\n    this.docMap.delete(name);\n    return new document_change_1.DocumentChange(ChangeType.removed, oldDocument, oldIndex, -1);\n  }\n  /**\n   * Applies a document add to the document tree and the document map. Returns\n   * the corresponding DocumentChange event.\n   * @private\n   */\n\n\n  addDoc(newDocument) {\n    const name = newDocument.ref.path;\n    assert(!this.docMap.has(name), 'Document to add already exists');\n    this.docTree = this.docTree.insert(newDocument, null);\n    const newIndex = this.docTree.find(newDocument).index;\n    this.docMap.set(name, newDocument);\n    return new document_change_1.DocumentChange(ChangeType.added, newDocument, -1, newIndex);\n  }\n  /**\n   * Applies a document modification to the document tree and the document map.\n   * Returns the DocumentChange event for successful modifications.\n   * @private\n   */\n\n\n  modifyDoc(newDocument) {\n    const name = newDocument.ref.path;\n    assert(this.docMap.has(name), 'Document to modify does not exist');\n    const oldDocument = this.docMap.get(name);\n\n    if (!oldDocument.updateTime.isEqual(newDocument.updateTime)) {\n      const removeChange = this.deleteDoc(name);\n      const addChange = this.addDoc(newDocument);\n      return new document_change_1.DocumentChange(ChangeType.modified, newDocument, removeChange.oldIndex, addChange.newIndex);\n    }\n\n    return null;\n  }\n  /**\n   * Applies the mutations in changeMap to both the document tree and the\n   * document lookup map. Modified docMap in-place and returns the updated\n   * state.\n   * @private\n   */\n\n\n  computeSnapshot(readTime) {\n    const changeSet = this.extractCurrentChanges(readTime);\n    const appliedChanges = []; // Process the sorted changes in the order that is expected by our clients\n    // (removals, additions, and then modifications). We also need to sort the\n    // individual changes to assure that oldIndex/newIndex keep incrementing.\n\n    changeSet.deletes.sort((name1, name2) => {\n      // Deletes are sorted based on the order of the existing document.\n      return this.getComparator()(this.docMap.get(name1), this.docMap.get(name2));\n    });\n    changeSet.deletes.forEach(name => {\n      const change = this.deleteDoc(name);\n      appliedChanges.push(change);\n    });\n    changeSet.adds.sort(this.getComparator());\n    changeSet.adds.forEach(snapshot => {\n      const change = this.addDoc(snapshot);\n      appliedChanges.push(change);\n    });\n    changeSet.updates.sort(this.getComparator());\n    changeSet.updates.forEach(snapshot => {\n      const change = this.modifyDoc(snapshot);\n\n      if (change) {\n        appliedChanges.push(change);\n      }\n    });\n    assert(this.docTree.length === this.docMap.size, 'The update document ' + 'tree and document map should have the same number of entries.');\n    return appliedChanges;\n  }\n  /**\n   * Determines whether a watch error is considered permanent and should not be\n   * retried. Errors that don't provide a GRPC error code are always considered\n   * transient in this context.\n   *\n   * @private\n   * @param error An error object.\n   * @return Whether the error is permanent.\n   */\n\n\n  isPermanentWatchError(error) {\n    if (error.code === undefined) {\n      logger_1.logger('Watch.isPermanentError', this.requestTag, 'Unable to determine error code: ', error);\n      return false;\n    }\n\n    switch (error.code) {\n      case google_gax_1.Status.ABORTED:\n      case google_gax_1.Status.CANCELLED:\n      case google_gax_1.Status.UNKNOWN:\n      case google_gax_1.Status.DEADLINE_EXCEEDED:\n      case google_gax_1.Status.RESOURCE_EXHAUSTED:\n      case google_gax_1.Status.INTERNAL:\n      case google_gax_1.Status.UNAVAILABLE:\n      case google_gax_1.Status.UNAUTHENTICATED:\n        return false;\n\n      default:\n        return true;\n    }\n  }\n  /**\n   * Determines whether we need to initiate a longer backoff due to system\n   * overload.\n   *\n   * @private\n   * @param error A GRPC Error object that exposes an error code.\n   * @return Whether we need to back off our retries.\n   */\n\n\n  isResourceExhaustedError(error) {\n    return error.code === google_gax_1.Status.RESOURCE_EXHAUSTED;\n  }\n  /** Closes the stream and clears all timeouts. */\n\n\n  shutdown() {\n    var _a;\n\n    if (this.isActive) {\n      this.isActive = false;\n\n      if (this.idleTimeoutHandle) {\n        clearTimeout(this.idleTimeoutHandle);\n        this.idleTimeoutHandle = undefined;\n      }\n\n      this.firestore.unregisterListener();\n    }\n\n    (_a = this.currentStream) === null || _a === void 0 ? void 0 : _a.end();\n    this.currentStream = null;\n  }\n\n}\n/**\n * Creates a new Watch instance to listen on DocumentReferences.\n *\n * @private\n */\n\n\nclass DocumentWatch extends Watch {\n  constructor(firestore, ref) {\n    super(firestore, ref._converter);\n    this.ref = ref;\n  }\n\n  getComparator() {\n    return DOCUMENT_WATCH_COMPARATOR;\n  }\n\n  getTarget(resumeToken) {\n    const formattedName = this.ref.formattedName;\n    return {\n      documents: {\n        documents: [formattedName]\n      },\n      targetId: WATCH_TARGET_ID,\n      resumeToken\n    };\n  }\n\n}\n\nexports.DocumentWatch = DocumentWatch;\n/**\n * Creates a new Watch instance to listen on Queries.\n *\n * @private\n */\n\nclass QueryWatch extends Watch {\n  constructor(firestore, query, converter) {\n    super(firestore, converter);\n    this.query = query;\n    this.comparator = query.comparator();\n  }\n\n  getComparator() {\n    return this.query.comparator();\n  }\n\n  getTarget(resumeToken) {\n    const query = this.query.toProto();\n    return {\n      query,\n      targetId: WATCH_TARGET_ID,\n      resumeToken\n    };\n  }\n\n}\n\nexports.QueryWatch = QueryWatch;","map":{"version":3,"sources":["/Users/piyushmaheshwari/Downloads/github/Bridgeorg/node_modules/@google-cloud/firestore/build/src/watch.js"],"names":["Object","defineProperty","exports","value","assert","require","rbtree","google_gax_1","backoff_1","document_1","document_change_1","logger_1","path_1","timestamp_1","types_1","util_1","WATCH_TARGET_ID","WATCH_IDLE_TIMEOUT_MS","REMOVED","ChangeType","added","modified","removed","DOCUMENT_WATCH_COMPARATOR","doc1","doc2","EMPTY_FUNCTION","Watch","constructor","firestore","_converter","defaultConverter","isActive","currentStream","resumeToken","undefined","docMap","Map","changeMap","current","hasPushed","backoff","ExponentialBackoff","requestTag","onNext","onError","onSnapshot","docTree","getComparator","initStream","unsubscribe","logger","shutdown","registerListener","currentSize","changes","extractCurrentChanges","Timestamp","now","size","adds","length","deletes","readTime","updates","forEach","name","has","push","build","resetDocs","clear","snapshot","set","ref","path","closeStream","err","maybeReopenStream","isPermanentWatchError","isResourceExhaustedError","resetToMax","resetIdleTimeout","idleTimeoutHandle","clearTimeout","delayExecution","_a","end","error","GoogleError","code","Status","UNKNOWN","resetStream","backoffAndWait","then","initializeIfNeeded","request","database","formattedName","addTarget","getTarget","requestStream","backendStream","emit","on","proto","onData","resume","catch","targetChange","change","noTargetIds","targetIds","targetChangeType","pushSnapshot","fromProto","Error","INTERNAL","message","cause","JSON","stringify","affectsTarget","reset","documentChange","removedTargetIds","changed","i","document","relativeName","QualifiedResourcePath","fromSlashSeparatedString","doc","DocumentSnapshotBuilder","withConverter","fieldsProto","fields","createTime","updateTime","documentDelete","documentRemove","filter","count","currentId","targetId","nextResumeToken","appliedChanges","computeSnapshot","String","currentTree","keys","deleteDoc","oldDocument","get","existing","find","oldIndex","index","remove","delete","DocumentChange","addDoc","newDocument","insert","newIndex","modifyDoc","isEqual","removeChange","addChange","changeSet","sort","name1","name2","ABORTED","CANCELLED","DEADLINE_EXCEEDED","RESOURCE_EXHAUSTED","UNAVAILABLE","UNAUTHENTICATED","unregisterListener","DocumentWatch","documents","QueryWatch","query","converter","comparator","toProto"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nconst rbtree = require(\"functional-red-black-tree\");\nconst google_gax_1 = require(\"google-gax\");\nconst backoff_1 = require(\"./backoff\");\nconst document_1 = require(\"./document\");\nconst document_change_1 = require(\"./document-change\");\nconst logger_1 = require(\"./logger\");\nconst path_1 = require(\"./path\");\nconst timestamp_1 = require(\"./timestamp\");\nconst types_1 = require(\"./types\");\nconst util_1 = require(\"./util\");\n/*!\n * Target ID used by watch. Watch uses a fixed target id since we only support\n * one target per stream.\n * @type {number}\n */\nconst WATCH_TARGET_ID = 0x1;\n/*!\n * Idle timeout used to detect Watch streams that stall (see\n * https://github.com/googleapis/nodejs-firestore/issues/1057, b/156308554).\n * Under normal load, the Watch backend will send a TARGET_CHANGE message\n * roughly every 30 seconds. As discussed with the backend team, we reset the\n * Watch stream if we do not receive any message within 120 seconds.\n */\nexports.WATCH_IDLE_TIMEOUT_MS = 120 * 1000;\n/*!\n * Sentinel value for a document remove.\n */\nconst REMOVED = {};\n/*!\n * The change type for document change events.\n */\n// tslint:disable-next-line:variable-name\nconst ChangeType = {\n    added: 'added',\n    modified: 'modified',\n    removed: 'removed',\n};\n/*!\n * The comparator used for document watches (which should always get called with\n * the same document).\n */\nconst DOCUMENT_WATCH_COMPARATOR = (doc1, doc2) => {\n    assert(doc1 === doc2, 'Document watches only support one document.');\n    return 0;\n};\nconst EMPTY_FUNCTION = () => { };\n/**\n * Watch provides listen functionality and exposes the 'onSnapshot' observer. It\n * can be used with a valid Firestore Listen target.\n *\n * @class\n * @private\n */\nclass Watch {\n    /**\n     * @private\n     * @hideconstructor\n     *\n     * @param firestore The Firestore Database client.\n     */\n    constructor(firestore, _converter = types_1.defaultConverter()) {\n        this._converter = _converter;\n        /**\n         * Indicates whether we are interested in data from the stream. Set to false in the\n         * 'unsubscribe()' callback.\n         * @private\n         */\n        this.isActive = true;\n        /**\n         * The current stream to the backend.\n         * @private\n         */\n        this.currentStream = null;\n        /**\n         * The server assigns and updates the resume token.\n         * @private\n         */\n        this.resumeToken = undefined;\n        /**\n         * A map of document names to QueryDocumentSnapshots for the last sent snapshot.\n         * @private\n         */\n        this.docMap = new Map();\n        /**\n         * The accumulated map of document changes (keyed by document name) for the\n         * current snapshot.\n         * @private\n         */\n        this.changeMap = new Map();\n        /**\n         * The current state of the query results. *\n         * @private\n         */\n        this.current = false;\n        /**\n         * We need this to track whether we've pushed an initial set of changes,\n         * since we should push those even when there are no changes, if there\n         * aren't docs.\n         * @private\n         */\n        this.hasPushed = false;\n        this.firestore = firestore;\n        this.backoff = new backoff_1.ExponentialBackoff();\n        this.requestTag = util_1.requestTag();\n        this.onNext = EMPTY_FUNCTION;\n        this.onError = EMPTY_FUNCTION;\n    }\n    /**\n     * Starts a watch and attaches a listener for document change events.\n     *\n     * @private\n     * @param onNext A callback to be called every time a new snapshot is\n     * available.\n     * @param onError A callback to be called if the listen fails or is cancelled.\n     * No further callbacks will occur.\n     *\n     * @returns An unsubscribe function that can be called to cancel the snapshot\n     * listener.\n     */\n    onSnapshot(onNext, onError) {\n        assert(this.onNext === EMPTY_FUNCTION, 'onNext should not already be defined.');\n        assert(this.onError === EMPTY_FUNCTION, 'onError should not already be defined.');\n        assert(this.docTree === undefined, 'docTree should not already be defined.');\n        this.onNext = onNext;\n        this.onError = onError;\n        this.docTree = rbtree(this.getComparator());\n        this.initStream();\n        const unsubscribe = () => {\n            logger_1.logger('Watch.onSnapshot', this.requestTag, 'Unsubscribe called');\n            // Prevent further callbacks.\n            this.onNext = () => { };\n            this.onError = () => { };\n            this.shutdown();\n        };\n        this.firestore.registerListener();\n        return unsubscribe;\n    }\n    /**\n     * Returns the current count of all documents, including the changes from\n     * the current changeMap.\n     * @private\n     */\n    currentSize() {\n        const changes = this.extractCurrentChanges(timestamp_1.Timestamp.now());\n        return this.docMap.size + changes.adds.length - changes.deletes.length;\n    }\n    /**\n     * Splits up document changes into removals, additions, and updates.\n     * @private\n     */\n    extractCurrentChanges(readTime) {\n        const deletes = [];\n        const adds = [];\n        const updates = [];\n        this.changeMap.forEach((value, name) => {\n            if (value === REMOVED) {\n                if (this.docMap.has(name)) {\n                    deletes.push(name);\n                }\n            }\n            else if (this.docMap.has(name)) {\n                value.readTime = readTime;\n                updates.push(value.build());\n            }\n            else {\n                value.readTime = readTime;\n                adds.push(value.build());\n            }\n        });\n        return { deletes, adds, updates };\n    }\n    /**\n     * Helper to clear the docs on RESET or filter mismatch.\n     * @private\n     */\n    resetDocs() {\n        logger_1.logger('Watch.resetDocs', this.requestTag, 'Resetting documents');\n        this.changeMap.clear();\n        this.resumeToken = undefined;\n        this.docTree.forEach((snapshot) => {\n            // Mark each document as deleted. If documents are not deleted, they\n            // will be send again by the server.\n            this.changeMap.set(snapshot.ref.path, REMOVED);\n        });\n        this.current = false;\n    }\n    /**\n     * Closes the stream and calls onError() if the stream is still active.\n     * @private\n     */\n    closeStream(err) {\n        if (this.isActive) {\n            logger_1.logger('Watch.closeStream', this.requestTag, 'Invoking onError: ', err);\n            this.onError(err);\n        }\n        this.shutdown();\n    }\n    /**\n     * Re-opens the stream unless the specified error is considered permanent.\n     * Clears the change map.\n     * @private\n     */\n    maybeReopenStream(err) {\n        if (this.isActive && !this.isPermanentWatchError(err)) {\n            logger_1.logger('Watch.maybeReopenStream', this.requestTag, 'Stream ended, re-opening after retryable error:', err);\n            this.changeMap.clear();\n            if (this.isResourceExhaustedError(err)) {\n                this.backoff.resetToMax();\n            }\n            this.initStream();\n        }\n        else {\n            this.closeStream(err);\n        }\n    }\n    /**\n     * Cancels the current idle timeout and reschedules a new timer.\n     *\n     * @private\n     */\n    resetIdleTimeout() {\n        if (this.idleTimeoutHandle) {\n            clearTimeout(this.idleTimeoutHandle);\n        }\n        this.idleTimeoutHandle = backoff_1.delayExecution(() => {\n            var _a;\n            logger_1.logger('Watch.resetIdleTimeout', this.requestTag, 'Resetting stream after idle timeout');\n            (_a = this.currentStream) === null || _a === void 0 ? void 0 : _a.end();\n            this.currentStream = null;\n            const error = new google_gax_1.GoogleError('Watch stream idle timeout');\n            error.code = google_gax_1.Status.UNKNOWN;\n            this.maybeReopenStream(error);\n        }, exports.WATCH_IDLE_TIMEOUT_MS);\n    }\n    /**\n     * Helper to restart the outgoing stream to the backend.\n     * @private\n     */\n    resetStream() {\n        logger_1.logger('Watch.resetStream', this.requestTag, 'Restarting stream');\n        if (this.currentStream) {\n            this.currentStream.end();\n            this.currentStream = null;\n        }\n        this.initStream();\n    }\n    /**\n     * Initializes a new stream to the backend with backoff.\n     * @private\n     */\n    initStream() {\n        this.backoff\n            .backoffAndWait()\n            .then(async () => {\n            if (!this.isActive) {\n                logger_1.logger('Watch.initStream', this.requestTag, 'Not initializing inactive stream');\n                return;\n            }\n            await this.firestore.initializeIfNeeded(this.requestTag);\n            const request = {};\n            request.database = this.firestore.formattedName;\n            request.addTarget = this.getTarget(this.resumeToken);\n            // Note that we need to call the internal _listen API to pass additional\n            // header values in readWriteStream.\n            return this.firestore\n                .requestStream('listen', request, this.requestTag)\n                .then(backendStream => {\n                if (!this.isActive) {\n                    logger_1.logger('Watch.initStream', this.requestTag, 'Closing inactive stream');\n                    backendStream.emit('end');\n                    return;\n                }\n                logger_1.logger('Watch.initStream', this.requestTag, 'Opened new stream');\n                this.currentStream = backendStream;\n                this.resetIdleTimeout();\n                this.currentStream.on('data', (proto) => {\n                    this.resetIdleTimeout();\n                    this.onData(proto);\n                })\n                    .on('error', err => {\n                    if (this.currentStream === backendStream) {\n                        this.currentStream = null;\n                        this.maybeReopenStream(err);\n                    }\n                })\n                    .on('end', () => {\n                    if (this.currentStream === backendStream) {\n                        this.currentStream = null;\n                        const err = new google_gax_1.GoogleError('Stream ended unexpectedly');\n                        err.code = google_gax_1.Status.UNKNOWN;\n                        this.maybeReopenStream(err);\n                    }\n                });\n                this.currentStream.resume();\n            });\n        })\n            .catch(err => {\n            this.closeStream(err);\n        });\n    }\n    /**\n     * Handles 'data' events and closes the stream if the response type is\n     * invalid.\n     * @private\n     */\n    onData(proto) {\n        if (proto.targetChange) {\n            logger_1.logger('Watch.onData', this.requestTag, 'Processing target change');\n            const change = proto.targetChange;\n            const noTargetIds = !change.targetIds || change.targetIds.length === 0;\n            if (change.targetChangeType === 'NO_CHANGE') {\n                if (noTargetIds && change.readTime && this.current) {\n                    // This means everything is up-to-date, so emit the current\n                    // set of docs as a snapshot, if there were changes.\n                    this.pushSnapshot(timestamp_1.Timestamp.fromProto(change.readTime), change.resumeToken);\n                }\n            }\n            else if (change.targetChangeType === 'ADD') {\n                if (WATCH_TARGET_ID !== change.targetIds[0]) {\n                    this.closeStream(Error('Unexpected target ID sent by server'));\n                }\n            }\n            else if (change.targetChangeType === 'REMOVE') {\n                let code = google_gax_1.Status.INTERNAL;\n                let message = 'internal error';\n                if (change.cause) {\n                    code = change.cause.code;\n                    message = change.cause.message;\n                }\n                // @todo: Surface a .code property on the exception.\n                this.closeStream(new Error('Error ' + code + ': ' + message));\n            }\n            else if (change.targetChangeType === 'RESET') {\n                // Whatever changes have happened so far no longer matter.\n                this.resetDocs();\n            }\n            else if (change.targetChangeType === 'CURRENT') {\n                this.current = true;\n            }\n            else {\n                this.closeStream(new Error('Unknown target change type: ' + JSON.stringify(change)));\n            }\n            if (change.resumeToken &&\n                this.affectsTarget(change.targetIds, WATCH_TARGET_ID)) {\n                this.backoff.reset();\n            }\n        }\n        else if (proto.documentChange) {\n            logger_1.logger('Watch.onData', this.requestTag, 'Processing change event');\n            // No other targetIds can show up here, but we still need to see\n            // if the targetId was in the added list or removed list.\n            const targetIds = proto.documentChange.targetIds || [];\n            const removedTargetIds = proto.documentChange.removedTargetIds || [];\n            let changed = false;\n            let removed = false;\n            for (let i = 0; i < targetIds.length; i++) {\n                if (targetIds[i] === WATCH_TARGET_ID) {\n                    changed = true;\n                }\n            }\n            for (let i = 0; i < removedTargetIds.length; i++) {\n                if (removedTargetIds[i] === WATCH_TARGET_ID) {\n                    removed = true;\n                }\n            }\n            const document = proto.documentChange.document;\n            const name = document.name;\n            const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name)\n                .relativeName;\n            if (changed) {\n                logger_1.logger('Watch.onData', this.requestTag, 'Received document change');\n                const ref = this.firestore.doc(relativeName);\n                const snapshot = new document_1.DocumentSnapshotBuilder(ref.withConverter(this._converter));\n                snapshot.fieldsProto = document.fields || {};\n                snapshot.createTime = timestamp_1.Timestamp.fromProto(document.createTime);\n                snapshot.updateTime = timestamp_1.Timestamp.fromProto(document.updateTime);\n                this.changeMap.set(relativeName, snapshot);\n            }\n            else if (removed) {\n                logger_1.logger('Watch.onData', this.requestTag, 'Received document remove');\n                this.changeMap.set(relativeName, REMOVED);\n            }\n        }\n        else if (proto.documentDelete || proto.documentRemove) {\n            logger_1.logger('Watch.onData', this.requestTag, 'Processing remove event');\n            const name = (proto.documentDelete || proto.documentRemove).document;\n            const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name)\n                .relativeName;\n            this.changeMap.set(relativeName, REMOVED);\n        }\n        else if (proto.filter) {\n            logger_1.logger('Watch.onData', this.requestTag, 'Processing filter update');\n            if (proto.filter.count !== this.currentSize()) {\n                // We need to remove all the current results.\n                this.resetDocs();\n                // The filter didn't match, so re-issue the query.\n                this.resetStream();\n            }\n        }\n        else {\n            this.closeStream(new Error('Unknown listen response type: ' + JSON.stringify(proto)));\n        }\n    }\n    /**\n     * Checks if the current target id is included in the list of target ids.\n     * If no targetIds are provided, returns true.\n     * @private\n     */\n    affectsTarget(targetIds, currentId) {\n        if (targetIds === undefined || targetIds.length === 0) {\n            return true;\n        }\n        for (const targetId of targetIds) {\n            if (targetId === currentId) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Assembles a new snapshot from the current set of changes and invokes the\n     * user's callback. Clears the current changes on completion.\n     * @private\n     */\n    pushSnapshot(readTime, nextResumeToken) {\n        const appliedChanges = this.computeSnapshot(readTime);\n        if (!this.hasPushed || appliedChanges.length > 0) {\n            logger_1.logger('Watch.pushSnapshot', this.requestTag, 'Sending snapshot with %d changes and %d documents', String(appliedChanges.length), this.docTree.length);\n            // We pass the current set of changes, even if `docTree` is modified later.\n            const currentTree = this.docTree;\n            this.onNext(readTime, currentTree.length, () => currentTree.keys, () => appliedChanges);\n            this.hasPushed = true;\n        }\n        this.changeMap.clear();\n        this.resumeToken = nextResumeToken;\n    }\n    /**\n     * Applies a document delete to the document tree and the document map.\n     * Returns the corresponding DocumentChange event.\n     * @private\n     */\n    deleteDoc(name) {\n        assert(this.docMap.has(name), 'Document to delete does not exist');\n        const oldDocument = this.docMap.get(name);\n        const existing = this.docTree.find(oldDocument);\n        const oldIndex = existing.index;\n        this.docTree = existing.remove();\n        this.docMap.delete(name);\n        return new document_change_1.DocumentChange(ChangeType.removed, oldDocument, oldIndex, -1);\n    }\n    /**\n     * Applies a document add to the document tree and the document map. Returns\n     * the corresponding DocumentChange event.\n     * @private\n     */\n    addDoc(newDocument) {\n        const name = newDocument.ref.path;\n        assert(!this.docMap.has(name), 'Document to add already exists');\n        this.docTree = this.docTree.insert(newDocument, null);\n        const newIndex = this.docTree.find(newDocument).index;\n        this.docMap.set(name, newDocument);\n        return new document_change_1.DocumentChange(ChangeType.added, newDocument, -1, newIndex);\n    }\n    /**\n     * Applies a document modification to the document tree and the document map.\n     * Returns the DocumentChange event for successful modifications.\n     * @private\n     */\n    modifyDoc(newDocument) {\n        const name = newDocument.ref.path;\n        assert(this.docMap.has(name), 'Document to modify does not exist');\n        const oldDocument = this.docMap.get(name);\n        if (!oldDocument.updateTime.isEqual(newDocument.updateTime)) {\n            const removeChange = this.deleteDoc(name);\n            const addChange = this.addDoc(newDocument);\n            return new document_change_1.DocumentChange(ChangeType.modified, newDocument, removeChange.oldIndex, addChange.newIndex);\n        }\n        return null;\n    }\n    /**\n     * Applies the mutations in changeMap to both the document tree and the\n     * document lookup map. Modified docMap in-place and returns the updated\n     * state.\n     * @private\n     */\n    computeSnapshot(readTime) {\n        const changeSet = this.extractCurrentChanges(readTime);\n        const appliedChanges = [];\n        // Process the sorted changes in the order that is expected by our clients\n        // (removals, additions, and then modifications). We also need to sort the\n        // individual changes to assure that oldIndex/newIndex keep incrementing.\n        changeSet.deletes.sort((name1, name2) => {\n            // Deletes are sorted based on the order of the existing document.\n            return this.getComparator()(this.docMap.get(name1), this.docMap.get(name2));\n        });\n        changeSet.deletes.forEach(name => {\n            const change = this.deleteDoc(name);\n            appliedChanges.push(change);\n        });\n        changeSet.adds.sort(this.getComparator());\n        changeSet.adds.forEach(snapshot => {\n            const change = this.addDoc(snapshot);\n            appliedChanges.push(change);\n        });\n        changeSet.updates.sort(this.getComparator());\n        changeSet.updates.forEach(snapshot => {\n            const change = this.modifyDoc(snapshot);\n            if (change) {\n                appliedChanges.push(change);\n            }\n        });\n        assert(this.docTree.length === this.docMap.size, 'The update document ' +\n            'tree and document map should have the same number of entries.');\n        return appliedChanges;\n    }\n    /**\n     * Determines whether a watch error is considered permanent and should not be\n     * retried. Errors that don't provide a GRPC error code are always considered\n     * transient in this context.\n     *\n     * @private\n     * @param error An error object.\n     * @return Whether the error is permanent.\n     */\n    isPermanentWatchError(error) {\n        if (error.code === undefined) {\n            logger_1.logger('Watch.isPermanentError', this.requestTag, 'Unable to determine error code: ', error);\n            return false;\n        }\n        switch (error.code) {\n            case google_gax_1.Status.ABORTED:\n            case google_gax_1.Status.CANCELLED:\n            case google_gax_1.Status.UNKNOWN:\n            case google_gax_1.Status.DEADLINE_EXCEEDED:\n            case google_gax_1.Status.RESOURCE_EXHAUSTED:\n            case google_gax_1.Status.INTERNAL:\n            case google_gax_1.Status.UNAVAILABLE:\n            case google_gax_1.Status.UNAUTHENTICATED:\n                return false;\n            default:\n                return true;\n        }\n    }\n    /**\n     * Determines whether we need to initiate a longer backoff due to system\n     * overload.\n     *\n     * @private\n     * @param error A GRPC Error object that exposes an error code.\n     * @return Whether we need to back off our retries.\n     */\n    isResourceExhaustedError(error) {\n        return error.code === google_gax_1.Status.RESOURCE_EXHAUSTED;\n    }\n    /** Closes the stream and clears all timeouts. */\n    shutdown() {\n        var _a;\n        if (this.isActive) {\n            this.isActive = false;\n            if (this.idleTimeoutHandle) {\n                clearTimeout(this.idleTimeoutHandle);\n                this.idleTimeoutHandle = undefined;\n            }\n            this.firestore.unregisterListener();\n        }\n        (_a = this.currentStream) === null || _a === void 0 ? void 0 : _a.end();\n        this.currentStream = null;\n    }\n}\n/**\n * Creates a new Watch instance to listen on DocumentReferences.\n *\n * @private\n */\nclass DocumentWatch extends Watch {\n    constructor(firestore, ref) {\n        super(firestore, ref._converter);\n        this.ref = ref;\n    }\n    getComparator() {\n        return DOCUMENT_WATCH_COMPARATOR;\n    }\n    getTarget(resumeToken) {\n        const formattedName = this.ref.formattedName;\n        return {\n            documents: {\n                documents: [formattedName],\n            },\n            targetId: WATCH_TARGET_ID,\n            resumeToken,\n        };\n    }\n}\nexports.DocumentWatch = DocumentWatch;\n/**\n * Creates a new Watch instance to listen on Queries.\n *\n * @private\n */\nclass QueryWatch extends Watch {\n    constructor(firestore, query, converter) {\n        super(firestore, converter);\n        this.query = query;\n        this.comparator = query.comparator();\n    }\n    getComparator() {\n        return this.query.comparator();\n    }\n    getTarget(resumeToken) {\n        const query = this.query.toProto();\n        return { query, targetId: WATCH_TARGET_ID, resumeToken };\n    }\n}\nexports.QueryWatch = QueryWatch;\n//# sourceMappingURL=watch.js.map"]},"metadata":{},"sourceType":"script"}