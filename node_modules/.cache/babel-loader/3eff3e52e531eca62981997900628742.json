{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transcode = exports.requestChangeCase = exports.flattenObject = exports.match = exports.applyPattern = exports.encodeWithoutSlashes = exports.encodeWithSlashes = exports.buildQueryStringComponents = exports.deleteField = exports.deepCopy = exports.getField = void 0;\n\nconst util_1 = require(\"./util\");\n\nconst httpOptionName = '(google.api.http)'; // List of methods as defined in google/api/http.proto (see HttpRule)\n\nconst supportedHttpMethods = ['get', 'post', 'put', 'patch', 'delete'];\n\nfunction getField(request, field) {\n  const parts = field.split('.');\n  let value = request;\n\n  for (const part of parts) {\n    if (typeof value !== 'object') {\n      return undefined;\n    }\n\n    value = value[part];\n  }\n\n  if (typeof value === 'object' && !Array.isArray(value) && value !== null) {\n    return undefined;\n  }\n\n  return value;\n}\n\nexports.getField = getField;\n\nfunction deepCopy(request) {\n  if (typeof request !== 'object' || request === null) {\n    return request;\n  }\n\n  const copy = Object.assign({}, request);\n\n  for (const key in copy) {\n    if (Array.isArray(copy[key])) {\n      copy[key] = copy[key].map(deepCopy);\n    } else if (typeof copy[key] === 'object' && copy[key] !== null) {\n      copy[key] = deepCopy(copy[key]);\n    }\n  }\n\n  return copy;\n}\n\nexports.deepCopy = deepCopy;\n\nfunction deleteField(request, field) {\n  const parts = field.split('.');\n\n  while (parts.length > 1) {\n    if (typeof request !== 'object') {\n      return;\n    }\n\n    const part = parts.shift();\n    request = request[part];\n  }\n\n  const part = parts.shift();\n\n  if (typeof request !== 'object') {\n    return;\n  }\n\n  delete request[part];\n}\n\nexports.deleteField = deleteField;\n\nfunction buildQueryStringComponents(request, prefix = '') {\n  const resultList = [];\n\n  for (const key in request) {\n    if (Array.isArray(request[key])) {\n      for (const value of request[key]) {\n        resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(value.toString())}`);\n      }\n    } else if (typeof request[key] === 'object' && request[key] !== null) {\n      resultList.push(...buildQueryStringComponents(request[key], `${key}.`));\n    } else {\n      resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(request[key].toString())}`);\n    }\n  }\n\n  return resultList;\n}\n\nexports.buildQueryStringComponents = buildQueryStringComponents;\n\nfunction encodeWithSlashes(str) {\n  return str.split('').map(c => c.match(/[-_.~0-9a-zA-Z]/) ? c : encodeURIComponent(c)).join('');\n}\n\nexports.encodeWithSlashes = encodeWithSlashes;\n\nfunction encodeWithoutSlashes(str) {\n  return str.split('').map(c => c.match(/[-_.~0-9a-zA-Z/]/) ? c : encodeURIComponent(c)).join('');\n}\n\nexports.encodeWithoutSlashes = encodeWithoutSlashes;\n\nfunction escapeRegExp(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction applyPattern(pattern, fieldValue) {\n  if (!pattern || pattern === '*') {\n    return encodeWithSlashes(fieldValue);\n  }\n\n  if (!pattern.includes('*') && pattern !== fieldValue) {\n    return undefined;\n  } // since we're converting the pattern to a regex, make necessary precautions:\n\n\n  const regex = new RegExp('^' + escapeRegExp(pattern).replace(/\\\\\\*\\\\\\*/g, '(.+)').replace(/\\\\\\*/g, '([^/]+)') + '$');\n\n  if (!fieldValue.match(regex)) {\n    return undefined;\n  }\n\n  return encodeWithoutSlashes(fieldValue);\n}\n\nexports.applyPattern = applyPattern;\n\nfunction match(request, pattern) {\n  let url = pattern;\n  const matchedFields = [];\n\n  for (;;) {\n    const match = url.match(/^(.*)\\{([^}=]+)(?:=([^}]*))?\\}(.*)/);\n\n    if (!match) {\n      break;\n    }\n\n    const [, before, field, pattern, after] = match;\n    matchedFields.push(field);\n    const fieldValue = getField(request, field);\n\n    if (typeof fieldValue === 'undefined') {\n      return undefined;\n    }\n\n    const appliedPattern = applyPattern(pattern, fieldValue.toString());\n\n    if (typeof appliedPattern === 'undefined') {\n      return undefined;\n    }\n\n    url = before + appliedPattern + after;\n  }\n\n  return {\n    matchedFields,\n    url\n  };\n}\n\nexports.match = match;\n\nfunction flattenObject(request) {\n  const result = {};\n\n  for (const key in request) {\n    if (typeof request[key] === 'undefined') {\n      continue;\n    }\n\n    if (Array.isArray(request[key])) {\n      // According to the http.proto comments, a repeated field may only\n      // contain primitive types, so no extra recursion here.\n      result[key] = request[key];\n      continue;\n    }\n\n    if (typeof request[key] === 'object' && request[key] !== null) {\n      const nested = flattenObject(request[key]);\n\n      for (const nestedKey in nested) {\n        result[`${key}.${nestedKey}`] = nested[nestedKey];\n      }\n\n      continue;\n    }\n\n    result[key] = request[key];\n  }\n\n  return result;\n}\n\nexports.flattenObject = flattenObject;\n\nfunction requestChangeCase(request, caseChangeFunc) {\n  if (!request || typeof request !== 'object') {\n    return request;\n  }\n\n  const convertedRequest = {};\n\n  for (const field in request) {\n    const convertedField = caseChangeFunc(field);\n    const value = request[field];\n\n    if (Array.isArray(value)) {\n      convertedRequest[convertedField] = value.map(v => requestChangeCase(v, caseChangeFunc));\n    } else {\n      convertedRequest[convertedField] = requestChangeCase(value, caseChangeFunc);\n    }\n  }\n\n  return convertedRequest;\n}\n\nexports.requestChangeCase = requestChangeCase;\n\nfunction transcode(request, parsedOptions) {\n  // request is supposed to have keys in camelCase.\n  const snakeRequest = requestChangeCase(request, util_1.camelToSnakeCase);\n  const httpRules = [];\n\n  for (const option of parsedOptions) {\n    if (!(httpOptionName in option)) {\n      continue;\n    }\n\n    const httpRule = option[httpOptionName];\n    httpRules.push(httpRule);\n\n    if (httpRule === null || httpRule === void 0 ? void 0 : httpRule.additional_bindings) {\n      const additionalBindings = Array.isArray(httpRule.additional_bindings) ? httpRule.additional_bindings : [httpRule.additional_bindings];\n      httpRules.push(...additionalBindings);\n    }\n  }\n\n  for (const httpRule of httpRules) {\n    for (const httpMethod of supportedHttpMethods) {\n      if (!(httpMethod in httpRule)) {\n        continue;\n      }\n\n      const pathTemplate = httpRule[httpMethod];\n      const matchResult = match(snakeRequest, pathTemplate);\n\n      if (typeof matchResult === 'undefined') {\n        continue;\n      }\n\n      const {\n        url,\n        matchedFields\n      } = matchResult;\n\n      if (httpRule.body === '*') {\n        // all fields except the matched fields go to request data\n        const data = deepCopy(snakeRequest);\n\n        for (const field of matchedFields) {\n          deleteField(data, field);\n        } // HTTP endpoint expects camelCase but we have snake_case at this point\n\n\n        const camelCaseData = requestChangeCase(data, util_1.snakeToCamelCase);\n        return {\n          httpMethod,\n          url,\n          queryString: '',\n          data: camelCaseData\n        };\n      } // one field possibly goes to request data, others go to query string\n\n\n      const body = httpRule.body;\n      let data = '';\n      const queryStringObject = deepCopy(request); // use camel case for query string\n\n      if (body) {\n        deleteField(queryStringObject, util_1.snakeToCamelCase(body));\n        data = snakeRequest[body];\n      }\n\n      for (const field of matchedFields) {\n        deleteField(queryStringObject, util_1.snakeToCamelCase(field));\n      }\n\n      const queryStringComponents = buildQueryStringComponents(queryStringObject);\n      const queryString = queryStringComponents.join('&');\n      let camelCaseData;\n\n      if (typeof data === 'string') {\n        camelCaseData = data;\n      } else {\n        camelCaseData = requestChangeCase(data, util_1.snakeToCamelCase);\n      }\n\n      return {\n        httpMethod,\n        url,\n        queryString,\n        data: camelCaseData\n      };\n    }\n  }\n\n  return undefined;\n}\n\nexports.transcode = transcode;","map":{"version":3,"sources":["../../src/transcoding.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.transcode = exports.requestChangeCase = exports.flattenObject = exports.match = exports.applyPattern = exports.encodeWithoutSlashes = exports.encodeWithSlashes = exports.buildQueryStringComponents = exports.deleteField = exports.deepCopy = exports.getField = void 0;\nconst util_1 = require(\"./util\");\nconst httpOptionName = '(google.api.http)';\n// List of methods as defined in google/api/http.proto (see HttpRule)\nconst supportedHttpMethods = ['get', 'post', 'put', 'patch', 'delete'];\nfunction getField(request, field) {\n    const parts = field.split('.');\n    let value = request;\n    for (const part of parts) {\n        if (typeof value !== 'object') {\n            return undefined;\n        }\n        value = value[part];\n    }\n    if (typeof value === 'object' && !Array.isArray(value) && value !== null) {\n        return undefined;\n    }\n    return value;\n}\nexports.getField = getField;\nfunction deepCopy(request) {\n    if (typeof request !== 'object' || request === null) {\n        return request;\n    }\n    const copy = Object.assign({}, request);\n    for (const key in copy) {\n        if (Array.isArray(copy[key])) {\n            copy[key] = copy[key].map(deepCopy);\n        }\n        else if (typeof copy[key] === 'object' && copy[key] !== null) {\n            copy[key] = deepCopy(copy[key]);\n        }\n    }\n    return copy;\n}\nexports.deepCopy = deepCopy;\nfunction deleteField(request, field) {\n    const parts = field.split('.');\n    while (parts.length > 1) {\n        if (typeof request !== 'object') {\n            return;\n        }\n        const part = parts.shift();\n        request = request[part];\n    }\n    const part = parts.shift();\n    if (typeof request !== 'object') {\n        return;\n    }\n    delete request[part];\n}\nexports.deleteField = deleteField;\nfunction buildQueryStringComponents(request, prefix = '') {\n    const resultList = [];\n    for (const key in request) {\n        if (Array.isArray(request[key])) {\n            for (const value of request[key]) {\n                resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(value.toString())}`);\n            }\n        }\n        else if (typeof request[key] === 'object' && request[key] !== null) {\n            resultList.push(...buildQueryStringComponents(request[key], `${key}.`));\n        }\n        else {\n            resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(request[key].toString())}`);\n        }\n    }\n    return resultList;\n}\nexports.buildQueryStringComponents = buildQueryStringComponents;\nfunction encodeWithSlashes(str) {\n    return str\n        .split('')\n        .map(c => (c.match(/[-_.~0-9a-zA-Z]/) ? c : encodeURIComponent(c)))\n        .join('');\n}\nexports.encodeWithSlashes = encodeWithSlashes;\nfunction encodeWithoutSlashes(str) {\n    return str\n        .split('')\n        .map(c => (c.match(/[-_.~0-9a-zA-Z/]/) ? c : encodeURIComponent(c)))\n        .join('');\n}\nexports.encodeWithoutSlashes = encodeWithoutSlashes;\nfunction escapeRegExp(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction applyPattern(pattern, fieldValue) {\n    if (!pattern || pattern === '*') {\n        return encodeWithSlashes(fieldValue);\n    }\n    if (!pattern.includes('*') && pattern !== fieldValue) {\n        return undefined;\n    }\n    // since we're converting the pattern to a regex, make necessary precautions:\n    const regex = new RegExp('^' +\n        escapeRegExp(pattern)\n            .replace(/\\\\\\*\\\\\\*/g, '(.+)')\n            .replace(/\\\\\\*/g, '([^/]+)') +\n        '$');\n    if (!fieldValue.match(regex)) {\n        return undefined;\n    }\n    return encodeWithoutSlashes(fieldValue);\n}\nexports.applyPattern = applyPattern;\nfunction match(request, pattern) {\n    let url = pattern;\n    const matchedFields = [];\n    for (;;) {\n        const match = url.match(/^(.*)\\{([^}=]+)(?:=([^}]*))?\\}(.*)/);\n        if (!match) {\n            break;\n        }\n        const [, before, field, pattern, after] = match;\n        matchedFields.push(field);\n        const fieldValue = getField(request, field);\n        if (typeof fieldValue === 'undefined') {\n            return undefined;\n        }\n        const appliedPattern = applyPattern(pattern, fieldValue.toString());\n        if (typeof appliedPattern === 'undefined') {\n            return undefined;\n        }\n        url = before + appliedPattern + after;\n    }\n    return { matchedFields, url };\n}\nexports.match = match;\nfunction flattenObject(request) {\n    const result = {};\n    for (const key in request) {\n        if (typeof request[key] === 'undefined') {\n            continue;\n        }\n        if (Array.isArray(request[key])) {\n            // According to the http.proto comments, a repeated field may only\n            // contain primitive types, so no extra recursion here.\n            result[key] = request[key];\n            continue;\n        }\n        if (typeof request[key] === 'object' && request[key] !== null) {\n            const nested = flattenObject(request[key]);\n            for (const nestedKey in nested) {\n                result[`${key}.${nestedKey}`] = nested[nestedKey];\n            }\n            continue;\n        }\n        result[key] = request[key];\n    }\n    return result;\n}\nexports.flattenObject = flattenObject;\nfunction requestChangeCase(request, caseChangeFunc) {\n    if (!request || typeof request !== 'object') {\n        return request;\n    }\n    const convertedRequest = {};\n    for (const field in request) {\n        const convertedField = caseChangeFunc(field);\n        const value = request[field];\n        if (Array.isArray(value)) {\n            convertedRequest[convertedField] = value.map(v => requestChangeCase(v, caseChangeFunc));\n        }\n        else {\n            convertedRequest[convertedField] = requestChangeCase(value, caseChangeFunc);\n        }\n    }\n    return convertedRequest;\n}\nexports.requestChangeCase = requestChangeCase;\nfunction transcode(request, parsedOptions) {\n    // request is supposed to have keys in camelCase.\n    const snakeRequest = requestChangeCase(request, util_1.camelToSnakeCase);\n    const httpRules = [];\n    for (const option of parsedOptions) {\n        if (!(httpOptionName in option)) {\n            continue;\n        }\n        const httpRule = option[httpOptionName];\n        httpRules.push(httpRule);\n        if (httpRule === null || httpRule === void 0 ? void 0 : httpRule.additional_bindings) {\n            const additionalBindings = Array.isArray(httpRule.additional_bindings)\n                ? httpRule.additional_bindings\n                : [httpRule.additional_bindings];\n            httpRules.push(...additionalBindings);\n        }\n    }\n    for (const httpRule of httpRules) {\n        for (const httpMethod of supportedHttpMethods) {\n            if (!(httpMethod in httpRule)) {\n                continue;\n            }\n            const pathTemplate = httpRule[httpMethod];\n            const matchResult = match(snakeRequest, pathTemplate);\n            if (typeof matchResult === 'undefined') {\n                continue;\n            }\n            const { url, matchedFields } = matchResult;\n            if (httpRule.body === '*') {\n                // all fields except the matched fields go to request data\n                const data = deepCopy(snakeRequest);\n                for (const field of matchedFields) {\n                    deleteField(data, field);\n                }\n                // HTTP endpoint expects camelCase but we have snake_case at this point\n                const camelCaseData = requestChangeCase(data, util_1.snakeToCamelCase);\n                return { httpMethod, url, queryString: '', data: camelCaseData };\n            }\n            // one field possibly goes to request data, others go to query string\n            const body = httpRule.body;\n            let data = '';\n            const queryStringObject = deepCopy(request); // use camel case for query string\n            if (body) {\n                deleteField(queryStringObject, util_1.snakeToCamelCase(body));\n                data = snakeRequest[body];\n            }\n            for (const field of matchedFields) {\n                deleteField(queryStringObject, util_1.snakeToCamelCase(field));\n            }\n            const queryStringComponents = buildQueryStringComponents(queryStringObject);\n            const queryString = queryStringComponents.join('&');\n            let camelCaseData;\n            if (typeof data === 'string') {\n                camelCaseData = data;\n            }\n            else {\n                camelCaseData = requestChangeCase(data, util_1.snakeToCamelCase);\n            }\n            return { httpMethod, url, queryString, data: camelCaseData };\n        }\n    }\n    return undefined;\n}\nexports.transcode = transcode;\n//# sourceMappingURL=transcoding.js.map"]},"metadata":{},"sourceType":"script"}