{"ast":null,"code":"var EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits;\n\nvar StreamSearch = require('streamsearch');\n\nvar B_DCRLF = Buffer.from('\\r\\n\\r\\n'),\n    RE_CRLF = /\\r\\n/g,\n    RE_HDR = /^([^:]+):[ \\t]?([\\x00-\\xFF]+)?$/,\n    MAX_HEADER_PAIRS = 2000,\n    // from node's http.js\nMAX_HEADER_SIZE = 80 * 1024; // from node's http_parser\n\nfunction HeaderParser(cfg) {\n  EventEmitter.call(this);\n  var self = this;\n  this.nread = 0;\n  this.maxed = false;\n  this.npairs = 0;\n  this.maxHeaderPairs = cfg && typeof cfg.maxHeaderPairs === 'number' ? cfg.maxHeaderPairs : MAX_HEADER_PAIRS;\n  this.buffer = '';\n  this.header = {};\n  this.finished = false;\n  this.ss = new StreamSearch(B_DCRLF);\n  this.ss.on('info', function (isMatch, data, start, end) {\n    if (data && !self.maxed) {\n      if (self.nread + (end - start) > MAX_HEADER_SIZE) {\n        end = MAX_HEADER_SIZE - self.nread;\n        self.nread = MAX_HEADER_SIZE;\n      } else self.nread += end - start;\n\n      if (self.nread === MAX_HEADER_SIZE) self.maxed = true;\n      self.buffer += data.toString('binary', start, end);\n    }\n\n    if (isMatch) self._finish();\n  });\n}\n\ninherits(HeaderParser, EventEmitter);\n\nHeaderParser.prototype.push = function (data) {\n  var r = this.ss.push(data);\n  if (this.finished) return r;\n};\n\nHeaderParser.prototype.reset = function () {\n  this.finished = false;\n  this.buffer = '';\n  this.header = {};\n  this.ss.reset();\n};\n\nHeaderParser.prototype._finish = function () {\n  if (this.buffer) this._parseHeader();\n  this.ss.matches = this.ss.maxMatches;\n  var header = this.header;\n  this.header = {};\n  this.buffer = '';\n  this.finished = true;\n  this.nread = this.npairs = 0;\n  this.maxed = false;\n  this.emit('header', header);\n};\n\nHeaderParser.prototype._parseHeader = function () {\n  if (this.npairs === this.maxHeaderPairs) return;\n  var lines = this.buffer.split(RE_CRLF),\n      len = lines.length,\n      m,\n      h,\n      modded = false;\n\n  for (var i = 0; i < len; ++i) {\n    if (lines[i].length === 0) continue;\n\n    if (lines[i][0] === '\\t' || lines[i][0] === ' ') {\n      // folded header content\n      // RFC2822 says to just remove the CRLF and not the whitespace following\n      // it, so we follow the RFC and include the leading whitespace ...\n      this.header[h][this.header[h].length - 1] += lines[i];\n    } else {\n      m = RE_HDR.exec(lines[i]);\n\n      if (m) {\n        h = m[1].toLowerCase();\n\n        if (m[2]) {\n          if (this.header[h] === undefined) this.header[h] = [m[2]];else this.header[h].push(m[2]);\n        } else this.header[h] = [''];\n\n        if (++this.npairs === this.maxHeaderPairs) break;\n      } else {\n        this.buffer = lines[i];\n        modded = true;\n        break;\n      }\n    }\n  }\n\n  if (!modded) this.buffer = '';\n};\n\nmodule.exports = HeaderParser;","map":{"version":3,"sources":["/Users/piyushmaheshwari/Downloads/github/Bridgeorg/node_modules/dicer/lib/HeaderParser.js"],"names":["EventEmitter","require","inherits","StreamSearch","B_DCRLF","Buffer","from","RE_CRLF","RE_HDR","MAX_HEADER_PAIRS","MAX_HEADER_SIZE","HeaderParser","cfg","call","self","nread","maxed","npairs","maxHeaderPairs","buffer","header","finished","ss","on","isMatch","data","start","end","toString","_finish","prototype","push","r","reset","_parseHeader","matches","maxMatches","emit","lines","split","len","length","m","h","modded","i","exec","toLowerCase","undefined","module","exports"],"mappings":"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","sourcesContent":["var EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits;\n\nvar StreamSearch = require('streamsearch');\n\nvar B_DCRLF = Buffer.from('\\r\\n\\r\\n'),\n    RE_CRLF = /\\r\\n/g,\n    RE_HDR = /^([^:]+):[ \\t]?([\\x00-\\xFF]+)?$/,\n    MAX_HEADER_PAIRS = 2000, // from node's http.js\n    MAX_HEADER_SIZE = 80 * 1024; // from node's http_parser\n\nfunction HeaderParser(cfg) {\n  EventEmitter.call(this);\n\n  var self = this;\n  this.nread = 0;\n  this.maxed = false;\n  this.npairs = 0;\n  this.maxHeaderPairs = (cfg && typeof cfg.maxHeaderPairs === 'number'\n                         ? cfg.maxHeaderPairs\n                         : MAX_HEADER_PAIRS);\n  this.buffer = '';\n  this.header = {};\n  this.finished = false;\n  this.ss = new StreamSearch(B_DCRLF);\n  this.ss.on('info', function(isMatch, data, start, end) {\n    if (data && !self.maxed) {\n      if (self.nread + (end - start) > MAX_HEADER_SIZE) {\n        end = (MAX_HEADER_SIZE - self.nread);\n        self.nread = MAX_HEADER_SIZE;\n      } else\n        self.nread += (end - start);\n\n      if (self.nread === MAX_HEADER_SIZE)\n        self.maxed = true;\n\n      self.buffer += data.toString('binary', start, end);\n    }\n    if (isMatch)\n      self._finish();\n  });\n}\ninherits(HeaderParser, EventEmitter);\n\nHeaderParser.prototype.push = function(data) {\n  var r = this.ss.push(data);\n  if (this.finished)\n    return r;\n};\n\nHeaderParser.prototype.reset = function() {\n  this.finished = false;\n  this.buffer = '';\n  this.header = {};\n  this.ss.reset();\n};\n\nHeaderParser.prototype._finish = function() {\n  if (this.buffer)\n    this._parseHeader();\n  this.ss.matches = this.ss.maxMatches;\n  var header = this.header;\n  this.header = {};\n  this.buffer = '';\n  this.finished = true;\n  this.nread = this.npairs = 0;\n  this.maxed = false;\n  this.emit('header', header);\n};\n\nHeaderParser.prototype._parseHeader = function() {\n  if (this.npairs === this.maxHeaderPairs)\n    return;\n\n  var lines = this.buffer.split(RE_CRLF), len = lines.length, m, h,\n      modded = false;\n\n  for (var i = 0; i < len; ++i) {\n    if (lines[i].length === 0)\n      continue;\n    if (lines[i][0] === '\\t' || lines[i][0] === ' ') {\n      // folded header content\n      // RFC2822 says to just remove the CRLF and not the whitespace following\n      // it, so we follow the RFC and include the leading whitespace ...\n      this.header[h][this.header[h].length - 1] += lines[i];\n    } else {\n      m = RE_HDR.exec(lines[i]);\n      if (m) {\n        h = m[1].toLowerCase();\n        if (m[2]) {\n          if (this.header[h] === undefined)\n            this.header[h] = [m[2]];\n          else\n            this.header[h].push(m[2]);\n        } else\n          this.header[h] = [''];\n        if (++this.npairs === this.maxHeaderPairs)\n          break;\n      } else {\n        this.buffer = lines[i];\n        modded = true;\n        break;\n      }\n    }\n  }\n  if (!modded)\n    this.buffer = '';\n};\n\nmodule.exports = HeaderParser;\n"]},"metadata":{},"sourceType":"script"}