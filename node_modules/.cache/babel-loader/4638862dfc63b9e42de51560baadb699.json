{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PagedApiCaller = void 0;\n\nconst call_1 = require(\"../call\");\n\nconst googleError_1 = require(\"../googleError\");\n\nconst resourceCollector_1 = require(\"./resourceCollector\");\n\nclass PagedApiCaller {\n  /**\n   * Creates an API caller that returns a stream to performs page-streaming.\n   *\n   * @private\n   * @constructor\n   * @param {PageDescriptor} pageDescriptor - indicates the structure\n   *   of page streaming to be performed.\n   */\n  constructor(pageDescriptor) {\n    this.pageDescriptor = pageDescriptor;\n  }\n  /**\n   * This function translates between regular gRPC calls (that accepts a request and returns a response,\n   * and does not know anything about pages and page tokens) and the users' callback (that expects\n   * to see resources from one page, a request to get the next page, and the raw response from the server).\n   *\n   * It generates a function that can be passed as a callback function to a gRPC call, will understand\n   * pagination-specific fields in the response, and call the users' callback after having those fields\n   * parsed.\n   *\n   * @param request Request object. It needs to be passed to all subsequent next page requests\n   * (the main content of the request object stays unchanged, only the next page token changes)\n   * @param callback The user's callback that expects the page content, next page request, and raw response.\n   */\n\n\n  generateParseResponseCallback(request, callback) {\n    const resourceFieldName = this.pageDescriptor.resourceField;\n    const responsePageTokenFieldName = this.pageDescriptor.responsePageTokenField;\n    const requestPageTokenFieldName = this.pageDescriptor.requestPageTokenField;\n    return (err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      if (!request) {\n        callback(new googleError_1.GoogleError('Undefined request in pagination method callback.'));\n        return;\n      }\n\n      if (!response) {\n        callback(new googleError_1.GoogleError('Undefined response in pagination method callback.'));\n        return;\n      }\n\n      const resources = response[resourceFieldName];\n      const pageToken = response[responsePageTokenFieldName];\n      let nextPageRequest = null;\n\n      if (pageToken) {\n        nextPageRequest = Object.assign({}, request);\n        nextPageRequest[requestPageTokenFieldName] = pageToken;\n      }\n\n      callback(err, resources, nextPageRequest, response);\n    };\n  }\n  /**\n   * Adds a special ability to understand pagination-specific fields to the existing gRPC call.\n   * The original gRPC call just calls callback(err, result).\n   * The wrapped one will call callback(err, resources, nextPageRequest, rawResponse) instead.\n   *\n   * @param func gRPC call (normally, a service stub call). The gRPC call is expected to accept four parameters:\n   * request, metadata, call options, and callback.\n   */\n\n\n  wrap(func) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    return function wrappedCall(argument, metadata, options, callback) {\n      return func(argument, metadata, options, self.generateParseResponseCallback(argument, callback));\n    };\n  }\n  /**\n   * Makes it possible to use both callback-based and promise-based calls.\n   * Returns an OngoingCall or OngoingCallPromise object.\n   * Regardless of which one is returned, it always has a `.callback` to call.\n   *\n   * @param settings Call settings. Can only be used to replace Promise with another promise implementation.\n   * @param [callback] Callback to be called, if any.\n   */\n\n\n  init(callback) {\n    if (callback) {\n      return new call_1.OngoingCall(callback);\n    }\n\n    return new call_1.OngoingCallPromise();\n  }\n  /**\n   * Implements auto-pagination logic.\n   *\n   * @param apiCall A function that performs gRPC request and calls its callback with a response or an error.\n   * It's supposed to be a gRPC service stub function wrapped into several layers of wrappers that make it\n   * accept just two parameters: (request, callback).\n   * @param request A request object that came from the user.\n   * @param settings Call settings. We are interested in `maxResults`, autoPaginate`, `pageToken`, and `pageSize`\n   * (they are all optional).\n   * @param ongoingCall An instance of OngoingCall or OngoingCallPromise that can be used for call cancellation,\n   * and is used to return results to the user.\n   */\n\n\n  call(apiCall, request, settings, ongoingCall) {\n    request = Object.assign({}, request); // If settings object contain pageToken or pageSize, override the corresponding fields in the request object.\n\n    if (settings.pageToken) {\n      request[this.pageDescriptor.requestPageTokenField] = settings.pageToken;\n    }\n\n    if (settings.pageSize) {\n      request[this.pageDescriptor.requestPageSizeField] = settings.pageSize;\n    }\n\n    if (!settings.autoPaginate) {\n      // they don't want auto-pagination this time - okay, just call once\n      ongoingCall.call(apiCall, request);\n      return;\n    }\n\n    const maxResults = settings.maxResults || -1;\n    const resourceCollector = new resourceCollector_1.ResourceCollector(apiCall, maxResults);\n    resourceCollector.processAllPages(request).then(resources => ongoingCall.callback(null, resources), err => ongoingCall.callback(err));\n  }\n\n  fail(ongoingCall, err) {\n    ongoingCall.callback(err);\n  }\n\n  result(ongoingCall) {\n    return ongoingCall.promise;\n  }\n\n}\n\nexports.PagedApiCaller = PagedApiCaller;","map":{"version":3,"sources":["../../../src/paginationCalls/pagedApiCaller.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;AAcG;;;;;;;AAWH,MAAA,MAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAEA,MAAA,aAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEA,MAAA,mBAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AAEA,MAAa,cAAb,CAA2B;AAEzB;;;;;;;AAOG;AACH,EAAA,WAAA,CAAY,cAAZ,EAA0C;AACxC,SAAK,cAAL,GAAsB,cAAtB;AACD;AAED;;;;;;;;;;;;AAYG;;;AACK,EAAA,6BAA6B,CACnC,OADmC,EAEnC,QAFmC,EAEd;AAErB,UAAM,iBAAiB,GAAG,KAAK,cAAL,CAAoB,aAA9C;AACA,UAAM,0BAA0B,GAAG,KAAK,cAAL,CAChC,sBADH;AAEA,UAAM,yBAAyB,GAAG,KAAK,cAAL,CAAoB,qBAAtD;AACA,WAAO,CAAC,GAAD,EAAoB,QAApB,KAAiE;AACtE,UAAI,GAAJ,EAAS;AACP,QAAA,QAAQ,CAAC,GAAD,CAAR;AACA;AACD;;AACD,UAAI,CAAC,OAAL,EAAc;AACZ,QAAA,QAAQ,CACN,IAAI,aAAA,CAAA,WAAJ,CAAgB,kDAAhB,CADM,CAAR;AAGA;AACD;;AACD,UAAI,CAAC,QAAL,EAAe;AACb,QAAA,QAAQ,CACN,IAAI,aAAA,CAAA,WAAJ,CAAgB,mDAAhB,CADM,CAAR;AAGA;AACD;;AACD,YAAM,SAAS,GAAG,QAAQ,CAAC,iBAAD,CAA1B;AACA,YAAM,SAAS,GAAG,QAAQ,CAAC,0BAAD,CAA1B;AACA,UAAI,eAAe,GAAG,IAAtB;;AACA,UAAI,SAAJ,EAAe;AACb,QAAA,eAAe,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,OAAlB,CAAlB;AACA,QAAA,eAAe,CAAC,yBAAD,CAAf,GAA6C,SAA7C;AACD;;AACD,MAAA,QAAQ,CAAC,GAAD,EAAM,SAAN,EAAiB,eAAjB,EAAkC,QAAlC,CAAR;AACD,KAzBD;AA0BD;AAED;;;;;;;AAOG;;;AACH,EAAA,IAAI,CAAC,IAAD,EAAe;AACjB;AACA,UAAM,IAAI,GAAG,IAAb;AACA,WAAO,SAAS,WAAT,CAAqB,QAArB,EAA+B,QAA/B,EAAyC,OAAzC,EAAkD,QAAlD,EAA0D;AAC/D,aAAQ,IAAkB,CACxB,QADwB,EAExB,QAFwB,EAGxB,OAHwB,EAIxB,IAAI,CAAC,6BAAL,CAAmC,QAAnC,EAA6C,QAA7C,CAJwB,CAA1B;AAMD,KAPD;AAQD;AAED;;;;;;;AAOG;;;AACH,EAAA,IAAI,CAAC,QAAD,EAAuB;AACzB,QAAI,QAAJ,EAAc;AACZ,aAAO,IAAI,MAAA,CAAA,WAAJ,CAAgB,QAAhB,CAAP;AACD;;AACD,WAAO,IAAI,MAAA,CAAA,kBAAJ,EAAP;AACD;AAED;;;;;;;;;;;AAWG;;;AACH,EAAA,IAAI,CACF,OADE,EAEF,OAFE,EAGF,QAHE,EAIF,WAJE,EAIsB;AAExB,IAAA,OAAO,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,OAAlB,CAAV,CAFwB,CAIxB;;AACA,QAAI,QAAQ,CAAC,SAAb,EAAwB;AACtB,MAAA,OAAO,CAAC,KAAK,cAAL,CAAoB,qBAArB,CAAP,GAAqD,QAAQ,CAAC,SAA9D;AACD;;AACD,QAAI,QAAQ,CAAC,QAAb,EAAuB;AACrB,MAAA,OAAO,CAAC,KAAK,cAAL,CAAoB,oBAArB,CAAP,GAAqD,QAAQ,CAAC,QAA9D;AACD;;AAED,QAAI,CAAC,QAAQ,CAAC,YAAd,EAA4B;AAC1B;AACA,MAAA,WAAW,CAAC,IAAZ,CAAiB,OAAjB,EAA0B,OAA1B;AACA;AACD;;AAED,UAAM,UAAU,GAAG,QAAQ,CAAC,UAAT,IAAuB,CAAC,CAA3C;AAEA,UAAM,iBAAiB,GAAG,IAAI,mBAAA,CAAA,iBAAJ,CAAsB,OAAtB,EAA+B,UAA/B,CAA1B;AACA,IAAA,iBAAiB,CAAC,eAAlB,CAAkC,OAAlC,EAA2C,IAA3C,CACE,SAAS,IAAI,WAAW,CAAC,QAAZ,CAAqB,IAArB,EAA2B,SAA3B,CADf,EAEE,GAAG,IAAI,WAAW,CAAC,QAAZ,CAAqB,GAArB,CAFT;AAID;;AAED,EAAA,IAAI,CAAC,WAAD,EAAkC,GAAlC,EAAkD;AACpD,IAAA,WAAW,CAAC,QAAZ,CAAsB,GAAtB;AACD;;AAED,EAAA,MAAM,CAAC,WAAD,EAAgC;AACpC,WAAO,WAAW,CAAC,OAAnB;AACD;;AApJwB;;AAA3B,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PagedApiCaller = void 0;\nconst call_1 = require(\"../call\");\nconst googleError_1 = require(\"../googleError\");\nconst resourceCollector_1 = require(\"./resourceCollector\");\nclass PagedApiCaller {\n    /**\n     * Creates an API caller that returns a stream to performs page-streaming.\n     *\n     * @private\n     * @constructor\n     * @param {PageDescriptor} pageDescriptor - indicates the structure\n     *   of page streaming to be performed.\n     */\n    constructor(pageDescriptor) {\n        this.pageDescriptor = pageDescriptor;\n    }\n    /**\n     * This function translates between regular gRPC calls (that accepts a request and returns a response,\n     * and does not know anything about pages and page tokens) and the users' callback (that expects\n     * to see resources from one page, a request to get the next page, and the raw response from the server).\n     *\n     * It generates a function that can be passed as a callback function to a gRPC call, will understand\n     * pagination-specific fields in the response, and call the users' callback after having those fields\n     * parsed.\n     *\n     * @param request Request object. It needs to be passed to all subsequent next page requests\n     * (the main content of the request object stays unchanged, only the next page token changes)\n     * @param callback The user's callback that expects the page content, next page request, and raw response.\n     */\n    generateParseResponseCallback(request, callback) {\n        const resourceFieldName = this.pageDescriptor.resourceField;\n        const responsePageTokenFieldName = this.pageDescriptor\n            .responsePageTokenField;\n        const requestPageTokenFieldName = this.pageDescriptor.requestPageTokenField;\n        return (err, response) => {\n            if (err) {\n                callback(err);\n                return;\n            }\n            if (!request) {\n                callback(new googleError_1.GoogleError('Undefined request in pagination method callback.'));\n                return;\n            }\n            if (!response) {\n                callback(new googleError_1.GoogleError('Undefined response in pagination method callback.'));\n                return;\n            }\n            const resources = response[resourceFieldName];\n            const pageToken = response[responsePageTokenFieldName];\n            let nextPageRequest = null;\n            if (pageToken) {\n                nextPageRequest = Object.assign({}, request);\n                nextPageRequest[requestPageTokenFieldName] = pageToken;\n            }\n            callback(err, resources, nextPageRequest, response);\n        };\n    }\n    /**\n     * Adds a special ability to understand pagination-specific fields to the existing gRPC call.\n     * The original gRPC call just calls callback(err, result).\n     * The wrapped one will call callback(err, resources, nextPageRequest, rawResponse) instead.\n     *\n     * @param func gRPC call (normally, a service stub call). The gRPC call is expected to accept four parameters:\n     * request, metadata, call options, and callback.\n     */\n    wrap(func) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        return function wrappedCall(argument, metadata, options, callback) {\n            return func(argument, metadata, options, self.generateParseResponseCallback(argument, callback));\n        };\n    }\n    /**\n     * Makes it possible to use both callback-based and promise-based calls.\n     * Returns an OngoingCall or OngoingCallPromise object.\n     * Regardless of which one is returned, it always has a `.callback` to call.\n     *\n     * @param settings Call settings. Can only be used to replace Promise with another promise implementation.\n     * @param [callback] Callback to be called, if any.\n     */\n    init(callback) {\n        if (callback) {\n            return new call_1.OngoingCall(callback);\n        }\n        return new call_1.OngoingCallPromise();\n    }\n    /**\n     * Implements auto-pagination logic.\n     *\n     * @param apiCall A function that performs gRPC request and calls its callback with a response or an error.\n     * It's supposed to be a gRPC service stub function wrapped into several layers of wrappers that make it\n     * accept just two parameters: (request, callback).\n     * @param request A request object that came from the user.\n     * @param settings Call settings. We are interested in `maxResults`, autoPaginate`, `pageToken`, and `pageSize`\n     * (they are all optional).\n     * @param ongoingCall An instance of OngoingCall or OngoingCallPromise that can be used for call cancellation,\n     * and is used to return results to the user.\n     */\n    call(apiCall, request, settings, ongoingCall) {\n        request = Object.assign({}, request);\n        // If settings object contain pageToken or pageSize, override the corresponding fields in the request object.\n        if (settings.pageToken) {\n            request[this.pageDescriptor.requestPageTokenField] = settings.pageToken;\n        }\n        if (settings.pageSize) {\n            request[this.pageDescriptor.requestPageSizeField] = settings.pageSize;\n        }\n        if (!settings.autoPaginate) {\n            // they don't want auto-pagination this time - okay, just call once\n            ongoingCall.call(apiCall, request);\n            return;\n        }\n        const maxResults = settings.maxResults || -1;\n        const resourceCollector = new resourceCollector_1.ResourceCollector(apiCall, maxResults);\n        resourceCollector.processAllPages(request).then(resources => ongoingCall.callback(null, resources), err => ongoingCall.callback(err));\n    }\n    fail(ongoingCall, err) {\n        ongoingCall.callback(err);\n    }\n    result(ongoingCall) {\n        return ongoingCall.promise;\n    }\n}\nexports.PagedApiCaller = PagedApiCaller;\n//# sourceMappingURL=pagedApiCaller.js.map"]},"metadata":{},"sourceType":"script"}