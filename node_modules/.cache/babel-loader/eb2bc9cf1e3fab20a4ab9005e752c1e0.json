{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst convert_1 = require(\"./convert\");\n\nconst path_1 = require(\"./path\");\n/*!\n * The type order as defined by the backend.\n */\n\n\nvar TypeOrder;\n\n(function (TypeOrder) {\n  TypeOrder[TypeOrder[\"NULL\"] = 0] = \"NULL\";\n  TypeOrder[TypeOrder[\"BOOLEAN\"] = 1] = \"BOOLEAN\";\n  TypeOrder[TypeOrder[\"NUMBER\"] = 2] = \"NUMBER\";\n  TypeOrder[TypeOrder[\"TIMESTAMP\"] = 3] = \"TIMESTAMP\";\n  TypeOrder[TypeOrder[\"STRING\"] = 4] = \"STRING\";\n  TypeOrder[TypeOrder[\"BLOB\"] = 5] = \"BLOB\";\n  TypeOrder[TypeOrder[\"REF\"] = 6] = \"REF\";\n  TypeOrder[TypeOrder[\"GEO_POINT\"] = 7] = \"GEO_POINT\";\n  TypeOrder[TypeOrder[\"ARRAY\"] = 8] = \"ARRAY\";\n  TypeOrder[TypeOrder[\"OBJECT\"] = 9] = \"OBJECT\";\n})(TypeOrder || (TypeOrder = {}));\n/*!\n * @private\n */\n\n\nfunction typeOrder(val) {\n  const valueType = convert_1.detectValueType(val);\n\n  switch (valueType) {\n    case 'nullValue':\n      return TypeOrder.NULL;\n\n    case 'integerValue':\n      return TypeOrder.NUMBER;\n\n    case 'doubleValue':\n      return TypeOrder.NUMBER;\n\n    case 'stringValue':\n      return TypeOrder.STRING;\n\n    case 'booleanValue':\n      return TypeOrder.BOOLEAN;\n\n    case 'arrayValue':\n      return TypeOrder.ARRAY;\n\n    case 'timestampValue':\n      return TypeOrder.TIMESTAMP;\n\n    case 'geoPointValue':\n      return TypeOrder.GEO_POINT;\n\n    case 'bytesValue':\n      return TypeOrder.BLOB;\n\n    case 'referenceValue':\n      return TypeOrder.REF;\n\n    case 'mapValue':\n      return TypeOrder.OBJECT;\n\n    default:\n      throw new Error('Unexpected value type: ' + valueType);\n  }\n}\n/*!\n * @private\n */\n\n\nfunction primitiveComparator(left, right) {\n  if (left < right) {\n    return -1;\n  }\n\n  if (left > right) {\n    return 1;\n  }\n\n  return 0;\n}\n\nexports.primitiveComparator = primitiveComparator;\n/*!\n * Utility function to compare doubles (using Firestore semantics for NaN).\n * @private\n */\n\nfunction compareNumbers(left, right) {\n  if (left < right) {\n    return -1;\n  }\n\n  if (left > right) {\n    return 1;\n  }\n\n  if (left === right) {\n    return 0;\n  } // one or both are NaN.\n\n\n  if (isNaN(left)) {\n    return isNaN(right) ? 0 : -1;\n  }\n\n  return 1;\n}\n/*!\n * @private\n */\n\n\nfunction compareNumberProtos(left, right) {\n  let leftValue, rightValue;\n\n  if (left.integerValue !== undefined) {\n    leftValue = Number(left.integerValue);\n  } else {\n    leftValue = Number(left.doubleValue);\n  }\n\n  if (right.integerValue !== undefined) {\n    rightValue = Number(right.integerValue);\n  } else {\n    rightValue = Number(right.doubleValue);\n  }\n\n  return compareNumbers(leftValue, rightValue);\n}\n/*!\n * @private\n */\n\n\nfunction compareTimestamps(left, right) {\n  const seconds = primitiveComparator(left.seconds || 0, right.seconds || 0);\n\n  if (seconds !== 0) {\n    return seconds;\n  }\n\n  return primitiveComparator(left.nanos || 0, right.nanos || 0);\n}\n/*!\n * @private\n */\n\n\nfunction compareBlobs(left, right) {\n  if (!(left instanceof Buffer) || !(right instanceof Buffer)) {\n    throw new Error('Blobs can only be compared if they are Buffers.');\n  }\n\n  return Buffer.compare(left, right);\n}\n/*!\n * @private\n */\n\n\nfunction compareReferenceProtos(left, right) {\n  const leftPath = path_1.QualifiedResourcePath.fromSlashSeparatedString(left.referenceValue);\n  const rightPath = path_1.QualifiedResourcePath.fromSlashSeparatedString(right.referenceValue);\n  return leftPath.compareTo(rightPath);\n}\n/*!\n * @private\n */\n\n\nfunction compareGeoPoints(left, right) {\n  return primitiveComparator(left.latitude || 0, right.latitude || 0) || primitiveComparator(left.longitude || 0, right.longitude || 0);\n}\n/*!\n * @private\n */\n\n\nfunction compareArrays(left, right) {\n  for (let i = 0; i < left.length && i < right.length; i++) {\n    const valueComparison = compare(left[i], right[i]);\n\n    if (valueComparison !== 0) {\n      return valueComparison;\n    }\n  } // If all the values matched so far, just check the length.\n\n\n  return primitiveComparator(left.length, right.length);\n}\n/*!\n * @private\n */\n\n\nfunction compareObjects(left, right) {\n  // This requires iterating over the keys in the object in order and doing a\n  // deep comparison.\n  const leftKeys = Object.keys(left);\n  const rightKeys = Object.keys(right);\n  leftKeys.sort();\n  rightKeys.sort();\n\n  for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\n    const keyComparison = primitiveComparator(leftKeys[i], rightKeys[i]);\n\n    if (keyComparison !== 0) {\n      return keyComparison;\n    }\n\n    const key = leftKeys[i];\n    const valueComparison = compare(left[key], right[key]);\n\n    if (valueComparison !== 0) {\n      return valueComparison;\n    }\n  } // If all the keys matched so far, just check the length.\n\n\n  return primitiveComparator(leftKeys.length, rightKeys.length);\n}\n/*!\n * @private\n */\n\n\nfunction compare(left, right) {\n  // First compare the types.\n  const leftType = typeOrder(left);\n  const rightType = typeOrder(right);\n  const typeComparison = primitiveComparator(leftType, rightType);\n\n  if (typeComparison !== 0) {\n    return typeComparison;\n  } // So they are the same type.\n\n\n  switch (leftType) {\n    case TypeOrder.NULL:\n      // Nulls are all equal.\n      return 0;\n\n    case TypeOrder.BOOLEAN:\n      return primitiveComparator(left.booleanValue, right.booleanValue);\n\n    case TypeOrder.STRING:\n      return primitiveComparator(left.stringValue, right.stringValue);\n\n    case TypeOrder.NUMBER:\n      return compareNumberProtos(left, right);\n\n    case TypeOrder.TIMESTAMP:\n      return compareTimestamps(left.timestampValue, right.timestampValue);\n\n    case TypeOrder.BLOB:\n      return compareBlobs(left.bytesValue, right.bytesValue);\n\n    case TypeOrder.REF:\n      return compareReferenceProtos(left, right);\n\n    case TypeOrder.GEO_POINT:\n      return compareGeoPoints(left.geoPointValue, right.geoPointValue);\n\n    case TypeOrder.ARRAY:\n      return compareArrays(left.arrayValue.values || [], right.arrayValue.values || []);\n\n    case TypeOrder.OBJECT:\n      return compareObjects(left.mapValue.fields || {}, right.mapValue.fields || {});\n\n    default:\n      throw new Error(`Encountered unknown type order: ${leftType}`);\n  }\n}\n\nexports.compare = compare;","map":{"version":3,"sources":["/Users/piyushmaheshwari/Downloads/github/Bridgeorg/node_modules/@google-cloud/firestore/build/src/order.js"],"names":["Object","defineProperty","exports","value","convert_1","require","path_1","TypeOrder","typeOrder","val","valueType","detectValueType","NULL","NUMBER","STRING","BOOLEAN","ARRAY","TIMESTAMP","GEO_POINT","BLOB","REF","OBJECT","Error","primitiveComparator","left","right","compareNumbers","isNaN","compareNumberProtos","leftValue","rightValue","integerValue","undefined","Number","doubleValue","compareTimestamps","seconds","nanos","compareBlobs","Buffer","compare","compareReferenceProtos","leftPath","QualifiedResourcePath","fromSlashSeparatedString","referenceValue","rightPath","compareTo","compareGeoPoints","latitude","longitude","compareArrays","i","length","valueComparison","compareObjects","leftKeys","keys","rightKeys","sort","keyComparison","key","leftType","rightType","typeComparison","booleanValue","stringValue","timestampValue","bytesValue","geoPointValue","arrayValue","values","mapValue","fields"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst convert_1 = require(\"./convert\");\nconst path_1 = require(\"./path\");\n/*!\n * The type order as defined by the backend.\n */\nvar TypeOrder;\n(function (TypeOrder) {\n    TypeOrder[TypeOrder[\"NULL\"] = 0] = \"NULL\";\n    TypeOrder[TypeOrder[\"BOOLEAN\"] = 1] = \"BOOLEAN\";\n    TypeOrder[TypeOrder[\"NUMBER\"] = 2] = \"NUMBER\";\n    TypeOrder[TypeOrder[\"TIMESTAMP\"] = 3] = \"TIMESTAMP\";\n    TypeOrder[TypeOrder[\"STRING\"] = 4] = \"STRING\";\n    TypeOrder[TypeOrder[\"BLOB\"] = 5] = \"BLOB\";\n    TypeOrder[TypeOrder[\"REF\"] = 6] = \"REF\";\n    TypeOrder[TypeOrder[\"GEO_POINT\"] = 7] = \"GEO_POINT\";\n    TypeOrder[TypeOrder[\"ARRAY\"] = 8] = \"ARRAY\";\n    TypeOrder[TypeOrder[\"OBJECT\"] = 9] = \"OBJECT\";\n})(TypeOrder || (TypeOrder = {}));\n/*!\n * @private\n */\nfunction typeOrder(val) {\n    const valueType = convert_1.detectValueType(val);\n    switch (valueType) {\n        case 'nullValue':\n            return TypeOrder.NULL;\n        case 'integerValue':\n            return TypeOrder.NUMBER;\n        case 'doubleValue':\n            return TypeOrder.NUMBER;\n        case 'stringValue':\n            return TypeOrder.STRING;\n        case 'booleanValue':\n            return TypeOrder.BOOLEAN;\n        case 'arrayValue':\n            return TypeOrder.ARRAY;\n        case 'timestampValue':\n            return TypeOrder.TIMESTAMP;\n        case 'geoPointValue':\n            return TypeOrder.GEO_POINT;\n        case 'bytesValue':\n            return TypeOrder.BLOB;\n        case 'referenceValue':\n            return TypeOrder.REF;\n        case 'mapValue':\n            return TypeOrder.OBJECT;\n        default:\n            throw new Error('Unexpected value type: ' + valueType);\n    }\n}\n/*!\n * @private\n */\nfunction primitiveComparator(left, right) {\n    if (left < right) {\n        return -1;\n    }\n    if (left > right) {\n        return 1;\n    }\n    return 0;\n}\nexports.primitiveComparator = primitiveComparator;\n/*!\n * Utility function to compare doubles (using Firestore semantics for NaN).\n * @private\n */\nfunction compareNumbers(left, right) {\n    if (left < right) {\n        return -1;\n    }\n    if (left > right) {\n        return 1;\n    }\n    if (left === right) {\n        return 0;\n    }\n    // one or both are NaN.\n    if (isNaN(left)) {\n        return isNaN(right) ? 0 : -1;\n    }\n    return 1;\n}\n/*!\n * @private\n */\nfunction compareNumberProtos(left, right) {\n    let leftValue, rightValue;\n    if (left.integerValue !== undefined) {\n        leftValue = Number(left.integerValue);\n    }\n    else {\n        leftValue = Number(left.doubleValue);\n    }\n    if (right.integerValue !== undefined) {\n        rightValue = Number(right.integerValue);\n    }\n    else {\n        rightValue = Number(right.doubleValue);\n    }\n    return compareNumbers(leftValue, rightValue);\n}\n/*!\n * @private\n */\nfunction compareTimestamps(left, right) {\n    const seconds = primitiveComparator(left.seconds || 0, right.seconds || 0);\n    if (seconds !== 0) {\n        return seconds;\n    }\n    return primitiveComparator(left.nanos || 0, right.nanos || 0);\n}\n/*!\n * @private\n */\nfunction compareBlobs(left, right) {\n    if (!(left instanceof Buffer) || !(right instanceof Buffer)) {\n        throw new Error('Blobs can only be compared if they are Buffers.');\n    }\n    return Buffer.compare(left, right);\n}\n/*!\n * @private\n */\nfunction compareReferenceProtos(left, right) {\n    const leftPath = path_1.QualifiedResourcePath.fromSlashSeparatedString(left.referenceValue);\n    const rightPath = path_1.QualifiedResourcePath.fromSlashSeparatedString(right.referenceValue);\n    return leftPath.compareTo(rightPath);\n}\n/*!\n * @private\n */\nfunction compareGeoPoints(left, right) {\n    return (primitiveComparator(left.latitude || 0, right.latitude || 0) ||\n        primitiveComparator(left.longitude || 0, right.longitude || 0));\n}\n/*!\n * @private\n */\nfunction compareArrays(left, right) {\n    for (let i = 0; i < left.length && i < right.length; i++) {\n        const valueComparison = compare(left[i], right[i]);\n        if (valueComparison !== 0) {\n            return valueComparison;\n        }\n    }\n    // If all the values matched so far, just check the length.\n    return primitiveComparator(left.length, right.length);\n}\n/*!\n * @private\n */\nfunction compareObjects(left, right) {\n    // This requires iterating over the keys in the object in order and doing a\n    // deep comparison.\n    const leftKeys = Object.keys(left);\n    const rightKeys = Object.keys(right);\n    leftKeys.sort();\n    rightKeys.sort();\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\n        const keyComparison = primitiveComparator(leftKeys[i], rightKeys[i]);\n        if (keyComparison !== 0) {\n            return keyComparison;\n        }\n        const key = leftKeys[i];\n        const valueComparison = compare(left[key], right[key]);\n        if (valueComparison !== 0) {\n            return valueComparison;\n        }\n    }\n    // If all the keys matched so far, just check the length.\n    return primitiveComparator(leftKeys.length, rightKeys.length);\n}\n/*!\n * @private\n */\nfunction compare(left, right) {\n    // First compare the types.\n    const leftType = typeOrder(left);\n    const rightType = typeOrder(right);\n    const typeComparison = primitiveComparator(leftType, rightType);\n    if (typeComparison !== 0) {\n        return typeComparison;\n    }\n    // So they are the same type.\n    switch (leftType) {\n        case TypeOrder.NULL:\n            // Nulls are all equal.\n            return 0;\n        case TypeOrder.BOOLEAN:\n            return primitiveComparator(left.booleanValue, right.booleanValue);\n        case TypeOrder.STRING:\n            return primitiveComparator(left.stringValue, right.stringValue);\n        case TypeOrder.NUMBER:\n            return compareNumberProtos(left, right);\n        case TypeOrder.TIMESTAMP:\n            return compareTimestamps(left.timestampValue, right.timestampValue);\n        case TypeOrder.BLOB:\n            return compareBlobs(left.bytesValue, right.bytesValue);\n        case TypeOrder.REF:\n            return compareReferenceProtos(left, right);\n        case TypeOrder.GEO_POINT:\n            return compareGeoPoints(left.geoPointValue, right.geoPointValue);\n        case TypeOrder.ARRAY:\n            return compareArrays(left.arrayValue.values || [], right.arrayValue.values || []);\n        case TypeOrder.OBJECT:\n            return compareObjects(left.mapValue.fields || {}, right.mapValue.fields || {});\n        default:\n            throw new Error(`Encountered unknown type order: ${leftType}`);\n    }\n}\nexports.compare = compare;\n//# sourceMappingURL=order.js.map"]},"metadata":{},"sourceType":"script"}