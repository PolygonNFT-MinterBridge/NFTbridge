{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst url_1 = require(\"url\");\n\nconst util_1 = require(\"./util\");\n/**\n * Generates an error message to use with custom objects that cannot be\n * serialized.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The value that failed serialization.\n * @param path The field path that the object is assigned to.\n */\n\n\nfunction customObjectMessage(arg, value, path) {\n  const fieldPathMessage = path ? ` (found in field \"${path}\")` : '';\n\n  if (util_1.isObject(value)) {\n    // We use the base class name as the type name as the sentinel classes\n    // returned by the public FieldValue API are subclasses of FieldValue. By\n    // using the base name, we reduce the number of special cases below.\n    const typeName = value.constructor.name;\n\n    switch (typeName) {\n      case 'DocumentReference':\n      case 'FieldPath':\n      case 'FieldValue':\n      case 'GeoPoint':\n      case 'Timestamp':\n        return `${invalidArgumentMessage(arg, 'Firestore document')} Detected an object of type \"${typeName}\" that doesn't match the ` + `expected instance${fieldPathMessage}. Please ensure that the ` + 'Firestore types you are using are from the same NPM package.)';\n\n      case 'Object':\n        return `${invalidArgumentMessage(arg, 'Firestore document')} Invalid use of type \"${typeof value}\" as a Firestore argument${fieldPathMessage}.`;\n\n      default:\n        return `${invalidArgumentMessage(arg, 'Firestore document')} Couldn't serialize object of type \"${typeName}\"${fieldPathMessage}. Firestore doesn't support JavaScript ` + 'objects with custom prototypes (i.e. objects that were created ' + 'via the \"new\" operator).';\n    }\n  } else {\n    return `${invalidArgumentMessage(arg, 'Firestore document')} Input is not a plain JavaScript object${fieldPathMessage}.`;\n  }\n}\n\nexports.customObjectMessage = customObjectMessage;\n/**\n * Validates that 'value' is a function.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the function can be omitted.\n */\n\nfunction validateFunction(arg, value, options) {\n  if (!validateOptional(value, options)) {\n    if (!util_1.isFunction(value)) {\n      throw new Error(invalidArgumentMessage(arg, 'function'));\n    }\n  }\n}\n\nexports.validateFunction = validateFunction;\n/**\n * Validates that 'value' is an object.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the object can be omitted.\n */\n\nfunction validateObject(arg, value, options) {\n  if (!validateOptional(value, options)) {\n    if (!util_1.isObject(value)) {\n      throw new Error(invalidArgumentMessage(arg, 'object'));\n    }\n  }\n}\n\nexports.validateObject = validateObject;\n/**\n * Validates that 'value' is a string.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the string can be omitted.\n */\n\nfunction validateString(arg, value, options) {\n  if (!validateOptional(value, options)) {\n    if (typeof value !== 'string') {\n      throw new Error(invalidArgumentMessage(arg, 'string'));\n    }\n  }\n}\n\nexports.validateString = validateString;\n/**\n * Validates that 'value' is a host.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the host can be omitted.\n */\n\nfunction validateHost(arg, value, options) {\n  if (!validateOptional(value, options)) {\n    validateString(arg, value);\n    const urlString = `http://${value}/`;\n    let parsed;\n\n    try {\n      parsed = new url_1.URL(urlString);\n    } catch (e) {\n      throw new Error(invalidArgumentMessage(arg, 'host'));\n    }\n\n    if (parsed.search !== '' || parsed.pathname !== '/' || parsed.username !== '') {\n      throw new Error(invalidArgumentMessage(arg, 'host'));\n    }\n  }\n}\n\nexports.validateHost = validateHost;\n/**\n * Validates that 'value' is a boolean.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the boolean can be omitted.\n */\n\nfunction validateBoolean(arg, value, options) {\n  if (!validateOptional(value, options)) {\n    if (typeof value !== 'boolean') {\n      throw new Error(invalidArgumentMessage(arg, 'boolean'));\n    }\n  }\n}\n\nexports.validateBoolean = validateBoolean;\n/**\n * Validates that 'value' is a number.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the number can be omitted.\n */\n\nfunction validateNumber(arg, value, options) {\n  const min = options !== undefined && options.minValue !== undefined ? options.minValue : -Infinity;\n  const max = options !== undefined && options.maxValue !== undefined ? options.maxValue : Infinity;\n\n  if (!validateOptional(value, options)) {\n    if (typeof value !== 'number' || isNaN(value)) {\n      throw new Error(invalidArgumentMessage(arg, 'number'));\n    } else if (value < min || value > max) {\n      throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);\n    }\n  }\n}\n\nexports.validateNumber = validateNumber;\n/**\n * Validates that 'value' is a integer.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the integer can be omitted.\n */\n\nfunction validateInteger(arg, value, options) {\n  const min = options !== undefined && options.minValue !== undefined ? options.minValue : -Infinity;\n  const max = options !== undefined && options.maxValue !== undefined ? options.maxValue : Infinity;\n\n  if (!validateOptional(value, options)) {\n    if (typeof value !== 'number' || isNaN(value) || value % 1 !== 0) {\n      throw new Error(invalidArgumentMessage(arg, 'integer'));\n    } else if (value < min || value > max) {\n      throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);\n    }\n  }\n}\n\nexports.validateInteger = validateInteger;\n/**\n * Generates an error message to use with invalid arguments.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param expectedType The expected input type.\n */\n\nfunction invalidArgumentMessage(arg, expectedType) {\n  return `${formatArgumentName(arg)} is not a valid ${expectedType}.`;\n}\n\nexports.invalidArgumentMessage = invalidArgumentMessage;\n/**\n * Enforces the 'options.optional' constraint for 'value'.\n *\n * @private\n * @param value The input to validate.\n * @param options Whether the function can be omitted.\n * @return Whether the object is omitted and is allowed to be omitted.\n */\n\nfunction validateOptional(value, options) {\n  return value === undefined && options !== undefined && options.optional === true;\n}\n\nexports.validateOptional = validateOptional;\n/**\n * Formats the given word as plural conditionally given the preceding number.\n *\n * @private\n * @param num The number to use for formatting.\n * @param str The string to format.\n */\n\nfunction formatPlural(num, str) {\n  return `${num} ${str}` + (num === 1 ? '' : 's');\n}\n/**\n * Creates a descriptive name for the provided argument name or index.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @return Either the argument name or its index description.\n */\n\n\nfunction formatArgumentName(arg) {\n  return typeof arg === 'string' ? `Value for argument \"${arg}\"` : `Element at index ${arg}`;\n}\n/**\n * Verifies that 'args' has at least 'minSize' elements.\n *\n * @private\n * @param funcName The function name to use in the error message.\n * @param args The array (or array-like structure) to verify.\n * @param minSize The minimum number of elements to enforce.\n * @throws if the expectation is not met.\n */\n\n\nfunction validateMinNumberOfArguments(funcName, args, minSize) {\n  if (args.length < minSize) {\n    throw new Error(`Function \"${funcName}()\" requires at least ` + `${formatPlural(minSize, 'argument')}.`);\n  }\n}\n\nexports.validateMinNumberOfArguments = validateMinNumberOfArguments;\n/**\n * Verifies that 'args' has at most 'maxSize' elements.\n *\n * @private\n * @param funcName The function name to use in the error message.\n * @param args The array (or array-like structure) to verify.\n * @param maxSize The maximum number of elements to enforce.\n * @throws if the expectation is not met.\n */\n\nfunction validateMaxNumberOfArguments(funcName, args, maxSize) {\n  if (args.length > maxSize) {\n    throw new Error(`Function \"${funcName}()\" accepts at most ` + `${formatPlural(maxSize, 'argument')}.`);\n  }\n}\n\nexports.validateMaxNumberOfArguments = validateMaxNumberOfArguments;\n/**\n * Validates that the provided named option equals one of the expected values.\n *\n * @param arg The argument name or argument index (for varargs methods).).\n * @param value The input to validate.\n * @param allowedValues A list of expected values.\n * @param options Whether the input can be omitted.\n * @private\n */\n\nfunction validateEnumValue(arg, value, allowedValues, options) {\n  if (!validateOptional(value, options)) {\n    const expectedDescription = [];\n\n    for (const allowed of allowedValues) {\n      if (allowed === value) {\n        return;\n      }\n\n      expectedDescription.push(allowed);\n    }\n\n    throw new Error(`${formatArgumentName(arg)} is invalid. Acceptable values are: ${expectedDescription.join(', ')}`);\n  }\n}\n\nexports.validateEnumValue = validateEnumValue;","map":{"version":3,"sources":["/Users/piyushmaheshwari/Downloads/github/Bridgeorg/node_modules/@google-cloud/firestore/build/src/validate.js"],"names":["Object","defineProperty","exports","value","url_1","require","util_1","customObjectMessage","arg","path","fieldPathMessage","isObject","typeName","constructor","name","invalidArgumentMessage","validateFunction","options","validateOptional","isFunction","Error","validateObject","validateString","validateHost","urlString","parsed","URL","e","search","pathname","username","validateBoolean","validateNumber","min","undefined","minValue","Infinity","max","maxValue","isNaN","formatArgumentName","validateInteger","expectedType","optional","formatPlural","num","str","validateMinNumberOfArguments","funcName","args","minSize","length","validateMaxNumberOfArguments","maxSize","validateEnumValue","allowedValues","expectedDescription","allowed","push","join"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst url_1 = require(\"url\");\nconst util_1 = require(\"./util\");\n/**\n * Generates an error message to use with custom objects that cannot be\n * serialized.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The value that failed serialization.\n * @param path The field path that the object is assigned to.\n */\nfunction customObjectMessage(arg, value, path) {\n    const fieldPathMessage = path ? ` (found in field \"${path}\")` : '';\n    if (util_1.isObject(value)) {\n        // We use the base class name as the type name as the sentinel classes\n        // returned by the public FieldValue API are subclasses of FieldValue. By\n        // using the base name, we reduce the number of special cases below.\n        const typeName = value.constructor.name;\n        switch (typeName) {\n            case 'DocumentReference':\n            case 'FieldPath':\n            case 'FieldValue':\n            case 'GeoPoint':\n            case 'Timestamp':\n                return (`${invalidArgumentMessage(arg, 'Firestore document')} Detected an object of type \"${typeName}\" that doesn't match the ` +\n                    `expected instance${fieldPathMessage}. Please ensure that the ` +\n                    'Firestore types you are using are from the same NPM package.)');\n            case 'Object':\n                return `${invalidArgumentMessage(arg, 'Firestore document')} Invalid use of type \"${typeof value}\" as a Firestore argument${fieldPathMessage}.`;\n            default:\n                return (`${invalidArgumentMessage(arg, 'Firestore document')} Couldn't serialize object of type \"${typeName}\"${fieldPathMessage}. Firestore doesn't support JavaScript ` +\n                    'objects with custom prototypes (i.e. objects that were created ' +\n                    'via the \"new\" operator).');\n        }\n    }\n    else {\n        return `${invalidArgumentMessage(arg, 'Firestore document')} Input is not a plain JavaScript object${fieldPathMessage}.`;\n    }\n}\nexports.customObjectMessage = customObjectMessage;\n/**\n * Validates that 'value' is a function.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the function can be omitted.\n */\nfunction validateFunction(arg, value, options) {\n    if (!validateOptional(value, options)) {\n        if (!util_1.isFunction(value)) {\n            throw new Error(invalidArgumentMessage(arg, 'function'));\n        }\n    }\n}\nexports.validateFunction = validateFunction;\n/**\n * Validates that 'value' is an object.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the object can be omitted.\n */\nfunction validateObject(arg, value, options) {\n    if (!validateOptional(value, options)) {\n        if (!util_1.isObject(value)) {\n            throw new Error(invalidArgumentMessage(arg, 'object'));\n        }\n    }\n}\nexports.validateObject = validateObject;\n/**\n * Validates that 'value' is a string.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the string can be omitted.\n */\nfunction validateString(arg, value, options) {\n    if (!validateOptional(value, options)) {\n        if (typeof value !== 'string') {\n            throw new Error(invalidArgumentMessage(arg, 'string'));\n        }\n    }\n}\nexports.validateString = validateString;\n/**\n * Validates that 'value' is a host.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the host can be omitted.\n */\nfunction validateHost(arg, value, options) {\n    if (!validateOptional(value, options)) {\n        validateString(arg, value);\n        const urlString = `http://${value}/`;\n        let parsed;\n        try {\n            parsed = new url_1.URL(urlString);\n        }\n        catch (e) {\n            throw new Error(invalidArgumentMessage(arg, 'host'));\n        }\n        if (parsed.search !== '' ||\n            parsed.pathname !== '/' ||\n            parsed.username !== '') {\n            throw new Error(invalidArgumentMessage(arg, 'host'));\n        }\n    }\n}\nexports.validateHost = validateHost;\n/**\n * Validates that 'value' is a boolean.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the boolean can be omitted.\n */\nfunction validateBoolean(arg, value, options) {\n    if (!validateOptional(value, options)) {\n        if (typeof value !== 'boolean') {\n            throw new Error(invalidArgumentMessage(arg, 'boolean'));\n        }\n    }\n}\nexports.validateBoolean = validateBoolean;\n/**\n * Validates that 'value' is a number.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the number can be omitted.\n */\nfunction validateNumber(arg, value, options) {\n    const min = options !== undefined && options.minValue !== undefined\n        ? options.minValue\n        : -Infinity;\n    const max = options !== undefined && options.maxValue !== undefined\n        ? options.maxValue\n        : Infinity;\n    if (!validateOptional(value, options)) {\n        if (typeof value !== 'number' || isNaN(value)) {\n            throw new Error(invalidArgumentMessage(arg, 'number'));\n        }\n        else if (value < min || value > max) {\n            throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);\n        }\n    }\n}\nexports.validateNumber = validateNumber;\n/**\n * Validates that 'value' is a integer.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the integer can be omitted.\n */\nfunction validateInteger(arg, value, options) {\n    const min = options !== undefined && options.minValue !== undefined\n        ? options.minValue\n        : -Infinity;\n    const max = options !== undefined && options.maxValue !== undefined\n        ? options.maxValue\n        : Infinity;\n    if (!validateOptional(value, options)) {\n        if (typeof value !== 'number' || isNaN(value) || value % 1 !== 0) {\n            throw new Error(invalidArgumentMessage(arg, 'integer'));\n        }\n        else if (value < min || value > max) {\n            throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);\n        }\n    }\n}\nexports.validateInteger = validateInteger;\n/**\n * Generates an error message to use with invalid arguments.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param expectedType The expected input type.\n */\nfunction invalidArgumentMessage(arg, expectedType) {\n    return `${formatArgumentName(arg)} is not a valid ${expectedType}.`;\n}\nexports.invalidArgumentMessage = invalidArgumentMessage;\n/**\n * Enforces the 'options.optional' constraint for 'value'.\n *\n * @private\n * @param value The input to validate.\n * @param options Whether the function can be omitted.\n * @return Whether the object is omitted and is allowed to be omitted.\n */\nfunction validateOptional(value, options) {\n    return (value === undefined && options !== undefined && options.optional === true);\n}\nexports.validateOptional = validateOptional;\n/**\n * Formats the given word as plural conditionally given the preceding number.\n *\n * @private\n * @param num The number to use for formatting.\n * @param str The string to format.\n */\nfunction formatPlural(num, str) {\n    return `${num} ${str}` + (num === 1 ? '' : 's');\n}\n/**\n * Creates a descriptive name for the provided argument name or index.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @return Either the argument name or its index description.\n */\nfunction formatArgumentName(arg) {\n    return typeof arg === 'string'\n        ? `Value for argument \"${arg}\"`\n        : `Element at index ${arg}`;\n}\n/**\n * Verifies that 'args' has at least 'minSize' elements.\n *\n * @private\n * @param funcName The function name to use in the error message.\n * @param args The array (or array-like structure) to verify.\n * @param minSize The minimum number of elements to enforce.\n * @throws if the expectation is not met.\n */\nfunction validateMinNumberOfArguments(funcName, args, minSize) {\n    if (args.length < minSize) {\n        throw new Error(`Function \"${funcName}()\" requires at least ` +\n            `${formatPlural(minSize, 'argument')}.`);\n    }\n}\nexports.validateMinNumberOfArguments = validateMinNumberOfArguments;\n/**\n * Verifies that 'args' has at most 'maxSize' elements.\n *\n * @private\n * @param funcName The function name to use in the error message.\n * @param args The array (or array-like structure) to verify.\n * @param maxSize The maximum number of elements to enforce.\n * @throws if the expectation is not met.\n */\nfunction validateMaxNumberOfArguments(funcName, args, maxSize) {\n    if (args.length > maxSize) {\n        throw new Error(`Function \"${funcName}()\" accepts at most ` +\n            `${formatPlural(maxSize, 'argument')}.`);\n    }\n}\nexports.validateMaxNumberOfArguments = validateMaxNumberOfArguments;\n/**\n * Validates that the provided named option equals one of the expected values.\n *\n * @param arg The argument name or argument index (for varargs methods).).\n * @param value The input to validate.\n * @param allowedValues A list of expected values.\n * @param options Whether the input can be omitted.\n * @private\n */\nfunction validateEnumValue(arg, value, allowedValues, options) {\n    if (!validateOptional(value, options)) {\n        const expectedDescription = [];\n        for (const allowed of allowedValues) {\n            if (allowed === value) {\n                return;\n            }\n            expectedDescription.push(allowed);\n        }\n        throw new Error(`${formatArgumentName(arg)} is invalid. Acceptable values are: ${expectedDescription.join(', ')}`);\n    }\n}\nexports.validateEnumValue = validateEnumValue;\n//# sourceMappingURL=validate.js.map"]},"metadata":{},"sourceType":"script"}