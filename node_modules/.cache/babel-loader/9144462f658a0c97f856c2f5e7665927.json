{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst validate_1 = require(\"./validate\");\n/*!\n * Number of nanoseconds in a millisecond.\n *\n * @type {number}\n */\n\n\nconst MS_TO_NANOS = 1000000;\n/*!\n * The minimum legal value for the \"seconds\" property of a Timestamp object.\n *\n * This value corresponds to 0001-01-01T00:00:00Z.\n *\n * @type {number}\n */\n\nconst MIN_SECONDS = -62135596800;\n/*!\n * The maximum legal value for the \"seconds\" property of a Timestamp object.\n *\n * This value corresponds to 9999-12-31T23:59:59.999999999Z.\n *\n * @type {number}\n */\n\nconst MAX_SECONDS = 253402300799;\n/**\n * A Timestamp represents a point in time independent of any time zone or\n * calendar, represented as seconds and fractions of seconds at nanosecond\n * resolution in UTC Epoch time. It is encoded using the Proleptic Gregorian\n * Calendar which extends the Gregorian calendar backwards to year one. It is\n * encoded assuming all minutes are 60 seconds long, i.e. leap seconds are\n * \"smeared\" so that no leap second table is needed for interpretation. Range is\n * from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z.\n *\n * @see https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto\n */\n\nclass Timestamp {\n  /**\n   * Creates a new timestamp.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({ startTime:new Firestore.Timestamp(42, 0) });\n   *\n   * @param {number} seconds The number of seconds of UTC time since Unix epoch\n   * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n   * 9999-12-31T23:59:59Z inclusive.\n   * @param {number} nanoseconds The non-negative fractions of a second at\n   * nanosecond resolution. Negative second values with fractions must still\n   * have non-negative nanoseconds values that count forward in time. Must be\n   * from 0 to 999,999,999 inclusive.\n   */\n  constructor(seconds, nanoseconds) {\n    validate_1.validateInteger('seconds', seconds, {\n      minValue: MIN_SECONDS,\n      maxValue: MAX_SECONDS\n    });\n    validate_1.validateInteger('nanoseconds', nanoseconds, {\n      minValue: 0,\n      maxValue: 999999999\n    });\n    this._seconds = seconds;\n    this._nanoseconds = nanoseconds;\n  }\n  /**\n   * Creates a new timestamp with the current date, with millisecond precision.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({ updateTime:Firestore.Timestamp.now() });\n   *\n   * @return {Timestamp} A new `Timestamp` representing the current date.\n   */\n\n\n  static now() {\n    return Timestamp.fromMillis(Date.now());\n  }\n  /**\n   * Creates a new timestamp from the given date.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * let date = Date.parse('01 Jan 2000 00:00:00 GMT');\n   * documentRef.set({ startTime:Firestore.Timestamp.fromDate(date) });\n   *\n   * @param {Date} date The date to initialize the `Timestamp` from.\n   * @return {Timestamp} A new `Timestamp` representing the same point in time\n   * as the given date.\n   */\n\n\n  static fromDate(date) {\n    return Timestamp.fromMillis(date.getTime());\n  }\n  /**\n   * Creates a new timestamp from the given number of milliseconds.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({ startTime:Firestore.Timestamp.fromMillis(42) });\n   *\n   * @param {number} milliseconds Number of milliseconds since Unix epoch\n   * 1970-01-01T00:00:00Z.\n   * @return {Timestamp}  A new `Timestamp` representing the same point in time\n   * as the given number of milliseconds.\n   */\n\n\n  static fromMillis(milliseconds) {\n    const seconds = Math.floor(milliseconds / 1000);\n    const nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);\n    return new Timestamp(seconds, nanos);\n  }\n  /**\n   * Generates a `Timestamp` object from a Timestamp proto.\n   *\n   * @private\n   * @param {Object} timestamp The `Timestamp` Protobuf object.\n   */\n\n\n  static fromProto(timestamp) {\n    return new Timestamp(Number(timestamp.seconds || 0), timestamp.nanos || 0);\n  }\n  /**\n   * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(snap => {\n   *   let updated = snap.updateTime;\n   *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\n   * });\n   *\n   * @type {number}\n   */\n\n\n  get seconds() {\n    return this._seconds;\n  }\n  /**\n   * The non-negative fractions of a second at nanosecond resolution.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(snap => {\n   *   let updated = snap.updateTime;\n   *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\n   * });\n   *\n   * @type {number}\n   */\n\n\n  get nanoseconds() {\n    return this._nanoseconds;\n  }\n  /**\n   * Returns a new `Date` corresponding to this timestamp. This may lose\n   * precision.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(snap => {\n   *   console.log(`Document updated at: ${snap.updateTime.toDate()}`);\n   * });\n   *\n   * @return {Date} JavaScript `Date` object representing the same point in time\n   * as this `Timestamp`, with millisecond precision.\n   */\n\n\n  toDate() {\n    return new Date(this._seconds * 1000 + Math.round(this._nanoseconds / MS_TO_NANOS));\n  }\n  /**\n   * Returns the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(snap => {\n   *   let startTime = snap.get('startTime');\n   *   let endTime = snap.get('endTime');\n   *   console.log(`Duration: ${endTime - startTime}`);\n   * });\n   *\n   * @return {number} The point in time corresponding to this timestamp,\n   * represented as the number of milliseconds since Unix epoch\n   * 1970-01-01T00:00:00Z.\n   */\n\n\n  toMillis() {\n    return this._seconds * 1000 + Math.floor(this._nanoseconds / MS_TO_NANOS);\n  }\n  /**\n   * Returns 'true' if this `Timestamp` is equal to the provided one.\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(snap => {\n   *   if (snap.createTime.isEqual(snap.updateTime)) {\n   *     console.log('Document is in its initial state.');\n   *   }\n   * });\n   *\n   * @param {any} other The `Timestamp` to compare against.\n   * @return {boolean} 'true' if this `Timestamp` is equal to the provided one.\n   */\n\n\n  isEqual(other) {\n    return this === other || other instanceof Timestamp && this._seconds === other.seconds && this._nanoseconds === other.nanoseconds;\n  }\n  /**\n   * Generates the Protobuf `Timestamp` object for this timestamp.\n   *\n   * @private\n   * @returns {Object} The `Timestamp` Protobuf object.\n   */\n\n\n  toProto() {\n    const timestamp = {};\n\n    if (this.seconds) {\n      timestamp.seconds = this.seconds.toString();\n    }\n\n    if (this.nanoseconds) {\n      timestamp.nanos = this.nanoseconds;\n    }\n\n    return {\n      timestampValue: timestamp\n    };\n  }\n  /**\n   * Converts this object to a primitive `string`, which allows `Timestamp` objects to be compared\n   * using the `>`, `<=`, `>=` and `>` operators.\n   *\n   * @return {string} a string encoding of this object.\n   */\n\n\n  valueOf() {\n    // This method returns a string of the form <seconds>.<nanoseconds> where <seconds> is\n    // translated to have a non-negative value and both <seconds> and <nanoseconds> are left-padded\n    // with zeroes to be a consistent length. Strings with this format then have a lexicographical\n    // ordering that matches the expected ordering. The <seconds> translation is done to avoid\n    // having a leading negative sign (i.e. a leading '-' character) in its string representation,\n    // which would affect its lexicographical ordering.\n    const adjustedSeconds = this.seconds - MIN_SECONDS; // Note: Up to 12 decimal digits are required to represent all valid 'seconds' values.\n\n    const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\n    const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\n    return formattedSeconds + '.' + formattedNanoseconds;\n  }\n\n}\n\nexports.Timestamp = Timestamp;","map":{"version":3,"sources":["/Users/pulkitmittal/nft-bridge/NFTbridge/node_modules/@google-cloud/firestore/build/src/timestamp.js"],"names":["Object","defineProperty","exports","value","validate_1","require","MS_TO_NANOS","MIN_SECONDS","MAX_SECONDS","Timestamp","constructor","seconds","nanoseconds","validateInteger","minValue","maxValue","_seconds","_nanoseconds","now","fromMillis","Date","fromDate","date","getTime","milliseconds","Math","floor","nanos","fromProto","timestamp","Number","toDate","round","toMillis","isEqual","other","toProto","toString","timestampValue","valueOf","adjustedSeconds","formattedSeconds","String","padStart","formattedNanoseconds"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,UAAU,GAAGC,OAAO,CAAC,YAAD,CAA1B;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,WAAW,GAAG,OAApB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,WAAW,GAAG,CAAC,WAArB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,WAAW,GAAG,YAApB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,SAAN,CAAgB;AACZ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAACC,OAAD,EAAUC,WAAV,EAAuB;AAC9BR,IAAAA,UAAU,CAACS,eAAX,CAA2B,SAA3B,EAAsCF,OAAtC,EAA+C;AAC3CG,MAAAA,QAAQ,EAAEP,WADiC;AAE3CQ,MAAAA,QAAQ,EAAEP;AAFiC,KAA/C;AAIAJ,IAAAA,UAAU,CAACS,eAAX,CAA2B,aAA3B,EAA0CD,WAA1C,EAAuD;AACnDE,MAAAA,QAAQ,EAAE,CADyC;AAEnDC,MAAAA,QAAQ,EAAE;AAFyC,KAAvD;AAIA,SAAKC,QAAL,GAAgBL,OAAhB;AACA,SAAKM,YAAL,GAAoBL,WAApB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACc,SAAHM,GAAG,GAAG;AACT,WAAOT,SAAS,CAACU,UAAV,CAAqBC,IAAI,CAACF,GAAL,EAArB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACmB,SAARG,QAAQ,CAACC,IAAD,EAAO;AAClB,WAAOb,SAAS,CAACU,UAAV,CAAqBG,IAAI,CAACC,OAAL,EAArB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACqB,SAAVJ,UAAU,CAACK,YAAD,EAAe;AAC5B,UAAMb,OAAO,GAAGc,IAAI,CAACC,KAAL,CAAWF,YAAY,GAAG,IAA1B,CAAhB;AACA,UAAMG,KAAK,GAAGF,IAAI,CAACC,KAAL,CAAW,CAACF,YAAY,GAAGb,OAAO,GAAG,IAA1B,IAAkCL,WAA7C,CAAd;AACA,WAAO,IAAIG,SAAJ,CAAcE,OAAd,EAAuBgB,KAAvB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACoB,SAATC,SAAS,CAACC,SAAD,EAAY;AACxB,WAAO,IAAIpB,SAAJ,CAAcqB,MAAM,CAACD,SAAS,CAAClB,OAAV,IAAqB,CAAtB,CAApB,EAA8CkB,SAAS,CAACF,KAAV,IAAmB,CAAjE,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACe,MAAPhB,OAAO,GAAG;AACV,WAAO,KAAKK,QAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACmB,MAAXJ,WAAW,GAAG;AACd,WAAO,KAAKK,YAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIc,EAAAA,MAAM,GAAG;AACL,WAAO,IAAIX,IAAJ,CAAS,KAAKJ,QAAL,GAAgB,IAAhB,GAAuBS,IAAI,CAACO,KAAL,CAAW,KAAKf,YAAL,GAAoBX,WAA/B,CAAhC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI2B,EAAAA,QAAQ,GAAG;AACP,WAAO,KAAKjB,QAAL,GAAgB,IAAhB,GAAuBS,IAAI,CAACC,KAAL,CAAW,KAAKT,YAAL,GAAoBX,WAA/B,CAA9B;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI4B,EAAAA,OAAO,CAACC,KAAD,EAAQ;AACX,WAAQ,SAASA,KAAT,IACHA,KAAK,YAAY1B,SAAjB,IACG,KAAKO,QAAL,KAAkBmB,KAAK,CAACxB,OAD3B,IAEG,KAAKM,YAAL,KAAsBkB,KAAK,CAACvB,WAHpC;AAIH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIwB,EAAAA,OAAO,GAAG;AACN,UAAMP,SAAS,GAAG,EAAlB;;AACA,QAAI,KAAKlB,OAAT,EAAkB;AACdkB,MAAAA,SAAS,CAAClB,OAAV,GAAoB,KAAKA,OAAL,CAAa0B,QAAb,EAApB;AACH;;AACD,QAAI,KAAKzB,WAAT,EAAsB;AAClBiB,MAAAA,SAAS,CAACF,KAAV,GAAkB,KAAKf,WAAvB;AACH;;AACD,WAAO;AAAE0B,MAAAA,cAAc,EAAET;AAAlB,KAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIU,EAAAA,OAAO,GAAG;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAMC,eAAe,GAAG,KAAK7B,OAAL,GAAeJ,WAAvC,CAPM,CAQN;;AACA,UAAMkC,gBAAgB,GAAGC,MAAM,CAACF,eAAD,CAAN,CAAwBG,QAAxB,CAAiC,EAAjC,EAAqC,GAArC,CAAzB;AACA,UAAMC,oBAAoB,GAAGF,MAAM,CAAC,KAAK9B,WAAN,CAAN,CAAyB+B,QAAzB,CAAkC,CAAlC,EAAqC,GAArC,CAA7B;AACA,WAAOF,gBAAgB,GAAG,GAAnB,GAAyBG,oBAAhC;AACH;;AAhNW;;AAkNhB1C,OAAO,CAACO,SAAR,GAAoBA,SAApB","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst validate_1 = require(\"./validate\");\n/*!\n * Number of nanoseconds in a millisecond.\n *\n * @type {number}\n */\nconst MS_TO_NANOS = 1000000;\n/*!\n * The minimum legal value for the \"seconds\" property of a Timestamp object.\n *\n * This value corresponds to 0001-01-01T00:00:00Z.\n *\n * @type {number}\n */\nconst MIN_SECONDS = -62135596800;\n/*!\n * The maximum legal value for the \"seconds\" property of a Timestamp object.\n *\n * This value corresponds to 9999-12-31T23:59:59.999999999Z.\n *\n * @type {number}\n */\nconst MAX_SECONDS = 253402300799;\n/**\n * A Timestamp represents a point in time independent of any time zone or\n * calendar, represented as seconds and fractions of seconds at nanosecond\n * resolution in UTC Epoch time. It is encoded using the Proleptic Gregorian\n * Calendar which extends the Gregorian calendar backwards to year one. It is\n * encoded assuming all minutes are 60 seconds long, i.e. leap seconds are\n * \"smeared\" so that no leap second table is needed for interpretation. Range is\n * from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z.\n *\n * @see https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto\n */\nclass Timestamp {\n    /**\n     * Creates a new timestamp.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({ startTime:new Firestore.Timestamp(42, 0) });\n     *\n     * @param {number} seconds The number of seconds of UTC time since Unix epoch\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     * 9999-12-31T23:59:59Z inclusive.\n     * @param {number} nanoseconds The non-negative fractions of a second at\n     * nanosecond resolution. Negative second values with fractions must still\n     * have non-negative nanoseconds values that count forward in time. Must be\n     * from 0 to 999,999,999 inclusive.\n     */\n    constructor(seconds, nanoseconds) {\n        validate_1.validateInteger('seconds', seconds, {\n            minValue: MIN_SECONDS,\n            maxValue: MAX_SECONDS,\n        });\n        validate_1.validateInteger('nanoseconds', nanoseconds, {\n            minValue: 0,\n            maxValue: 999999999,\n        });\n        this._seconds = seconds;\n        this._nanoseconds = nanoseconds;\n    }\n    /**\n     * Creates a new timestamp with the current date, with millisecond precision.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({ updateTime:Firestore.Timestamp.now() });\n     *\n     * @return {Timestamp} A new `Timestamp` representing the current date.\n     */\n    static now() {\n        return Timestamp.fromMillis(Date.now());\n    }\n    /**\n     * Creates a new timestamp from the given date.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * let date = Date.parse('01 Jan 2000 00:00:00 GMT');\n     * documentRef.set({ startTime:Firestore.Timestamp.fromDate(date) });\n     *\n     * @param {Date} date The date to initialize the `Timestamp` from.\n     * @return {Timestamp} A new `Timestamp` representing the same point in time\n     * as the given date.\n     */\n    static fromDate(date) {\n        return Timestamp.fromMillis(date.getTime());\n    }\n    /**\n     * Creates a new timestamp from the given number of milliseconds.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({ startTime:Firestore.Timestamp.fromMillis(42) });\n     *\n     * @param {number} milliseconds Number of milliseconds since Unix epoch\n     * 1970-01-01T00:00:00Z.\n     * @return {Timestamp}  A new `Timestamp` representing the same point in time\n     * as the given number of milliseconds.\n     */\n    static fromMillis(milliseconds) {\n        const seconds = Math.floor(milliseconds / 1000);\n        const nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);\n        return new Timestamp(seconds, nanos);\n    }\n    /**\n     * Generates a `Timestamp` object from a Timestamp proto.\n     *\n     * @private\n     * @param {Object} timestamp The `Timestamp` Protobuf object.\n     */\n    static fromProto(timestamp) {\n        return new Timestamp(Number(timestamp.seconds || 0), timestamp.nanos || 0);\n    }\n    /**\n     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(snap => {\n     *   let updated = snap.updateTime;\n     *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\n     * });\n     *\n     * @type {number}\n     */\n    get seconds() {\n        return this._seconds;\n    }\n    /**\n     * The non-negative fractions of a second at nanosecond resolution.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(snap => {\n     *   let updated = snap.updateTime;\n     *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\n     * });\n     *\n     * @type {number}\n     */\n    get nanoseconds() {\n        return this._nanoseconds;\n    }\n    /**\n     * Returns a new `Date` corresponding to this timestamp. This may lose\n     * precision.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(snap => {\n     *   console.log(`Document updated at: ${snap.updateTime.toDate()}`);\n     * });\n     *\n     * @return {Date} JavaScript `Date` object representing the same point in time\n     * as this `Timestamp`, with millisecond precision.\n     */\n    toDate() {\n        return new Date(this._seconds * 1000 + Math.round(this._nanoseconds / MS_TO_NANOS));\n    }\n    /**\n     * Returns the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(snap => {\n     *   let startTime = snap.get('startTime');\n     *   let endTime = snap.get('endTime');\n     *   console.log(`Duration: ${endTime - startTime}`);\n     * });\n     *\n     * @return {number} The point in time corresponding to this timestamp,\n     * represented as the number of milliseconds since Unix epoch\n     * 1970-01-01T00:00:00Z.\n     */\n    toMillis() {\n        return this._seconds * 1000 + Math.floor(this._nanoseconds / MS_TO_NANOS);\n    }\n    /**\n     * Returns 'true' if this `Timestamp` is equal to the provided one.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(snap => {\n     *   if (snap.createTime.isEqual(snap.updateTime)) {\n     *     console.log('Document is in its initial state.');\n     *   }\n     * });\n     *\n     * @param {any} other The `Timestamp` to compare against.\n     * @return {boolean} 'true' if this `Timestamp` is equal to the provided one.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof Timestamp &&\n                this._seconds === other.seconds &&\n                this._nanoseconds === other.nanoseconds));\n    }\n    /**\n     * Generates the Protobuf `Timestamp` object for this timestamp.\n     *\n     * @private\n     * @returns {Object} The `Timestamp` Protobuf object.\n     */\n    toProto() {\n        const timestamp = {};\n        if (this.seconds) {\n            timestamp.seconds = this.seconds.toString();\n        }\n        if (this.nanoseconds) {\n            timestamp.nanos = this.nanoseconds;\n        }\n        return { timestampValue: timestamp };\n    }\n    /**\n     * Converts this object to a primitive `string`, which allows `Timestamp` objects to be compared\n     * using the `>`, `<=`, `>=` and `>` operators.\n     *\n     * @return {string} a string encoding of this object.\n     */\n    valueOf() {\n        // This method returns a string of the form <seconds>.<nanoseconds> where <seconds> is\n        // translated to have a non-negative value and both <seconds> and <nanoseconds> are left-padded\n        // with zeroes to be a consistent length. Strings with this format then have a lexicographical\n        // ordering that matches the expected ordering. The <seconds> translation is done to avoid\n        // having a leading negative sign (i.e. a leading '-' character) in its string representation,\n        // which would affect its lexicographical ordering.\n        const adjustedSeconds = this.seconds - MIN_SECONDS;\n        // Note: Up to 12 decimal digits are required to represent all valid 'seconds' values.\n        const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\n        const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\n        return formattedSeconds + '.' + formattedNanoseconds;\n    }\n}\nexports.Timestamp = Timestamp;\n//# sourceMappingURL=timestamp.js.map"]},"metadata":{},"sourceType":"script"}