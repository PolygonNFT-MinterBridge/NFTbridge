{"ast":null,"code":"/*! firebase-admin v9.6.0 */\n\"use strict\";\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OIDCConfig = exports.SAMLConfig = exports.EmailSignInConfig = exports.validateTestPhoneNumbers = exports.MultiFactorAuthConfig = exports.MAXIMUM_TEST_PHONE_NUMBERS = void 0;\n\nvar validator = require(\"../utils/validator\");\n\nvar deep_copy_1 = require(\"../utils/deep-copy\");\n\nvar error_1 = require(\"../utils/error\");\n/** A maximum of 10 test phone number / code pairs can be configured. */\n\n\nexports.MAXIMUM_TEST_PHONE_NUMBERS = 10;\n/** Client Auth factor type to server auth factor type mapping. */\n\nvar AUTH_FACTOR_CLIENT_TO_SERVER_TYPE = {\n  phone: 'PHONE_SMS'\n};\n/** Server Auth factor type to client auth factor type mapping. */\n\nvar AUTH_FACTOR_SERVER_TO_CLIENT_TYPE = Object.keys(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE).reduce(function (res, key) {\n  res[AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[key]] = key;\n  return res;\n}, {});\n/**\n * Defines the multi-factor config class used to convert client side MultiFactorConfig\n * to a format that is understood by the Auth server.\n */\n\nvar MultiFactorAuthConfig =\n/** @class */\nfunction () {\n  /**\n   * The MultiFactorAuthConfig constructor.\n   *\n   * @param response The server side response used to initialize the\n   *     MultiFactorAuthConfig object.\n   * @constructor\n   */\n  function MultiFactorAuthConfig(response) {\n    var _this = this;\n\n    if (typeof response.state === 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor configuration response');\n    }\n\n    this.state = response.state;\n    this.factorIds = [];\n    (response.enabledProviders || []).forEach(function (enabledProvider) {\n      // Ignore unsupported types. It is possible the current admin SDK version is\n      // not up to date and newer backend types are supported.\n      if (typeof AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider] !== 'undefined') {\n        _this.factorIds.push(AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider]);\n      }\n    });\n  }\n  /**\n   * Static method to convert a client side request to a MultiFactorAuthServerConfig.\n   * Throws an error if validation fails.\n   *\n   * @param options The options object to convert to a server request.\n   * @return The resulting server request.\n   */\n\n\n  MultiFactorAuthConfig.buildServerRequest = function (options) {\n    var request = {};\n    MultiFactorAuthConfig.validate(options);\n\n    if (Object.prototype.hasOwnProperty.call(options, 'state')) {\n      request.state = options.state;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'factorIds')) {\n      (options.factorIds || []).forEach(function (factorId) {\n        if (typeof request.enabledProviders === 'undefined') {\n          request.enabledProviders = [];\n        }\n\n        request.enabledProviders.push(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId]);\n      }); // In case an empty array is passed. Ensure it gets populated so the array is cleared.\n\n      if (options.factorIds && options.factorIds.length === 0) {\n        request.enabledProviders = [];\n      }\n    }\n\n    return request;\n  };\n  /**\n   * Validates the MultiFactorConfig options object. Throws an error on failure.\n   *\n   * @param options The options object to validate.\n   */\n\n\n  MultiFactorAuthConfig.validate = function (options) {\n    var validKeys = {\n      state: true,\n      factorIds: true\n    };\n\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig\" must be a non-null object.');\n    } // Check for unsupported top level attributes.\n\n\n    for (var key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + key + \"\\\" is not a valid MultiFactorConfig parameter.\");\n      }\n    } // Validate content.\n\n\n    if (typeof options.state !== 'undefined' && options.state !== 'ENABLED' && options.state !== 'DISABLED') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.state\" must be either \"ENABLED\" or \"DISABLED\".');\n    }\n\n    if (typeof options.factorIds !== 'undefined') {\n      if (!validator.isArray(options.factorIds)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.factorIds\" must be an array of valid \"AuthFactorTypes\".');\n      } // Validate content of array.\n\n\n      options.factorIds.forEach(function (factorId) {\n        if (typeof AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId] === 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + factorId + \"\\\" is not a valid \\\"AuthFactorType\\\".\");\n        }\n      });\n    }\n  };\n  /** @return The plain object representation of the multi-factor config instance. */\n\n\n  MultiFactorAuthConfig.prototype.toJSON = function () {\n    return {\n      state: this.state,\n      factorIds: this.factorIds\n    };\n  };\n\n  return MultiFactorAuthConfig;\n}();\n\nexports.MultiFactorAuthConfig = MultiFactorAuthConfig;\n/**\n * Validates the provided map of test phone number / code pairs.\n * @param testPhoneNumbers The phone number / code pairs to validate.\n */\n\nfunction validateTestPhoneNumbers(testPhoneNumbers) {\n  if (!validator.isObject(testPhoneNumbers)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"testPhoneNumbers\" must be a map of phone number / code pairs.');\n  }\n\n  if (Object.keys(testPhoneNumbers).length > exports.MAXIMUM_TEST_PHONE_NUMBERS) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED);\n  }\n\n  for (var phoneNumber in testPhoneNumbers) {\n    // Validate phone number.\n    if (!validator.isPhoneNumber(phoneNumber)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, \"\\\"\" + phoneNumber + \"\\\" is not a valid E.164 standard compliant phone number.\");\n    } // Validate code.\n\n\n    if (!validator.isString(testPhoneNumbers[phoneNumber]) || !/^[\\d]{6}$/.test(testPhoneNumbers[phoneNumber])) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, \"\\\"\" + testPhoneNumbers[phoneNumber] + \"\\\" is not a valid 6 digit code string.\");\n    }\n  }\n}\n\nexports.validateTestPhoneNumbers = validateTestPhoneNumbers;\n/**\n * Defines the email sign-in config class used to convert client side EmailSignInConfig\n * to a format that is understood by the Auth server.\n */\n\nvar EmailSignInConfig =\n/** @class */\nfunction () {\n  /**\n   * The EmailSignInConfig constructor.\n   *\n   * @param {any} response The server side response used to initialize the\n   *     EmailSignInConfig object.\n   * @constructor\n   */\n  function EmailSignInConfig(response) {\n    if (typeof response.allowPasswordSignup === 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid email sign-in configuration response');\n    }\n\n    this.enabled = response.allowPasswordSignup;\n    this.passwordRequired = !response.enableEmailLinkSignin;\n  }\n  /**\n   * Static method to convert a client side request to a EmailSignInConfigServerRequest.\n   * Throws an error if validation fails.\n   *\n   * @param {any} options The options object to convert to a server request.\n   * @return {EmailSignInConfigServerRequest} The resulting server request.\n   */\n\n\n  EmailSignInConfig.buildServerRequest = function (options) {\n    var request = {};\n    EmailSignInConfig.validate(options);\n\n    if (Object.prototype.hasOwnProperty.call(options, 'enabled')) {\n      request.allowPasswordSignup = options.enabled;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'passwordRequired')) {\n      request.enableEmailLinkSignin = !options.passwordRequired;\n    }\n\n    return request;\n  };\n  /**\n   * Validates the EmailSignInConfig options object. Throws an error on failure.\n   *\n   * @param {any} options The options object to validate.\n   */\n\n\n  EmailSignInConfig.validate = function (options) {\n    // TODO: Validate the request.\n    var validKeys = {\n      enabled: true,\n      passwordRequired: true\n    };\n\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig\" must be a non-null object.');\n    } // Check for unsupported top level attributes.\n\n\n    for (var key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"\" + key + \"\\\" is not a valid EmailSignInConfig parameter.\");\n      }\n    } // Validate content.\n\n\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.enabled\" must be a boolean.');\n    }\n\n    if (typeof options.passwordRequired !== 'undefined' && !validator.isBoolean(options.passwordRequired)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.passwordRequired\" must be a boolean.');\n    }\n  };\n  /** @return {object} The plain object representation of the email sign-in config. */\n\n\n  EmailSignInConfig.prototype.toJSON = function () {\n    return {\n      enabled: this.enabled,\n      passwordRequired: this.passwordRequired\n    };\n  };\n\n  return EmailSignInConfig;\n}();\n\nexports.EmailSignInConfig = EmailSignInConfig;\n/**\n * Defines the SAMLConfig class used to convert a client side configuration to its\n * server side representation.\n */\n\nvar SAMLConfig =\n/** @class */\nfunction () {\n  /**\n   * The SAMLConfig constructor.\n   *\n   * @param {any} response The server side response used to initialize the SAMLConfig object.\n   * @constructor\n   */\n  function SAMLConfig(response) {\n    if (!response || !response.idpConfig || !response.idpConfig.idpEntityId || !response.idpConfig.ssoUrl || !response.spConfig || !response.spConfig.spEntityId || !response.name || !(validator.isString(response.name) && SAMLConfig.getProviderIdFromResourceName(response.name))) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n    }\n\n    var providerId = SAMLConfig.getProviderIdFromResourceName(response.name);\n\n    if (!providerId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n    }\n\n    this.providerId = providerId; // RP config.\n\n    this.rpEntityId = response.spConfig.spEntityId;\n    this.callbackURL = response.spConfig.callbackUri; // IdP config.\n\n    this.idpEntityId = response.idpConfig.idpEntityId;\n    this.ssoURL = response.idpConfig.ssoUrl;\n    this.enableRequestSigning = !!response.idpConfig.signRequest;\n    var x509Certificates = [];\n\n    for (var _i = 0, _a = response.idpConfig.idpCertificates || []; _i < _a.length; _i++) {\n      var cert = _a[_i];\n\n      if (cert.x509Certificate) {\n        x509Certificates.push(cert.x509Certificate);\n      }\n    }\n\n    this.x509Certificates = x509Certificates; // When enabled is undefined, it takes its default value of false.\n\n    this.enabled = !!response.enabled;\n    this.displayName = response.displayName;\n  }\n  /**\n   * Converts a client side request to a SAMLConfigServerRequest which is the format\n   * accepted by the backend server.\n   * Throws an error if validation fails. If the request is not a SAMLConfig request,\n   * returns null.\n   *\n   * @param {SAMLAuthProviderRequest} options The options object to convert to a server request.\n   * @param {boolean=} ignoreMissingFields Whether to ignore missing fields.\n   * @return {?SAMLConfigServerRequest} The resulting server request or null if not valid.\n   */\n\n\n  SAMLConfig.buildServerRequest = function (options, ignoreMissingFields) {\n    if (ignoreMissingFields === void 0) {\n      ignoreMissingFields = false;\n    }\n\n    var makeRequest = validator.isNonNullObject(options) && (options.providerId || ignoreMissingFields);\n\n    if (!makeRequest) {\n      return null;\n    }\n\n    var request = {}; // Validate options.\n\n    SAMLConfig.validate(options, ignoreMissingFields);\n    request.enabled = options.enabled;\n    request.displayName = options.displayName; // IdP config.\n\n    if (options.idpEntityId || options.ssoURL || options.x509Certificates) {\n      request.idpConfig = {\n        idpEntityId: options.idpEntityId,\n        ssoUrl: options.ssoURL,\n        signRequest: options.enableRequestSigning,\n        idpCertificates: typeof options.x509Certificates === 'undefined' ? undefined : []\n      };\n\n      if (options.x509Certificates) {\n        for (var _i = 0, _a = options.x509Certificates || []; _i < _a.length; _i++) {\n          var cert = _a[_i];\n          request.idpConfig.idpCertificates.push({\n            x509Certificate: cert\n          });\n        }\n      }\n    } // RP config.\n\n\n    if (options.callbackURL || options.rpEntityId) {\n      request.spConfig = {\n        spEntityId: options.rpEntityId,\n        callbackUri: options.callbackURL\n      };\n    }\n\n    return request;\n  };\n  /**\n   * Returns the provider ID corresponding to the resource name if available.\n   *\n   * @param {string} resourceName The server side resource name.\n   * @return {?string} The provider ID corresponding to the resource, null otherwise.\n   */\n\n\n  SAMLConfig.getProviderIdFromResourceName = function (resourceName) {\n    // name is of form projects/project1/inboundSamlConfigs/providerId1\n    var matchProviderRes = resourceName.match(/\\/inboundSamlConfigs\\/(saml\\..*)$/);\n\n    if (!matchProviderRes || matchProviderRes.length < 2) {\n      return null;\n    }\n\n    return matchProviderRes[1];\n  };\n  /**\n   * @param {any} providerId The provider ID to check.\n   * @return {boolean} Whether the provider ID corresponds to a SAML provider.\n   */\n\n\n  SAMLConfig.isProviderId = function (providerId) {\n    return validator.isNonEmptyString(providerId) && providerId.indexOf('saml.') === 0;\n  };\n  /**\n   * Validates the SAMLConfig options object. Throws an error on failure.\n   *\n   * @param {SAMLAuthProviderRequest} options The options object to validate.\n   * @param {boolean=} ignoreMissingFields Whether to ignore missing fields.\n   */\n\n\n  SAMLConfig.validate = function (options, ignoreMissingFields) {\n    if (ignoreMissingFields === void 0) {\n      ignoreMissingFields = false;\n    }\n\n    var validKeys = {\n      enabled: true,\n      displayName: true,\n      providerId: true,\n      idpEntityId: true,\n      ssoURL: true,\n      x509Certificates: true,\n      rpEntityId: true,\n      callbackURL: true,\n      enableRequestSigning: true\n    };\n\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig\" must be a valid non-null object.');\n    } // Check for unsupported top level attributes.\n\n\n    for (var key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + key + \"\\\" is not a valid SAML config parameter.\");\n      }\n    } // Required fields.\n\n\n    if (validator.isNonEmptyString(options.providerId)) {\n      if (options.providerId.indexOf('saml.') !== 0) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n      }\n    } else if (!ignoreMissingFields) {\n      // providerId is required and not provided correctly.\n      throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n    }\n\n    if (!(ignoreMissingFields && typeof options.idpEntityId === 'undefined') && !validator.isNonEmptyString(options.idpEntityId)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.idpEntityId\" must be a valid non-empty string.');\n    }\n\n    if (!(ignoreMissingFields && typeof options.ssoURL === 'undefined') && !validator.isURL(options.ssoURL)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.ssoURL\" must be a valid URL string.');\n    }\n\n    if (!(ignoreMissingFields && typeof options.rpEntityId === 'undefined') && !validator.isNonEmptyString(options.rpEntityId)) {\n      throw new error_1.FirebaseAuthError(!options.rpEntityId ? error_1.AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.rpEntityId\" must be a valid non-empty string.');\n    }\n\n    if (!(ignoreMissingFields && typeof options.callbackURL === 'undefined') && !validator.isURL(options.callbackURL)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.callbackURL\" must be a valid URL string.');\n    }\n\n    if (!(ignoreMissingFields && typeof options.x509Certificates === 'undefined') && !validator.isArray(options.x509Certificates)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n    }\n\n    (options.x509Certificates || []).forEach(function (cert) {\n      if (!validator.isNonEmptyString(cert)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n      }\n    });\n\n    if (typeof options.enableRequestSigning !== 'undefined' && !validator.isBoolean(options.enableRequestSigning)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enableRequestSigning\" must be a boolean.');\n    }\n\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enabled\" must be a boolean.');\n    }\n\n    if (typeof options.displayName !== 'undefined' && !validator.isString(options.displayName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.displayName\" must be a valid string.');\n    }\n  };\n  /** @return The plain object representation of the SAMLConfig. */\n\n\n  SAMLConfig.prototype.toJSON = function () {\n    return {\n      enabled: this.enabled,\n      displayName: this.displayName,\n      providerId: this.providerId,\n      idpEntityId: this.idpEntityId,\n      ssoURL: this.ssoURL,\n      x509Certificates: deep_copy_1.deepCopy(this.x509Certificates),\n      rpEntityId: this.rpEntityId,\n      callbackURL: this.callbackURL,\n      enableRequestSigning: this.enableRequestSigning\n    };\n  };\n\n  return SAMLConfig;\n}();\n\nexports.SAMLConfig = SAMLConfig;\n/**\n * Defines the OIDCConfig class used to convert a client side configuration to its\n * server side representation.\n */\n\nvar OIDCConfig =\n/** @class */\nfunction () {\n  /**\n   * The OIDCConfig constructor.\n   *\n   * @param {any} response The server side response used to initialize the OIDCConfig object.\n   * @constructor\n   */\n  function OIDCConfig(response) {\n    if (!response || !response.issuer || !response.clientId || !response.name || !(validator.isString(response.name) && OIDCConfig.getProviderIdFromResourceName(response.name))) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid OIDC configuration response');\n    }\n\n    var providerId = OIDCConfig.getProviderIdFromResourceName(response.name);\n\n    if (!providerId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n    }\n\n    this.providerId = providerId;\n    this.clientId = response.clientId;\n    this.issuer = response.issuer; // When enabled is undefined, it takes its default value of false.\n\n    this.enabled = !!response.enabled;\n    this.displayName = response.displayName;\n  }\n  /**\n   * Converts a client side request to a OIDCConfigServerRequest which is the format\n   * accepted by the backend server.\n   * Throws an error if validation fails. If the request is not a OIDCConfig request,\n   * returns null.\n   *\n   * @param options The options object to convert to a server request.\n   * @param ignoreMissingFields Whether to ignore missing fields.\n   * @return The resulting server request or null if not valid.\n   */\n\n\n  OIDCConfig.buildServerRequest = function (options, ignoreMissingFields) {\n    if (ignoreMissingFields === void 0) {\n      ignoreMissingFields = false;\n    }\n\n    var makeRequest = validator.isNonNullObject(options) && (options.providerId || ignoreMissingFields);\n\n    if (!makeRequest) {\n      return null;\n    }\n\n    var request = {}; // Validate options.\n\n    OIDCConfig.validate(options, ignoreMissingFields);\n    request.enabled = options.enabled;\n    request.displayName = options.displayName;\n    request.issuer = options.issuer;\n    request.clientId = options.clientId;\n    return request;\n  };\n  /**\n   * Returns the provider ID corresponding to the resource name if available.\n   *\n   * @param {string} resourceName The server side resource name\n   * @return {?string} The provider ID corresponding to the resource, null otherwise.\n   */\n\n\n  OIDCConfig.getProviderIdFromResourceName = function (resourceName) {\n    // name is of form projects/project1/oauthIdpConfigs/providerId1\n    var matchProviderRes = resourceName.match(/\\/oauthIdpConfigs\\/(oidc\\..*)$/);\n\n    if (!matchProviderRes || matchProviderRes.length < 2) {\n      return null;\n    }\n\n    return matchProviderRes[1];\n  };\n  /**\n   * @param {any} providerId The provider ID to check.\n   * @return {boolean} Whether the provider ID corresponds to an OIDC provider.\n   */\n\n\n  OIDCConfig.isProviderId = function (providerId) {\n    return validator.isNonEmptyString(providerId) && providerId.indexOf('oidc.') === 0;\n  };\n  /**\n   * Validates the OIDCConfig options object. Throws an error on failure.\n   *\n   * @param options The options object to validate.\n   * @param ignoreMissingFields Whether to ignore missing fields.\n   */\n\n\n  OIDCConfig.validate = function (options, ignoreMissingFields) {\n    if (ignoreMissingFields === void 0) {\n      ignoreMissingFields = false;\n    }\n\n    var validKeys = {\n      enabled: true,\n      displayName: true,\n      providerId: true,\n      clientId: true,\n      issuer: true\n    };\n\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig\" must be a valid non-null object.');\n    } // Check for unsupported top level attributes.\n\n\n    for (var key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + key + \"\\\" is not a valid OIDC config parameter.\");\n      }\n    } // Required fields.\n\n\n    if (validator.isNonEmptyString(options.providerId)) {\n      if (options.providerId.indexOf('oidc.') !== 0) {\n        throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n      }\n    } else if (!ignoreMissingFields) {\n      throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n    }\n\n    if (!(ignoreMissingFields && typeof options.clientId === 'undefined') && !validator.isNonEmptyString(options.clientId)) {\n      throw new error_1.FirebaseAuthError(!options.clientId ? error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID : error_1.AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID, '\"OIDCAuthProviderConfig.clientId\" must be a valid non-empty string.');\n    }\n\n    if (!(ignoreMissingFields && typeof options.issuer === 'undefined') && !validator.isURL(options.issuer)) {\n      throw new error_1.FirebaseAuthError(!options.issuer ? error_1.AuthClientErrorCode.MISSING_ISSUER : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.issuer\" must be a valid URL string.');\n    }\n\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.enabled\" must be a boolean.');\n    }\n\n    if (typeof options.displayName !== 'undefined' && !validator.isString(options.displayName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.displayName\" must be a valid string.');\n    }\n  };\n  /** @return {OIDCAuthProviderConfig} The plain object representation of the OIDCConfig. */\n\n\n  OIDCConfig.prototype.toJSON = function () {\n    return {\n      enabled: this.enabled,\n      displayName: this.displayName,\n      providerId: this.providerId,\n      issuer: this.issuer,\n      clientId: this.clientId\n    };\n  };\n\n  return OIDCConfig;\n}();\n\nexports.OIDCConfig = OIDCConfig;","map":{"version":3,"sources":["/Users/pulkitmittal/nft-bridge/NFTbridge/node_modules/firebase-admin/lib/auth/auth-config.js"],"names":["Object","defineProperty","exports","value","OIDCConfig","SAMLConfig","EmailSignInConfig","validateTestPhoneNumbers","MultiFactorAuthConfig","MAXIMUM_TEST_PHONE_NUMBERS","validator","require","deep_copy_1","error_1","AUTH_FACTOR_CLIENT_TO_SERVER_TYPE","phone","AUTH_FACTOR_SERVER_TO_CLIENT_TYPE","keys","reduce","res","key","response","_this","state","FirebaseAuthError","AuthClientErrorCode","INTERNAL_ERROR","factorIds","enabledProviders","forEach","enabledProvider","push","buildServerRequest","options","request","validate","prototype","hasOwnProperty","call","factorId","length","validKeys","isNonNullObject","INVALID_CONFIG","isArray","toJSON","testPhoneNumbers","isObject","INVALID_ARGUMENT","MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED","phoneNumber","isPhoneNumber","INVALID_TESTING_PHONE_NUMBER","isString","test","allowPasswordSignup","enabled","passwordRequired","enableEmailLinkSignin","isBoolean","idpConfig","idpEntityId","ssoUrl","spConfig","spEntityId","name","getProviderIdFromResourceName","providerId","rpEntityId","callbackURL","callbackUri","ssoURL","enableRequestSigning","signRequest","x509Certificates","_i","_a","idpCertificates","cert","x509Certificate","displayName","ignoreMissingFields","makeRequest","undefined","resourceName","matchProviderRes","match","isProviderId","isNonEmptyString","indexOf","INVALID_PROVIDER_ID","MISSING_PROVIDER_ID","isURL","MISSING_SAML_RELYING_PARTY_CONFIG","deepCopy","issuer","clientId","MISSING_OAUTH_CLIENT_ID","INVALID_OAUTH_CLIENT_ID","MISSING_ISSUER"],"mappings":"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","sourcesContent":["/*! firebase-admin v9.6.0 */\n\"use strict\";\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OIDCConfig = exports.SAMLConfig = exports.EmailSignInConfig = exports.validateTestPhoneNumbers = exports.MultiFactorAuthConfig = exports.MAXIMUM_TEST_PHONE_NUMBERS = void 0;\nvar validator = require(\"../utils/validator\");\nvar deep_copy_1 = require(\"../utils/deep-copy\");\nvar error_1 = require(\"../utils/error\");\n/** A maximum of 10 test phone number / code pairs can be configured. */\nexports.MAXIMUM_TEST_PHONE_NUMBERS = 10;\n/** Client Auth factor type to server auth factor type mapping. */\nvar AUTH_FACTOR_CLIENT_TO_SERVER_TYPE = {\n    phone: 'PHONE_SMS',\n};\n/** Server Auth factor type to client auth factor type mapping. */\nvar AUTH_FACTOR_SERVER_TO_CLIENT_TYPE = Object.keys(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE)\n    .reduce(function (res, key) {\n    res[AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[key]] = key;\n    return res;\n}, {});\n/**\n * Defines the multi-factor config class used to convert client side MultiFactorConfig\n * to a format that is understood by the Auth server.\n */\nvar MultiFactorAuthConfig = /** @class */ (function () {\n    /**\n     * The MultiFactorAuthConfig constructor.\n     *\n     * @param response The server side response used to initialize the\n     *     MultiFactorAuthConfig object.\n     * @constructor\n     */\n    function MultiFactorAuthConfig(response) {\n        var _this = this;\n        if (typeof response.state === 'undefined') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor configuration response');\n        }\n        this.state = response.state;\n        this.factorIds = [];\n        (response.enabledProviders || []).forEach(function (enabledProvider) {\n            // Ignore unsupported types. It is possible the current admin SDK version is\n            // not up to date and newer backend types are supported.\n            if (typeof AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider] !== 'undefined') {\n                _this.factorIds.push(AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider]);\n            }\n        });\n    }\n    /**\n     * Static method to convert a client side request to a MultiFactorAuthServerConfig.\n     * Throws an error if validation fails.\n     *\n     * @param options The options object to convert to a server request.\n     * @return The resulting server request.\n     */\n    MultiFactorAuthConfig.buildServerRequest = function (options) {\n        var request = {};\n        MultiFactorAuthConfig.validate(options);\n        if (Object.prototype.hasOwnProperty.call(options, 'state')) {\n            request.state = options.state;\n        }\n        if (Object.prototype.hasOwnProperty.call(options, 'factorIds')) {\n            (options.factorIds || []).forEach(function (factorId) {\n                if (typeof request.enabledProviders === 'undefined') {\n                    request.enabledProviders = [];\n                }\n                request.enabledProviders.push(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId]);\n            });\n            // In case an empty array is passed. Ensure it gets populated so the array is cleared.\n            if (options.factorIds && options.factorIds.length === 0) {\n                request.enabledProviders = [];\n            }\n        }\n        return request;\n    };\n    /**\n     * Validates the MultiFactorConfig options object. Throws an error on failure.\n     *\n     * @param options The options object to validate.\n     */\n    MultiFactorAuthConfig.validate = function (options) {\n        var validKeys = {\n            state: true,\n            factorIds: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig\" must be a non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (var key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + key + \"\\\" is not a valid MultiFactorConfig parameter.\");\n            }\n        }\n        // Validate content.\n        if (typeof options.state !== 'undefined' &&\n            options.state !== 'ENABLED' &&\n            options.state !== 'DISABLED') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.state\" must be either \"ENABLED\" or \"DISABLED\".');\n        }\n        if (typeof options.factorIds !== 'undefined') {\n            if (!validator.isArray(options.factorIds)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.factorIds\" must be an array of valid \"AuthFactorTypes\".');\n            }\n            // Validate content of array.\n            options.factorIds.forEach(function (factorId) {\n                if (typeof AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId] === 'undefined') {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + factorId + \"\\\" is not a valid \\\"AuthFactorType\\\".\");\n                }\n            });\n        }\n    };\n    /** @return The plain object representation of the multi-factor config instance. */\n    MultiFactorAuthConfig.prototype.toJSON = function () {\n        return {\n            state: this.state,\n            factorIds: this.factorIds,\n        };\n    };\n    return MultiFactorAuthConfig;\n}());\nexports.MultiFactorAuthConfig = MultiFactorAuthConfig;\n/**\n * Validates the provided map of test phone number / code pairs.\n * @param testPhoneNumbers The phone number / code pairs to validate.\n */\nfunction validateTestPhoneNumbers(testPhoneNumbers) {\n    if (!validator.isObject(testPhoneNumbers)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"testPhoneNumbers\" must be a map of phone number / code pairs.');\n    }\n    if (Object.keys(testPhoneNumbers).length > exports.MAXIMUM_TEST_PHONE_NUMBERS) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED);\n    }\n    for (var phoneNumber in testPhoneNumbers) {\n        // Validate phone number.\n        if (!validator.isPhoneNumber(phoneNumber)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, \"\\\"\" + phoneNumber + \"\\\" is not a valid E.164 standard compliant phone number.\");\n        }\n        // Validate code.\n        if (!validator.isString(testPhoneNumbers[phoneNumber]) ||\n            !/^[\\d]{6}$/.test(testPhoneNumbers[phoneNumber])) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, \"\\\"\" + testPhoneNumbers[phoneNumber] + \"\\\" is not a valid 6 digit code string.\");\n        }\n    }\n}\nexports.validateTestPhoneNumbers = validateTestPhoneNumbers;\n/**\n * Defines the email sign-in config class used to convert client side EmailSignInConfig\n * to a format that is understood by the Auth server.\n */\nvar EmailSignInConfig = /** @class */ (function () {\n    /**\n     * The EmailSignInConfig constructor.\n     *\n     * @param {any} response The server side response used to initialize the\n     *     EmailSignInConfig object.\n     * @constructor\n     */\n    function EmailSignInConfig(response) {\n        if (typeof response.allowPasswordSignup === 'undefined') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid email sign-in configuration response');\n        }\n        this.enabled = response.allowPasswordSignup;\n        this.passwordRequired = !response.enableEmailLinkSignin;\n    }\n    /**\n     * Static method to convert a client side request to a EmailSignInConfigServerRequest.\n     * Throws an error if validation fails.\n     *\n     * @param {any} options The options object to convert to a server request.\n     * @return {EmailSignInConfigServerRequest} The resulting server request.\n     */\n    EmailSignInConfig.buildServerRequest = function (options) {\n        var request = {};\n        EmailSignInConfig.validate(options);\n        if (Object.prototype.hasOwnProperty.call(options, 'enabled')) {\n            request.allowPasswordSignup = options.enabled;\n        }\n        if (Object.prototype.hasOwnProperty.call(options, 'passwordRequired')) {\n            request.enableEmailLinkSignin = !options.passwordRequired;\n        }\n        return request;\n    };\n    /**\n     * Validates the EmailSignInConfig options object. Throws an error on failure.\n     *\n     * @param {any} options The options object to validate.\n     */\n    EmailSignInConfig.validate = function (options) {\n        // TODO: Validate the request.\n        var validKeys = {\n            enabled: true,\n            passwordRequired: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig\" must be a non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (var key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"\" + key + \"\\\" is not a valid EmailSignInConfig parameter.\");\n            }\n        }\n        // Validate content.\n        if (typeof options.enabled !== 'undefined' &&\n            !validator.isBoolean(options.enabled)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.enabled\" must be a boolean.');\n        }\n        if (typeof options.passwordRequired !== 'undefined' &&\n            !validator.isBoolean(options.passwordRequired)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.passwordRequired\" must be a boolean.');\n        }\n    };\n    /** @return {object} The plain object representation of the email sign-in config. */\n    EmailSignInConfig.prototype.toJSON = function () {\n        return {\n            enabled: this.enabled,\n            passwordRequired: this.passwordRequired,\n        };\n    };\n    return EmailSignInConfig;\n}());\nexports.EmailSignInConfig = EmailSignInConfig;\n/**\n * Defines the SAMLConfig class used to convert a client side configuration to its\n * server side representation.\n */\nvar SAMLConfig = /** @class */ (function () {\n    /**\n     * The SAMLConfig constructor.\n     *\n     * @param {any} response The server side response used to initialize the SAMLConfig object.\n     * @constructor\n     */\n    function SAMLConfig(response) {\n        if (!response ||\n            !response.idpConfig ||\n            !response.idpConfig.idpEntityId ||\n            !response.idpConfig.ssoUrl ||\n            !response.spConfig ||\n            !response.spConfig.spEntityId ||\n            !response.name ||\n            !(validator.isString(response.name) &&\n                SAMLConfig.getProviderIdFromResourceName(response.name))) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n        }\n        var providerId = SAMLConfig.getProviderIdFromResourceName(response.name);\n        if (!providerId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n        }\n        this.providerId = providerId;\n        // RP config.\n        this.rpEntityId = response.spConfig.spEntityId;\n        this.callbackURL = response.spConfig.callbackUri;\n        // IdP config.\n        this.idpEntityId = response.idpConfig.idpEntityId;\n        this.ssoURL = response.idpConfig.ssoUrl;\n        this.enableRequestSigning = !!response.idpConfig.signRequest;\n        var x509Certificates = [];\n        for (var _i = 0, _a = (response.idpConfig.idpCertificates || []); _i < _a.length; _i++) {\n            var cert = _a[_i];\n            if (cert.x509Certificate) {\n                x509Certificates.push(cert.x509Certificate);\n            }\n        }\n        this.x509Certificates = x509Certificates;\n        // When enabled is undefined, it takes its default value of false.\n        this.enabled = !!response.enabled;\n        this.displayName = response.displayName;\n    }\n    /**\n     * Converts a client side request to a SAMLConfigServerRequest which is the format\n     * accepted by the backend server.\n     * Throws an error if validation fails. If the request is not a SAMLConfig request,\n     * returns null.\n     *\n     * @param {SAMLAuthProviderRequest} options The options object to convert to a server request.\n     * @param {boolean=} ignoreMissingFields Whether to ignore missing fields.\n     * @return {?SAMLConfigServerRequest} The resulting server request or null if not valid.\n     */\n    SAMLConfig.buildServerRequest = function (options, ignoreMissingFields) {\n        if (ignoreMissingFields === void 0) { ignoreMissingFields = false; }\n        var makeRequest = validator.isNonNullObject(options) &&\n            (options.providerId || ignoreMissingFields);\n        if (!makeRequest) {\n            return null;\n        }\n        var request = {};\n        // Validate options.\n        SAMLConfig.validate(options, ignoreMissingFields);\n        request.enabled = options.enabled;\n        request.displayName = options.displayName;\n        // IdP config.\n        if (options.idpEntityId || options.ssoURL || options.x509Certificates) {\n            request.idpConfig = {\n                idpEntityId: options.idpEntityId,\n                ssoUrl: options.ssoURL,\n                signRequest: options.enableRequestSigning,\n                idpCertificates: typeof options.x509Certificates === 'undefined' ? undefined : [],\n            };\n            if (options.x509Certificates) {\n                for (var _i = 0, _a = (options.x509Certificates || []); _i < _a.length; _i++) {\n                    var cert = _a[_i];\n                    request.idpConfig.idpCertificates.push({ x509Certificate: cert });\n                }\n            }\n        }\n        // RP config.\n        if (options.callbackURL || options.rpEntityId) {\n            request.spConfig = {\n                spEntityId: options.rpEntityId,\n                callbackUri: options.callbackURL,\n            };\n        }\n        return request;\n    };\n    /**\n     * Returns the provider ID corresponding to the resource name if available.\n     *\n     * @param {string} resourceName The server side resource name.\n     * @return {?string} The provider ID corresponding to the resource, null otherwise.\n     */\n    SAMLConfig.getProviderIdFromResourceName = function (resourceName) {\n        // name is of form projects/project1/inboundSamlConfigs/providerId1\n        var matchProviderRes = resourceName.match(/\\/inboundSamlConfigs\\/(saml\\..*)$/);\n        if (!matchProviderRes || matchProviderRes.length < 2) {\n            return null;\n        }\n        return matchProviderRes[1];\n    };\n    /**\n     * @param {any} providerId The provider ID to check.\n     * @return {boolean} Whether the provider ID corresponds to a SAML provider.\n     */\n    SAMLConfig.isProviderId = function (providerId) {\n        return validator.isNonEmptyString(providerId) && providerId.indexOf('saml.') === 0;\n    };\n    /**\n     * Validates the SAMLConfig options object. Throws an error on failure.\n     *\n     * @param {SAMLAuthProviderRequest} options The options object to validate.\n     * @param {boolean=} ignoreMissingFields Whether to ignore missing fields.\n     */\n    SAMLConfig.validate = function (options, ignoreMissingFields) {\n        if (ignoreMissingFields === void 0) { ignoreMissingFields = false; }\n        var validKeys = {\n            enabled: true,\n            displayName: true,\n            providerId: true,\n            idpEntityId: true,\n            ssoURL: true,\n            x509Certificates: true,\n            rpEntityId: true,\n            callbackURL: true,\n            enableRequestSigning: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig\" must be a valid non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (var key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + key + \"\\\" is not a valid SAML config parameter.\");\n            }\n        }\n        // Required fields.\n        if (validator.isNonEmptyString(options.providerId)) {\n            if (options.providerId.indexOf('saml.') !== 0) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n            }\n        }\n        else if (!ignoreMissingFields) {\n            // providerId is required and not provided correctly.\n            throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n        }\n        if (!(ignoreMissingFields && typeof options.idpEntityId === 'undefined') &&\n            !validator.isNonEmptyString(options.idpEntityId)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.idpEntityId\" must be a valid non-empty string.');\n        }\n        if (!(ignoreMissingFields && typeof options.ssoURL === 'undefined') &&\n            !validator.isURL(options.ssoURL)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.ssoURL\" must be a valid URL string.');\n        }\n        if (!(ignoreMissingFields && typeof options.rpEntityId === 'undefined') &&\n            !validator.isNonEmptyString(options.rpEntityId)) {\n            throw new error_1.FirebaseAuthError(!options.rpEntityId ? error_1.AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG :\n                error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.rpEntityId\" must be a valid non-empty string.');\n        }\n        if (!(ignoreMissingFields && typeof options.callbackURL === 'undefined') &&\n            !validator.isURL(options.callbackURL)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.callbackURL\" must be a valid URL string.');\n        }\n        if (!(ignoreMissingFields && typeof options.x509Certificates === 'undefined') &&\n            !validator.isArray(options.x509Certificates)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n        }\n        (options.x509Certificates || []).forEach(function (cert) {\n            if (!validator.isNonEmptyString(cert)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n            }\n        });\n        if (typeof options.enableRequestSigning !== 'undefined' &&\n            !validator.isBoolean(options.enableRequestSigning)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enableRequestSigning\" must be a boolean.');\n        }\n        if (typeof options.enabled !== 'undefined' &&\n            !validator.isBoolean(options.enabled)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enabled\" must be a boolean.');\n        }\n        if (typeof options.displayName !== 'undefined' &&\n            !validator.isString(options.displayName)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.displayName\" must be a valid string.');\n        }\n    };\n    /** @return The plain object representation of the SAMLConfig. */\n    SAMLConfig.prototype.toJSON = function () {\n        return {\n            enabled: this.enabled,\n            displayName: this.displayName,\n            providerId: this.providerId,\n            idpEntityId: this.idpEntityId,\n            ssoURL: this.ssoURL,\n            x509Certificates: deep_copy_1.deepCopy(this.x509Certificates),\n            rpEntityId: this.rpEntityId,\n            callbackURL: this.callbackURL,\n            enableRequestSigning: this.enableRequestSigning,\n        };\n    };\n    return SAMLConfig;\n}());\nexports.SAMLConfig = SAMLConfig;\n/**\n * Defines the OIDCConfig class used to convert a client side configuration to its\n * server side representation.\n */\nvar OIDCConfig = /** @class */ (function () {\n    /**\n     * The OIDCConfig constructor.\n     *\n     * @param {any} response The server side response used to initialize the OIDCConfig object.\n     * @constructor\n     */\n    function OIDCConfig(response) {\n        if (!response ||\n            !response.issuer ||\n            !response.clientId ||\n            !response.name ||\n            !(validator.isString(response.name) &&\n                OIDCConfig.getProviderIdFromResourceName(response.name))) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid OIDC configuration response');\n        }\n        var providerId = OIDCConfig.getProviderIdFromResourceName(response.name);\n        if (!providerId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n        }\n        this.providerId = providerId;\n        this.clientId = response.clientId;\n        this.issuer = response.issuer;\n        // When enabled is undefined, it takes its default value of false.\n        this.enabled = !!response.enabled;\n        this.displayName = response.displayName;\n    }\n    /**\n     * Converts a client side request to a OIDCConfigServerRequest which is the format\n     * accepted by the backend server.\n     * Throws an error if validation fails. If the request is not a OIDCConfig request,\n     * returns null.\n     *\n     * @param options The options object to convert to a server request.\n     * @param ignoreMissingFields Whether to ignore missing fields.\n     * @return The resulting server request or null if not valid.\n     */\n    OIDCConfig.buildServerRequest = function (options, ignoreMissingFields) {\n        if (ignoreMissingFields === void 0) { ignoreMissingFields = false; }\n        var makeRequest = validator.isNonNullObject(options) &&\n            (options.providerId || ignoreMissingFields);\n        if (!makeRequest) {\n            return null;\n        }\n        var request = {};\n        // Validate options.\n        OIDCConfig.validate(options, ignoreMissingFields);\n        request.enabled = options.enabled;\n        request.displayName = options.displayName;\n        request.issuer = options.issuer;\n        request.clientId = options.clientId;\n        return request;\n    };\n    /**\n     * Returns the provider ID corresponding to the resource name if available.\n     *\n     * @param {string} resourceName The server side resource name\n     * @return {?string} The provider ID corresponding to the resource, null otherwise.\n     */\n    OIDCConfig.getProviderIdFromResourceName = function (resourceName) {\n        // name is of form projects/project1/oauthIdpConfigs/providerId1\n        var matchProviderRes = resourceName.match(/\\/oauthIdpConfigs\\/(oidc\\..*)$/);\n        if (!matchProviderRes || matchProviderRes.length < 2) {\n            return null;\n        }\n        return matchProviderRes[1];\n    };\n    /**\n     * @param {any} providerId The provider ID to check.\n     * @return {boolean} Whether the provider ID corresponds to an OIDC provider.\n     */\n    OIDCConfig.isProviderId = function (providerId) {\n        return validator.isNonEmptyString(providerId) && providerId.indexOf('oidc.') === 0;\n    };\n    /**\n     * Validates the OIDCConfig options object. Throws an error on failure.\n     *\n     * @param options The options object to validate.\n     * @param ignoreMissingFields Whether to ignore missing fields.\n     */\n    OIDCConfig.validate = function (options, ignoreMissingFields) {\n        if (ignoreMissingFields === void 0) { ignoreMissingFields = false; }\n        var validKeys = {\n            enabled: true,\n            displayName: true,\n            providerId: true,\n            clientId: true,\n            issuer: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig\" must be a valid non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (var key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + key + \"\\\" is not a valid OIDC config parameter.\");\n            }\n        }\n        // Required fields.\n        if (validator.isNonEmptyString(options.providerId)) {\n            if (options.providerId.indexOf('oidc.') !== 0) {\n                throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n            }\n        }\n        else if (!ignoreMissingFields) {\n            throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n        }\n        if (!(ignoreMissingFields && typeof options.clientId === 'undefined') &&\n            !validator.isNonEmptyString(options.clientId)) {\n            throw new error_1.FirebaseAuthError(!options.clientId ? error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID : error_1.AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID, '\"OIDCAuthProviderConfig.clientId\" must be a valid non-empty string.');\n        }\n        if (!(ignoreMissingFields && typeof options.issuer === 'undefined') &&\n            !validator.isURL(options.issuer)) {\n            throw new error_1.FirebaseAuthError(!options.issuer ? error_1.AuthClientErrorCode.MISSING_ISSUER : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.issuer\" must be a valid URL string.');\n        }\n        if (typeof options.enabled !== 'undefined' &&\n            !validator.isBoolean(options.enabled)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.enabled\" must be a boolean.');\n        }\n        if (typeof options.displayName !== 'undefined' &&\n            !validator.isString(options.displayName)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.displayName\" must be a valid string.');\n        }\n    };\n    /** @return {OIDCAuthProviderConfig} The plain object representation of the OIDCConfig. */\n    OIDCConfig.prototype.toJSON = function () {\n        return {\n            enabled: this.enabled,\n            displayName: this.displayName,\n            providerId: this.providerId,\n            issuer: this.issuer,\n            clientId: this.clientId,\n        };\n    };\n    return OIDCConfig;\n}());\nexports.OIDCConfig = OIDCConfig;\n"]},"metadata":{},"sourceType":"script"}