{"ast":null,"code":"'use strict';\n\nconst isObj = require('is-obj');\n\nconst disallowedKeys = ['__proto__', 'prototype', 'constructor'];\n\nconst isValidPath = pathSegments => !pathSegments.some(segment => disallowedKeys.includes(segment));\n\nfunction getPathSegments(path) {\n  const pathArray = path.split('.');\n  const parts = [];\n\n  for (let i = 0; i < pathArray.length; i++) {\n    let p = pathArray[i];\n\n    while (p[p.length - 1] === '\\\\' && pathArray[i + 1] !== undefined) {\n      p = p.slice(0, -1) + '.';\n      p += pathArray[++i];\n    }\n\n    parts.push(p);\n  }\n\n  if (!isValidPath(parts)) {\n    return [];\n  }\n\n  return parts;\n}\n\nmodule.exports = {\n  get(object, path, value) {\n    if (!isObj(object) || typeof path !== 'string') {\n      return value === undefined ? object : value;\n    }\n\n    const pathArray = getPathSegments(path);\n\n    if (pathArray.length === 0) {\n      return;\n    }\n\n    for (let i = 0; i < pathArray.length; i++) {\n      if (!Object.prototype.propertyIsEnumerable.call(object, pathArray[i])) {\n        return value;\n      }\n\n      object = object[pathArray[i]];\n\n      if (object === undefined || object === null) {\n        // `object` is either `undefined` or `null` so we want to stop the loop, and\n        // if this is not the last bit of the path, and\n        // if it did't return `undefined`\n        // it would return `null` if `object` is `null`\n        // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n        if (i !== pathArray.length - 1) {\n          return value;\n        }\n\n        break;\n      }\n    }\n\n    return object;\n  },\n\n  set(object, path, value) {\n    if (!isObj(object) || typeof path !== 'string') {\n      return object;\n    }\n\n    const root = object;\n    const pathArray = getPathSegments(path);\n\n    for (let i = 0; i < pathArray.length; i++) {\n      const p = pathArray[i];\n\n      if (!isObj(object[p])) {\n        object[p] = {};\n      }\n\n      if (i === pathArray.length - 1) {\n        object[p] = value;\n      }\n\n      object = object[p];\n    }\n\n    return root;\n  },\n\n  delete(object, path) {\n    if (!isObj(object) || typeof path !== 'string') {\n      return false;\n    }\n\n    const pathArray = getPathSegments(path);\n\n    for (let i = 0; i < pathArray.length; i++) {\n      const p = pathArray[i];\n\n      if (i === pathArray.length - 1) {\n        delete object[p];\n        return true;\n      }\n\n      object = object[p];\n\n      if (!isObj(object)) {\n        return false;\n      }\n    }\n  },\n\n  has(object, path) {\n    if (!isObj(object) || typeof path !== 'string') {\n      return false;\n    }\n\n    const pathArray = getPathSegments(path);\n\n    if (pathArray.length === 0) {\n      return false;\n    } // eslint-disable-next-line unicorn/no-for-loop\n\n\n    for (let i = 0; i < pathArray.length; i++) {\n      if (isObj(object)) {\n        if (!(pathArray[i] in object)) {\n          return false;\n        }\n\n        object = object[pathArray[i]];\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n};","map":{"version":3,"sources":["/Users/pulkitmittal/nft-bridge/NFTbridge/node_modules/dot-prop/index.js"],"names":["isObj","require","disallowedKeys","isValidPath","pathSegments","some","segment","includes","getPathSegments","path","pathArray","split","parts","i","length","p","undefined","slice","push","module","exports","get","object","value","Object","prototype","propertyIsEnumerable","call","set","root","delete","has"],"mappings":"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","sourcesContent":["'use strict';\nconst isObj = require('is-obj');\n\nconst disallowedKeys = [\n\t'__proto__',\n\t'prototype',\n\t'constructor'\n];\n\nconst isValidPath = pathSegments => !pathSegments.some(segment => disallowedKeys.includes(segment));\n\nfunction getPathSegments(path) {\n\tconst pathArray = path.split('.');\n\tconst parts = [];\n\n\tfor (let i = 0; i < pathArray.length; i++) {\n\t\tlet p = pathArray[i];\n\n\t\twhile (p[p.length - 1] === '\\\\' && pathArray[i + 1] !== undefined) {\n\t\t\tp = p.slice(0, -1) + '.';\n\t\t\tp += pathArray[++i];\n\t\t}\n\n\t\tparts.push(p);\n\t}\n\n\tif (!isValidPath(parts)) {\n\t\treturn [];\n\t}\n\n\treturn parts;\n}\n\nmodule.exports = {\n\tget(object, path, value) {\n\t\tif (!isObj(object) || typeof path !== 'string') {\n\t\t\treturn value === undefined ? object : value;\n\t\t}\n\n\t\tconst pathArray = getPathSegments(path);\n\t\tif (pathArray.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let i = 0; i < pathArray.length; i++) {\n\t\t\tif (!Object.prototype.propertyIsEnumerable.call(object, pathArray[i])) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tobject = object[pathArray[i]];\n\n\t\t\tif (object === undefined || object === null) {\n\t\t\t\t// `object` is either `undefined` or `null` so we want to stop the loop, and\n\t\t\t\t// if this is not the last bit of the path, and\n\t\t\t\t// if it did't return `undefined`\n\t\t\t\t// it would return `null` if `object` is `null`\n\t\t\t\t// but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n\t\t\t\tif (i !== pathArray.length - 1) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn object;\n\t},\n\n\tset(object, path, value) {\n\t\tif (!isObj(object) || typeof path !== 'string') {\n\t\t\treturn object;\n\t\t}\n\n\t\tconst root = object;\n\t\tconst pathArray = getPathSegments(path);\n\n\t\tfor (let i = 0; i < pathArray.length; i++) {\n\t\t\tconst p = pathArray[i];\n\n\t\t\tif (!isObj(object[p])) {\n\t\t\t\tobject[p] = {};\n\t\t\t}\n\n\t\t\tif (i === pathArray.length - 1) {\n\t\t\t\tobject[p] = value;\n\t\t\t}\n\n\t\t\tobject = object[p];\n\t\t}\n\n\t\treturn root;\n\t},\n\n\tdelete(object, path) {\n\t\tif (!isObj(object) || typeof path !== 'string') {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst pathArray = getPathSegments(path);\n\n\t\tfor (let i = 0; i < pathArray.length; i++) {\n\t\t\tconst p = pathArray[i];\n\n\t\t\tif (i === pathArray.length - 1) {\n\t\t\t\tdelete object[p];\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tobject = object[p];\n\n\t\t\tif (!isObj(object)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t},\n\n\thas(object, path) {\n\t\tif (!isObj(object) || typeof path !== 'string') {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst pathArray = getPathSegments(path);\n\t\tif (pathArray.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// eslint-disable-next-line unicorn/no-for-loop\n\t\tfor (let i = 0; i < pathArray.length; i++) {\n\t\t\tif (isObj(object)) {\n\t\t\t\tif (!(pathArray[i] in object)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tobject = object[pathArray[i]];\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}