{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createURI = exports.upload = exports.Upload = exports.PROTOCOL_REGEX = void 0;\n\nconst abort_controller_1 = require(\"abort-controller\");\n\nconst ConfigStore = require(\"configstore\");\n\nconst crypto_1 = require(\"crypto\");\n\nconst extend = require(\"extend\");\n\nconst google_auth_library_1 = require(\"google-auth-library\");\n\nconst Pumpify = require(\"pumpify\");\n\nconst stream_1 = require(\"stream\");\n\nconst streamEvents = require(\"stream-events\");\n\nconst TERMINATED_UPLOAD_STATUS_CODE = 410;\nconst RESUMABLE_INCOMPLETE_STATUS_CODE = 308;\nconst RETRY_LIMIT = 5;\nexports.PROTOCOL_REGEX = /^(\\w*):\\/\\//;\n\nclass Upload extends Pumpify {\n  constructor(cfg) {\n    super();\n    this.numBytesWritten = 0;\n    this.numRetries = 0;\n    streamEvents(this);\n    cfg = cfg || {};\n\n    if (!cfg.bucket || !cfg.file) {\n      throw new Error('A bucket and file name are required');\n    }\n\n    cfg.authConfig = cfg.authConfig || {};\n    cfg.authConfig.scopes = ['https://www.googleapis.com/auth/devstorage.full_control'];\n    this.authClient = cfg.authClient || new google_auth_library_1.GoogleAuth(cfg.authConfig);\n    this.apiEndpoint = 'https://storage.googleapis.com';\n\n    if (cfg.apiEndpoint) {\n      this.apiEndpoint = this.sanitizeEndpoint(cfg.apiEndpoint);\n    }\n\n    this.baseURI = `${this.apiEndpoint}/upload/storage/v1/b`;\n    this.bucket = cfg.bucket;\n    const cacheKeyElements = [cfg.bucket, cfg.file];\n\n    if (typeof cfg.generation === 'number') {\n      cacheKeyElements.push(`${cfg.generation}`);\n    }\n\n    this.cacheKey = cacheKeyElements.join('/');\n    this.customRequestOptions = cfg.customRequestOptions || {};\n    this.file = cfg.file;\n    this.generation = cfg.generation;\n    this.kmsKeyName = cfg.kmsKeyName;\n    this.metadata = cfg.metadata || {};\n    this.offset = cfg.offset;\n    this.origin = cfg.origin;\n    this.params = cfg.params || {};\n    this.userProject = cfg.userProject;\n\n    if (cfg.key) {\n      /**\n       * NOTE: This is `as string` because there appears to be some weird kind\n       * of TypeScript bug as 2.8. Tracking the issue here:\n       * https://github.com/Microsoft/TypeScript/issues/23155\n       */\n      const base64Key = Buffer.from(cfg.key).toString('base64');\n      this.encryption = {\n        key: base64Key,\n        hash: crypto_1.createHash('sha256').update(cfg.key).digest('base64')\n      };\n    }\n\n    this.predefinedAcl = cfg.predefinedAcl;\n    if (cfg.private) this.predefinedAcl = 'private';\n    if (cfg.public) this.predefinedAcl = 'publicRead';\n    const configPath = cfg.configPath;\n    this.configStore = new ConfigStore('gcs-resumable-upload', null, {\n      configPath\n    });\n    this.uriProvidedManually = !!cfg.uri;\n    this.uri = cfg.uri || this.get('uri');\n    this.numBytesWritten = 0;\n    this.numRetries = 0;\n    const contentLength = cfg.metadata ? Number(cfg.metadata.contentLength) : NaN;\n    this.contentLength = isNaN(contentLength) ? '*' : contentLength;\n    this.once('writing', () => {\n      if (this.uri) {\n        this.continueUploading();\n      } else {\n        this.createURI(err => {\n          if (err) {\n            return this.destroy(err);\n          }\n\n          this.startUploading();\n        });\n      }\n    });\n  }\n\n  createURI(callback) {\n    if (!callback) {\n      return this.createURIAsync();\n    }\n\n    this.createURIAsync().then(r => callback(null, r), callback);\n  }\n\n  async createURIAsync() {\n    const metadata = this.metadata;\n    const reqOpts = {\n      method: 'POST',\n      url: [this.baseURI, this.bucket, 'o'].join('/'),\n      params: Object.assign({\n        name: this.file,\n        uploadType: 'resumable'\n      }, this.params),\n      data: metadata,\n      headers: {}\n    };\n\n    if (metadata.contentLength) {\n      reqOpts.headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n    }\n\n    if (metadata.contentType) {\n      reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType;\n    }\n\n    if (typeof this.generation !== 'undefined') {\n      reqOpts.params.ifGenerationMatch = this.generation;\n    }\n\n    if (this.kmsKeyName) {\n      reqOpts.params.kmsKeyName = this.kmsKeyName;\n    }\n\n    if (this.predefinedAcl) {\n      reqOpts.params.predefinedAcl = this.predefinedAcl;\n    }\n\n    if (this.origin) {\n      reqOpts.headers.Origin = this.origin;\n    }\n\n    const resp = await this.makeRequest(reqOpts);\n    const uri = resp.headers.location;\n    this.uri = uri;\n    this.set({\n      uri\n    });\n    this.offset = 0;\n    return uri;\n  }\n\n  async continueUploading() {\n    if (typeof this.offset === 'number') {\n      this.startUploading();\n      return;\n    }\n\n    await this.getAndSetOffset();\n    this.startUploading();\n  }\n\n  async startUploading() {\n    // The buffer stream allows us to keep chunks in memory\n    // until we are sure we can successfully resume the upload.\n    const bufferStream = this.bufferStream || new stream_1.PassThrough();\n    this.bufferStream = bufferStream; // The offset stream allows us to analyze each incoming\n    // chunk to analyze it against what the upstream API already\n    // has stored for this upload.\n\n    const offsetStream = this.offsetStream = new stream_1.Transform({\n      transform: this.onChunk.bind(this)\n    }); // The delay stream gives us a chance to catch the response\n    // from the API request before we signal to the user that\n    // the upload was successful.\n\n    const delayStream = new stream_1.PassThrough(); // The request library (authClient.request()) requires the\n    // stream to be sent within the request options.\n\n    const requestStreamEmbeddedStream = new stream_1.PassThrough();\n    delayStream.on('prefinish', () => {\n      // Pause the stream from finishing so we can process the\n      // response from the API.\n      this.cork();\n    }); // Process the API response to look for errors that came in\n    // the response body.\n\n    this.on('response', resp => {\n      if (resp.data.error) {\n        this.destroy(resp.data.error);\n        return;\n      }\n\n      if (resp.status < 200 || resp.status > 299) {\n        this.destroy(new Error('Upload failed'));\n        return;\n      }\n\n      if (resp && resp.data) {\n        resp.data.size = Number(resp.data.size);\n      }\n\n      this.emit('metadata', resp.data);\n      this.deleteConfig(); // Allow the stream to continue naturally so the user's\n      // \"finish\" event fires.\n\n      this.uncork();\n    });\n    this.setPipeline(bufferStream, offsetStream, delayStream);\n    this.pipe(requestStreamEmbeddedStream);\n    this.once('restart', () => {\n      // The upload is being re-attempted. Disconnect the request\n      // stream, so it won't receive more data.\n      this.unpipe(requestStreamEmbeddedStream);\n    });\n    const reqOpts = {\n      method: 'PUT',\n      url: this.uri,\n      headers: {\n        'Content-Range': 'bytes ' + this.offset + '-*/' + this.contentLength\n      },\n      body: requestStreamEmbeddedStream\n    };\n\n    try {\n      await this.makeRequestStream(reqOpts);\n    } catch (e) {\n      this.destroy(e);\n    }\n  }\n\n  onChunk(chunk, enc, next) {\n    const offset = this.offset;\n    const numBytesWritten = this.numBytesWritten;\n    this.emit('progress', {\n      bytesWritten: this.numBytesWritten,\n      contentLength: this.contentLength\n    }); // check if this is the same content uploaded previously. this caches a\n    // slice of the first chunk, then compares it with the first byte of\n    // incoming data\n\n    if (numBytesWritten === 0) {\n      let cachedFirstChunk = this.get('firstChunk');\n      const firstChunk = chunk.slice(0, 16).valueOf();\n\n      if (!cachedFirstChunk) {\n        // This is a new upload. Cache the first chunk.\n        this.set({\n          uri: this.uri,\n          firstChunk\n        });\n      } else {\n        // this continues an upload in progress. check if the bytes are the same\n        cachedFirstChunk = Buffer.from(cachedFirstChunk);\n        const nextChunk = Buffer.from(firstChunk);\n\n        if (Buffer.compare(cachedFirstChunk, nextChunk) !== 0) {\n          // this data is not the same. start a new upload\n          this.bufferStream.unshift(chunk);\n          this.bufferStream.unpipe(this.offsetStream);\n          this.restart();\n          return;\n        }\n      }\n    }\n\n    let length = chunk.length;\n    if (typeof chunk === 'string') length = Buffer.byteLength(chunk, enc);\n    if (numBytesWritten < offset) chunk = chunk.slice(offset - numBytesWritten);\n    this.numBytesWritten += length; // only push data from the byte after the one we left off on\n\n    next(undefined, this.numBytesWritten > offset ? chunk : undefined);\n  }\n\n  async getAndSetOffset() {\n    const opts = {\n      method: 'PUT',\n      url: this.uri,\n      headers: {\n        'Content-Length': 0,\n        'Content-Range': 'bytes */*'\n      }\n    };\n\n    try {\n      const resp = await this.makeRequest(opts);\n\n      if (resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE) {\n        if (resp.headers.range) {\n          const range = resp.headers.range;\n          this.offset = Number(range.split('-')[1]) + 1;\n          return;\n        }\n      }\n\n      this.offset = 0;\n    } catch (err) {\n      const resp = err.response; // we don't return a 404 to the user if they provided the resumable\n      // URI. if we're just using the configstore file to tell us that this\n      // file exists, and it turns out that it doesn't (the 404), that's\n      // probably stale config data.\n\n      if (resp && resp.status === 404 && !this.uriProvidedManually) {\n        this.restart();\n        return;\n      } // this resumable upload is unrecoverable (bad data or service error).\n      //  -\n      //  https://github.com/stephenplusplus/gcs-resumable-upload/issues/15\n      //  -\n      //  https://github.com/stephenplusplus/gcs-resumable-upload/pull/16#discussion_r80363774\n\n\n      if (resp && resp.status === TERMINATED_UPLOAD_STATUS_CODE) {\n        this.restart();\n        return;\n      }\n\n      this.destroy(err);\n    }\n  }\n\n  async makeRequest(reqOpts) {\n    if (this.encryption) {\n      reqOpts.headers = reqOpts.headers || {};\n      reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n      reqOpts.headers['x-goog-encryption-key'] = this.encryption.key.toString();\n      reqOpts.headers['x-goog-encryption-key-sha256'] = this.encryption.hash.toString();\n    }\n\n    if (this.userProject) {\n      reqOpts.params = reqOpts.params || {};\n      reqOpts.params.userProject = this.userProject;\n    } // Let gaxios know we will handle a 308 error code ourselves.\n\n\n    reqOpts.validateStatus = status => {\n      return status >= 200 && status < 300 || status === RESUMABLE_INCOMPLETE_STATUS_CODE;\n    };\n\n    const combinedReqOpts = extend(true, {}, this.customRequestOptions, reqOpts);\n    const res = await this.authClient.request(combinedReqOpts);\n\n    if (res.data && res.data.error) {\n      throw res.data.error;\n    }\n\n    return res;\n  }\n\n  async makeRequestStream(reqOpts) {\n    const controller = new abort_controller_1.default();\n    this.once('error', () => controller.abort());\n\n    if (this.userProject) {\n      reqOpts.params = reqOpts.params || {};\n      reqOpts.params.userProject = this.userProject;\n    }\n\n    reqOpts.signal = controller.signal;\n\n    reqOpts.validateStatus = () => true;\n\n    const combinedReqOpts = extend(true, {}, this.customRequestOptions, reqOpts);\n    const res = await this.authClient.request(combinedReqOpts);\n    this.onResponse(res);\n    return res;\n  }\n\n  restart() {\n    this.emit('restart');\n    this.numBytesWritten = 0;\n    this.deleteConfig();\n    this.createURI(err => {\n      if (err) {\n        return this.destroy(err);\n      }\n\n      this.startUploading();\n    });\n  }\n\n  get(prop) {\n    const store = this.configStore.get(this.cacheKey);\n    return store && store[prop];\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  set(props) {\n    this.configStore.set(this.cacheKey, props);\n  }\n\n  deleteConfig() {\n    this.configStore.delete(this.cacheKey);\n  }\n  /**\n   * @return {bool} is the request good?\n   */\n\n\n  onResponse(resp) {\n    if (resp.status === 404) {\n      if (this.numRetries < RETRY_LIMIT) {\n        this.numRetries++;\n        this.startUploading();\n      } else {\n        this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n      }\n\n      return false;\n    }\n\n    if (resp.status > 499 && resp.status < 600) {\n      if (this.numRetries < RETRY_LIMIT) {\n        const randomMs = Math.round(Math.random() * 1000);\n        const waitTime = Math.pow(2, this.numRetries) * 1000 + randomMs;\n        this.numRetries++;\n        setTimeout(this.continueUploading.bind(this), waitTime);\n      } else {\n        this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n      }\n\n      return false;\n    }\n\n    this.emit('response', resp);\n    return true;\n  }\n  /*\n   * Prepare user-defined API endpoint for compatibility with our API.\n   */\n\n\n  sanitizeEndpoint(url) {\n    if (!exports.PROTOCOL_REGEX.test(url)) {\n      url = `https://${url}`;\n    }\n\n    return url.replace(/\\/+$/, ''); // Remove trailing slashes\n  }\n\n}\n\nexports.Upload = Upload;\n\nfunction upload(cfg) {\n  return new Upload(cfg);\n}\n\nexports.upload = upload;\n\nfunction createURI(cfg, callback) {\n  const up = new Upload(cfg);\n\n  if (!callback) {\n    return up.createURI();\n  }\n\n  up.createURI().then(r => callback(null, r), callback);\n}\n\nexports.createURI = createURI;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createURI = exports.upload = exports.Upload = exports.PROTOCOL_REGEX = void 0;\nconst abort_controller_1 = require(\"abort-controller\");\nconst ConfigStore = require(\"configstore\");\nconst crypto_1 = require(\"crypto\");\nconst extend = require(\"extend\");\nconst google_auth_library_1 = require(\"google-auth-library\");\nconst Pumpify = require(\"pumpify\");\nconst stream_1 = require(\"stream\");\nconst streamEvents = require(\"stream-events\");\nconst TERMINATED_UPLOAD_STATUS_CODE = 410;\nconst RESUMABLE_INCOMPLETE_STATUS_CODE = 308;\nconst RETRY_LIMIT = 5;\nexports.PROTOCOL_REGEX = /^(\\w*):\\/\\//;\nclass Upload extends Pumpify {\n    constructor(cfg) {\n        super();\n        this.numBytesWritten = 0;\n        this.numRetries = 0;\n        streamEvents(this);\n        cfg = cfg || {};\n        if (!cfg.bucket || !cfg.file) {\n            throw new Error('A bucket and file name are required');\n        }\n        cfg.authConfig = cfg.authConfig || {};\n        cfg.authConfig.scopes = [\n            'https://www.googleapis.com/auth/devstorage.full_control',\n        ];\n        this.authClient = cfg.authClient || new google_auth_library_1.GoogleAuth(cfg.authConfig);\n        this.apiEndpoint = 'https://storage.googleapis.com';\n        if (cfg.apiEndpoint) {\n            this.apiEndpoint = this.sanitizeEndpoint(cfg.apiEndpoint);\n        }\n        this.baseURI = `${this.apiEndpoint}/upload/storage/v1/b`;\n        this.bucket = cfg.bucket;\n        const cacheKeyElements = [cfg.bucket, cfg.file];\n        if (typeof cfg.generation === 'number') {\n            cacheKeyElements.push(`${cfg.generation}`);\n        }\n        this.cacheKey = cacheKeyElements.join('/');\n        this.customRequestOptions = cfg.customRequestOptions || {};\n        this.file = cfg.file;\n        this.generation = cfg.generation;\n        this.kmsKeyName = cfg.kmsKeyName;\n        this.metadata = cfg.metadata || {};\n        this.offset = cfg.offset;\n        this.origin = cfg.origin;\n        this.params = cfg.params || {};\n        this.userProject = cfg.userProject;\n        if (cfg.key) {\n            /**\n             * NOTE: This is `as string` because there appears to be some weird kind\n             * of TypeScript bug as 2.8. Tracking the issue here:\n             * https://github.com/Microsoft/TypeScript/issues/23155\n             */\n            const base64Key = Buffer.from(cfg.key).toString('base64');\n            this.encryption = {\n                key: base64Key,\n                hash: crypto_1.createHash('sha256').update(cfg.key).digest('base64'),\n            };\n        }\n        this.predefinedAcl = cfg.predefinedAcl;\n        if (cfg.private)\n            this.predefinedAcl = 'private';\n        if (cfg.public)\n            this.predefinedAcl = 'publicRead';\n        const configPath = cfg.configPath;\n        this.configStore = new ConfigStore('gcs-resumable-upload', null, {\n            configPath,\n        });\n        this.uriProvidedManually = !!cfg.uri;\n        this.uri = cfg.uri || this.get('uri');\n        this.numBytesWritten = 0;\n        this.numRetries = 0;\n        const contentLength = cfg.metadata\n            ? Number(cfg.metadata.contentLength)\n            : NaN;\n        this.contentLength = isNaN(contentLength) ? '*' : contentLength;\n        this.once('writing', () => {\n            if (this.uri) {\n                this.continueUploading();\n            }\n            else {\n                this.createURI(err => {\n                    if (err) {\n                        return this.destroy(err);\n                    }\n                    this.startUploading();\n                });\n            }\n        });\n    }\n    createURI(callback) {\n        if (!callback) {\n            return this.createURIAsync();\n        }\n        this.createURIAsync().then(r => callback(null, r), callback);\n    }\n    async createURIAsync() {\n        const metadata = this.metadata;\n        const reqOpts = {\n            method: 'POST',\n            url: [this.baseURI, this.bucket, 'o'].join('/'),\n            params: Object.assign({\n                name: this.file,\n                uploadType: 'resumable',\n            }, this.params),\n            data: metadata,\n            headers: {},\n        };\n        if (metadata.contentLength) {\n            reqOpts.headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n        }\n        if (metadata.contentType) {\n            reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType;\n        }\n        if (typeof this.generation !== 'undefined') {\n            reqOpts.params.ifGenerationMatch = this.generation;\n        }\n        if (this.kmsKeyName) {\n            reqOpts.params.kmsKeyName = this.kmsKeyName;\n        }\n        if (this.predefinedAcl) {\n            reqOpts.params.predefinedAcl = this.predefinedAcl;\n        }\n        if (this.origin) {\n            reqOpts.headers.Origin = this.origin;\n        }\n        const resp = await this.makeRequest(reqOpts);\n        const uri = resp.headers.location;\n        this.uri = uri;\n        this.set({ uri });\n        this.offset = 0;\n        return uri;\n    }\n    async continueUploading() {\n        if (typeof this.offset === 'number') {\n            this.startUploading();\n            return;\n        }\n        await this.getAndSetOffset();\n        this.startUploading();\n    }\n    async startUploading() {\n        // The buffer stream allows us to keep chunks in memory\n        // until we are sure we can successfully resume the upload.\n        const bufferStream = this.bufferStream || new stream_1.PassThrough();\n        this.bufferStream = bufferStream;\n        // The offset stream allows us to analyze each incoming\n        // chunk to analyze it against what the upstream API already\n        // has stored for this upload.\n        const offsetStream = (this.offsetStream = new stream_1.Transform({\n            transform: this.onChunk.bind(this),\n        }));\n        // The delay stream gives us a chance to catch the response\n        // from the API request before we signal to the user that\n        // the upload was successful.\n        const delayStream = new stream_1.PassThrough();\n        // The request library (authClient.request()) requires the\n        // stream to be sent within the request options.\n        const requestStreamEmbeddedStream = new stream_1.PassThrough();\n        delayStream.on('prefinish', () => {\n            // Pause the stream from finishing so we can process the\n            // response from the API.\n            this.cork();\n        });\n        // Process the API response to look for errors that came in\n        // the response body.\n        this.on('response', (resp) => {\n            if (resp.data.error) {\n                this.destroy(resp.data.error);\n                return;\n            }\n            if (resp.status < 200 || resp.status > 299) {\n                this.destroy(new Error('Upload failed'));\n                return;\n            }\n            if (resp && resp.data) {\n                resp.data.size = Number(resp.data.size);\n            }\n            this.emit('metadata', resp.data);\n            this.deleteConfig();\n            // Allow the stream to continue naturally so the user's\n            // \"finish\" event fires.\n            this.uncork();\n        });\n        this.setPipeline(bufferStream, offsetStream, delayStream);\n        this.pipe(requestStreamEmbeddedStream);\n        this.once('restart', () => {\n            // The upload is being re-attempted. Disconnect the request\n            // stream, so it won't receive more data.\n            this.unpipe(requestStreamEmbeddedStream);\n        });\n        const reqOpts = {\n            method: 'PUT',\n            url: this.uri,\n            headers: {\n                'Content-Range': 'bytes ' + this.offset + '-*/' + this.contentLength,\n            },\n            body: requestStreamEmbeddedStream,\n        };\n        try {\n            await this.makeRequestStream(reqOpts);\n        }\n        catch (e) {\n            this.destroy(e);\n        }\n    }\n    onChunk(chunk, enc, next) {\n        const offset = this.offset;\n        const numBytesWritten = this.numBytesWritten;\n        this.emit('progress', {\n            bytesWritten: this.numBytesWritten,\n            contentLength: this.contentLength,\n        });\n        // check if this is the same content uploaded previously. this caches a\n        // slice of the first chunk, then compares it with the first byte of\n        // incoming data\n        if (numBytesWritten === 0) {\n            let cachedFirstChunk = this.get('firstChunk');\n            const firstChunk = chunk.slice(0, 16).valueOf();\n            if (!cachedFirstChunk) {\n                // This is a new upload. Cache the first chunk.\n                this.set({ uri: this.uri, firstChunk });\n            }\n            else {\n                // this continues an upload in progress. check if the bytes are the same\n                cachedFirstChunk = Buffer.from(cachedFirstChunk);\n                const nextChunk = Buffer.from(firstChunk);\n                if (Buffer.compare(cachedFirstChunk, nextChunk) !== 0) {\n                    // this data is not the same. start a new upload\n                    this.bufferStream.unshift(chunk);\n                    this.bufferStream.unpipe(this.offsetStream);\n                    this.restart();\n                    return;\n                }\n            }\n        }\n        let length = chunk.length;\n        if (typeof chunk === 'string')\n            length = Buffer.byteLength(chunk, enc);\n        if (numBytesWritten < offset)\n            chunk = chunk.slice(offset - numBytesWritten);\n        this.numBytesWritten += length;\n        // only push data from the byte after the one we left off on\n        next(undefined, this.numBytesWritten > offset ? chunk : undefined);\n    }\n    async getAndSetOffset() {\n        const opts = {\n            method: 'PUT',\n            url: this.uri,\n            headers: { 'Content-Length': 0, 'Content-Range': 'bytes */*' },\n        };\n        try {\n            const resp = await this.makeRequest(opts);\n            if (resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE) {\n                if (resp.headers.range) {\n                    const range = resp.headers.range;\n                    this.offset = Number(range.split('-')[1]) + 1;\n                    return;\n                }\n            }\n            this.offset = 0;\n        }\n        catch (err) {\n            const resp = err.response;\n            // we don't return a 404 to the user if they provided the resumable\n            // URI. if we're just using the configstore file to tell us that this\n            // file exists, and it turns out that it doesn't (the 404), that's\n            // probably stale config data.\n            if (resp && resp.status === 404 && !this.uriProvidedManually) {\n                this.restart();\n                return;\n            }\n            // this resumable upload is unrecoverable (bad data or service error).\n            //  -\n            //  https://github.com/stephenplusplus/gcs-resumable-upload/issues/15\n            //  -\n            //  https://github.com/stephenplusplus/gcs-resumable-upload/pull/16#discussion_r80363774\n            if (resp && resp.status === TERMINATED_UPLOAD_STATUS_CODE) {\n                this.restart();\n                return;\n            }\n            this.destroy(err);\n        }\n    }\n    async makeRequest(reqOpts) {\n        if (this.encryption) {\n            reqOpts.headers = reqOpts.headers || {};\n            reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n            reqOpts.headers['x-goog-encryption-key'] = this.encryption.key.toString();\n            reqOpts.headers['x-goog-encryption-key-sha256'] = this.encryption.hash.toString();\n        }\n        if (this.userProject) {\n            reqOpts.params = reqOpts.params || {};\n            reqOpts.params.userProject = this.userProject;\n        }\n        // Let gaxios know we will handle a 308 error code ourselves.\n        reqOpts.validateStatus = (status) => {\n            return ((status >= 200 && status < 300) ||\n                status === RESUMABLE_INCOMPLETE_STATUS_CODE);\n        };\n        const combinedReqOpts = extend(true, {}, this.customRequestOptions, reqOpts);\n        const res = await this.authClient.request(combinedReqOpts);\n        if (res.data && res.data.error) {\n            throw res.data.error;\n        }\n        return res;\n    }\n    async makeRequestStream(reqOpts) {\n        const controller = new abort_controller_1.default();\n        this.once('error', () => controller.abort());\n        if (this.userProject) {\n            reqOpts.params = reqOpts.params || {};\n            reqOpts.params.userProject = this.userProject;\n        }\n        reqOpts.signal = controller.signal;\n        reqOpts.validateStatus = () => true;\n        const combinedReqOpts = extend(true, {}, this.customRequestOptions, reqOpts);\n        const res = await this.authClient.request(combinedReqOpts);\n        this.onResponse(res);\n        return res;\n    }\n    restart() {\n        this.emit('restart');\n        this.numBytesWritten = 0;\n        this.deleteConfig();\n        this.createURI(err => {\n            if (err) {\n                return this.destroy(err);\n            }\n            this.startUploading();\n        });\n    }\n    get(prop) {\n        const store = this.configStore.get(this.cacheKey);\n        return store && store[prop];\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    set(props) {\n        this.configStore.set(this.cacheKey, props);\n    }\n    deleteConfig() {\n        this.configStore.delete(this.cacheKey);\n    }\n    /**\n     * @return {bool} is the request good?\n     */\n    onResponse(resp) {\n        if (resp.status === 404) {\n            if (this.numRetries < RETRY_LIMIT) {\n                this.numRetries++;\n                this.startUploading();\n            }\n            else {\n                this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n            }\n            return false;\n        }\n        if (resp.status > 499 && resp.status < 600) {\n            if (this.numRetries < RETRY_LIMIT) {\n                const randomMs = Math.round(Math.random() * 1000);\n                const waitTime = Math.pow(2, this.numRetries) * 1000 + randomMs;\n                this.numRetries++;\n                setTimeout(this.continueUploading.bind(this), waitTime);\n            }\n            else {\n                this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n            }\n            return false;\n        }\n        this.emit('response', resp);\n        return true;\n    }\n    /*\n     * Prepare user-defined API endpoint for compatibility with our API.\n     */\n    sanitizeEndpoint(url) {\n        if (!exports.PROTOCOL_REGEX.test(url)) {\n            url = `https://${url}`;\n        }\n        return url.replace(/\\/+$/, ''); // Remove trailing slashes\n    }\n}\nexports.Upload = Upload;\nfunction upload(cfg) {\n    return new Upload(cfg);\n}\nexports.upload = upload;\nfunction createURI(cfg, callback) {\n    const up = new Upload(cfg);\n    if (!callback) {\n        return up.createURI();\n    }\n    up.createURI().then(r => callback(null, r), callback);\n}\nexports.createURI = createURI;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}