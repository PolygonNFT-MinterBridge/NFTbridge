{"ast":null,"code":"\"use strict\";\n\nmodule.exports = decoder;\n\nvar Enum = require(\"./enum\"),\n    types = require(\"./types\"),\n    util = require(\"./util\");\n\nfunction missing(field) {\n  return \"missing required '\" + field.name + \"'\";\n}\n/**\n * Generates a decoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\n\n\nfunction decoder(mtype) {\n  /* eslint-disable no-unexpected-multiline */\n  var gen = util.codegen([\"r\", \"l\"], mtype.name + \"$decode\")(\"if(!(r instanceof Reader))\")(\"r=Reader.create(r)\")(\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function (field) {\n    return field.map;\n  }).length ? \",k,value\" : \"\"))(\"while(r.pos<c){\")(\"var t=r.uint32()\");\n  if (mtype.group) gen(\"if((t&7)===4)\")(\"break\");\n  gen(\"switch(t>>>3){\");\n  var i = 0;\n\n  for (; i <\n  /* initializes */\n  mtype.fieldsArray.length; ++i) {\n    var field = mtype._fieldsArray[i].resolve(),\n        type = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n        ref = \"m\" + util.safeProp(field.name);\n\n    gen(\"case %i:\", field.id); // Map fields\n\n    if (field.map) {\n      gen(\"if(%s===util.emptyObject)\", ref)(\"%s={}\", ref)(\"var c2 = r.uint32()+r.pos\");\n      if (types.defaults[field.keyType] !== undefined) gen(\"k=%j\", types.defaults[field.keyType]);else gen(\"k=null\");\n      if (types.defaults[type] !== undefined) gen(\"value=%j\", types.defaults[type]);else gen(\"value=null\");\n      gen(\"while(r.pos<c2){\")(\"var tag2=r.uint32()\")(\"switch(tag2>>>3){\")(\"case 1: k=r.%s(); break\", field.keyType)(\"case 2:\");\n      if (types.basic[type] === undefined) gen(\"value=types[%i].decode(r,r.uint32())\", i); // can't be groups\n      else gen(\"value=r.%s()\", type);\n      gen(\"break\")(\"default:\")(\"r.skipType(tag2&7)\")(\"break\")(\"}\")(\"}\");\n      if (types.long[field.keyType] !== undefined) gen(\"%s[typeof k===\\\"object\\\"?util.longToHash(k):k]=value\", ref);else gen(\"%s[k]=value\", ref); // Repeated fields\n    } else if (field.repeated) {\n      gen(\"if(!(%s&&%s.length))\", ref, ref)(\"%s=[]\", ref); // Packable (always check for forward and backward compatiblity)\n\n      if (types.packed[type] !== undefined) gen(\"if((t&7)===2){\")(\"var c2=r.uint32()+r.pos\")(\"while(r.pos<c2)\")(\"%s.push(r.%s())\", ref, type)(\"}else\"); // Non-packed\n\n      if (types.basic[type] === undefined) gen(field.resolvedType.group ? \"%s.push(types[%i].decode(r))\" : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);else gen(\"%s.push(r.%s())\", ref, type); // Non-repeated\n    } else if (types.basic[type] === undefined) gen(field.resolvedType.group ? \"%s=types[%i].decode(r)\" : \"%s=types[%i].decode(r,r.uint32())\", ref, i);else gen(\"%s=r.%s()\", ref, type);\n\n    gen(\"break\"); // Unknown fields\n  }\n\n  gen(\"default:\")(\"r.skipType(t&7)\")(\"break\")(\"}\")(\"}\"); // Field presence\n\n  for (i = 0; i < mtype._fieldsArray.length; ++i) {\n    var rfield = mtype._fieldsArray[i];\n    if (rfield.required) gen(\"if(!m.hasOwnProperty(%j))\", rfield.name)(\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\n  }\n\n  return gen(\"return m\");\n  /* eslint-enable no-unexpected-multiline */\n}","map":{"version":3,"sources":["/Users/piyushmaheshwari/Downloads/github/Bridgeorg/node_modules/protobufjs/src/decoder.js"],"names":["module","exports","decoder","Enum","require","types","util","missing","field","name","mtype","gen","codegen","fieldsArray","filter","map","length","group","i","_fieldsArray","resolve","type","resolvedType","ref","safeProp","id","defaults","keyType","undefined","basic","long","repeated","packed","rfield","required"],"mappings":"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","sourcesContent":["\"use strict\";\nmodule.exports = decoder;\n\nvar Enum    = require(\"./enum\"),\n    types   = require(\"./types\"),\n    util    = require(\"./util\");\n\nfunction missing(field) {\n    return \"missing required '\" + field.name + \"'\";\n}\n\n/**\n * Generates a decoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */\nfunction decoder(mtype) {\n    /* eslint-disable no-unexpected-multiline */\n    var gen = util.codegen([\"r\", \"l\"], mtype.name + \"$decode\")\n    (\"if(!(r instanceof Reader))\")\n        (\"r=Reader.create(r)\")\n    (\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? \",k,value\" : \"\"))\n    (\"while(r.pos<c){\")\n        (\"var t=r.uint32()\");\n    if (mtype.group) gen\n        (\"if((t&7)===4)\")\n            (\"break\");\n    gen\n        (\"switch(t>>>3){\");\n\n    var i = 0;\n    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {\n        var field = mtype._fieldsArray[i].resolve(),\n            type  = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n            ref   = \"m\" + util.safeProp(field.name); gen\n            (\"case %i:\", field.id);\n\n        // Map fields\n        if (field.map) { gen\n                (\"if(%s===util.emptyObject)\", ref)\n                    (\"%s={}\", ref)\n                (\"var c2 = r.uint32()+r.pos\");\n\n            if (types.defaults[field.keyType] !== undefined) gen\n                (\"k=%j\", types.defaults[field.keyType]);\n            else gen\n                (\"k=null\");\n\n            if (types.defaults[type] !== undefined) gen\n                (\"value=%j\", types.defaults[type]);\n            else gen\n                (\"value=null\");\n\n            gen\n                (\"while(r.pos<c2){\")\n                    (\"var tag2=r.uint32()\")\n                    (\"switch(tag2>>>3){\")\n                        (\"case 1: k=r.%s(); break\", field.keyType)\n                        (\"case 2:\");\n\n            if (types.basic[type] === undefined) gen\n                            (\"value=types[%i].decode(r,r.uint32())\", i); // can't be groups\n            else gen\n                            (\"value=r.%s()\", type);\n\n            gen\n                            (\"break\")\n                        (\"default:\")\n                            (\"r.skipType(tag2&7)\")\n                            (\"break\")\n                    (\"}\")\n                (\"}\");\n\n            if (types.long[field.keyType] !== undefined) gen\n                (\"%s[typeof k===\\\"object\\\"?util.longToHash(k):k]=value\", ref);\n            else gen\n                (\"%s[k]=value\", ref);\n\n        // Repeated fields\n        } else if (field.repeated) { gen\n\n                (\"if(!(%s&&%s.length))\", ref, ref)\n                    (\"%s=[]\", ref);\n\n            // Packable (always check for forward and backward compatiblity)\n            if (types.packed[type] !== undefined) gen\n                (\"if((t&7)===2){\")\n                    (\"var c2=r.uint32()+r.pos\")\n                    (\"while(r.pos<c2)\")\n                        (\"%s.push(r.%s())\", ref, type)\n                (\"}else\");\n\n            // Non-packed\n            if (types.basic[type] === undefined) gen(field.resolvedType.group\n                    ? \"%s.push(types[%i].decode(r))\"\n                    : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);\n            else gen\n                    (\"%s.push(r.%s())\", ref, type);\n\n        // Non-repeated\n        } else if (types.basic[type] === undefined) gen(field.resolvedType.group\n                ? \"%s=types[%i].decode(r)\"\n                : \"%s=types[%i].decode(r,r.uint32())\", ref, i);\n        else gen\n                (\"%s=r.%s()\", ref, type);\n        gen\n                (\"break\");\n    // Unknown fields\n    } gen\n            (\"default:\")\n                (\"r.skipType(t&7)\")\n                (\"break\")\n\n        (\"}\")\n    (\"}\");\n\n    // Field presence\n    for (i = 0; i < mtype._fieldsArray.length; ++i) {\n        var rfield = mtype._fieldsArray[i];\n        if (rfield.required) gen\n    (\"if(!m.hasOwnProperty(%j))\", rfield.name)\n        (\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\n    }\n\n    return gen\n    (\"return m\");\n    /* eslint-enable no-unexpected-multiline */\n}\n"]},"metadata":{},"sourceType":"script"}