{"ast":null,"code":"\"use strict\";\n\nmodule.exports = Namespace; // extends ReflectionObject\n\nvar ReflectionObject = require(\"./object\");\n\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\n\nvar Field = require(\"./field\"),\n    util = require(\"./util\");\n\nvar Type, // cyclic\nService, Enum;\n/**\n * Constructs a new namespace instance.\n * @name Namespace\n * @classdesc Reflected namespace.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n */\n\n/**\n * Constructs a namespace from JSON.\n * @memberof Namespace\n * @function\n * @param {string} name Namespace name\n * @param {Object.<string,*>} json JSON object\n * @returns {Namespace} Created namespace\n * @throws {TypeError} If arguments are invalid\n */\n\nNamespace.fromJSON = function fromJSON(name, json) {\n  return new Namespace(name, json.options).addJSON(json.nested);\n};\n/**\n * Converts an array of reflection objects to JSON.\n * @memberof Namespace\n * @param {ReflectionObject[]} array Object array\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\n */\n\n\nfunction arrayToJSON(array, toJSONOptions) {\n  if (!(array && array.length)) return undefined;\n  var obj = {};\n\n  for (var i = 0; i < array.length; ++i) obj[array[i].name] = array[i].toJSON(toJSONOptions);\n\n  return obj;\n}\n\nNamespace.arrayToJSON = arrayToJSON;\n/**\n * Tests if the specified id is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\n\nNamespace.isReservedId = function isReservedId(reserved, id) {\n  if (reserved) for (var i = 0; i < reserved.length; ++i) if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id) return true;\n  return false;\n};\n/**\n * Tests if the specified name is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\n\n\nNamespace.isReservedName = function isReservedName(reserved, name) {\n  if (reserved) for (var i = 0; i < reserved.length; ++i) if (reserved[i] === name) return true;\n  return false;\n};\n/**\n * Not an actual constructor. Use {@link Namespace} instead.\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports NamespaceBase\n * @extends ReflectionObject\n * @abstract\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n * @see {@link Namespace}\n */\n\n\nfunction Namespace(name, options) {\n  ReflectionObject.call(this, name, options);\n  /**\n   * Nested objects by name.\n   * @type {Object.<string,ReflectionObject>|undefined}\n   */\n\n  this.nested = undefined; // toJSON\n\n  /**\n   * Cached nested objects as an array.\n   * @type {ReflectionObject[]|null}\n   * @private\n   */\n\n  this._nestedArray = null;\n}\n\nfunction clearCache(namespace) {\n  namespace._nestedArray = null;\n  return namespace;\n}\n/**\n * Nested objects of this namespace as an array for iteration.\n * @name NamespaceBase#nestedArray\n * @type {ReflectionObject[]}\n * @readonly\n */\n\n\nObject.defineProperty(Namespace.prototype, \"nestedArray\", {\n  get: function () {\n    return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n  }\n});\n/**\n * Namespace descriptor.\n * @interface INamespace\n * @property {Object.<string,*>} [options] Namespace options\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\n */\n\n/**\n * Any extension field descriptor.\n * @typedef AnyExtensionField\n * @type {IExtensionField|IExtensionMapField}\n */\n\n/**\n * Any nested object descriptor.\n * @typedef AnyNestedObject\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace}\n */\n// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)\n\n/**\n * Converts this namespace to a namespace descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {INamespace} Namespace descriptor\n */\n\nNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\n  return util.toObject([\"options\", this.options, \"nested\", arrayToJSON(this.nestedArray, toJSONOptions)]);\n};\n/**\n * Adds nested objects to this namespace from nested object descriptors.\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\n * @returns {Namespace} `this`\n */\n\n\nNamespace.prototype.addJSON = function addJSON(nestedJson) {\n  var ns = this;\n  /* istanbul ignore else */\n\n  if (nestedJson) {\n    for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\n      nested = nestedJson[names[i]];\n      ns.add( // most to least likely\n      (nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : nested.id !== undefined ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));\n    }\n  }\n\n  return this;\n};\n/**\n * Gets the nested object of the specified name.\n * @param {string} name Nested object name\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\n */\n\n\nNamespace.prototype.get = function get(name) {\n  return this.nested && this.nested[name] || null;\n};\n/**\n * Gets the values of the nested {@link Enum|enum} of the specified name.\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\n * @param {string} name Nested enum name\n * @returns {Object.<string,number>} Enum values\n * @throws {Error} If there is no such enum\n */\n\n\nNamespace.prototype.getEnum = function getEnum(name) {\n  if (this.nested && this.nested[name] instanceof Enum) return this.nested[name].values;\n  throw Error(\"no such enum: \" + name);\n};\n/**\n * Adds a nested object to this namespace.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name\n */\n\n\nNamespace.prototype.add = function add(object) {\n  if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace)) throw TypeError(\"object must be a valid nested object\");\n  if (!this.nested) this.nested = {};else {\n    var prev = this.get(object.name);\n\n    if (prev) {\n      if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n        // replace plain namespace but keep existing nested elements and options\n        var nested = prev.nestedArray;\n\n        for (var i = 0; i < nested.length; ++i) object.add(nested[i]);\n\n        this.remove(prev);\n        if (!this.nested) this.nested = {};\n        object.setOptions(prev.options, true);\n      } else throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n    }\n  }\n  this.nested[object.name] = object;\n  object.onAdd(this);\n  return clearCache(this);\n};\n/**\n * Removes a nested object from this namespace.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this namespace\n */\n\n\nNamespace.prototype.remove = function remove(object) {\n  if (!(object instanceof ReflectionObject)) throw TypeError(\"object must be a ReflectionObject\");\n  if (object.parent !== this) throw Error(object + \" is not a member of \" + this);\n  delete this.nested[object.name];\n  if (!Object.keys(this.nested).length) this.nested = undefined;\n  object.onRemove(this);\n  return clearCache(this);\n};\n/**\n * Defines additial namespaces within this one if not yet existing.\n * @param {string|string[]} path Path to create\n * @param {*} [json] Nested types to create from JSON\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\n */\n\n\nNamespace.prototype.define = function define(path, json) {\n  if (util.isString(path)) path = path.split(\".\");else if (!Array.isArray(path)) throw TypeError(\"illegal path\");\n  if (path && path.length && path[0] === \"\") throw Error(\"path must be relative\");\n  var ptr = this;\n\n  while (path.length > 0) {\n    var part = path.shift();\n\n    if (ptr.nested && ptr.nested[part]) {\n      ptr = ptr.nested[part];\n      if (!(ptr instanceof Namespace)) throw Error(\"path conflicts with non-namespace objects\");\n    } else ptr.add(ptr = new Namespace(part));\n  }\n\n  if (json) ptr.addJSON(json);\n  return ptr;\n};\n/**\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\n * @returns {Namespace} `this`\n */\n\n\nNamespace.prototype.resolveAll = function resolveAll() {\n  var nested = this.nestedArray,\n      i = 0;\n\n  while (i < nested.length) if (nested[i] instanceof Namespace) nested[i++].resolveAll();else nested[i++].resolve();\n\n  return this.resolve();\n};\n/**\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\n * @param {string|string[]} path Path to look up\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n */\n\n\nNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n  /* istanbul ignore next */\n  if (typeof filterTypes === \"boolean\") {\n    parentAlreadyChecked = filterTypes;\n    filterTypes = undefined;\n  } else if (filterTypes && !Array.isArray(filterTypes)) filterTypes = [filterTypes];\n\n  if (util.isString(path) && path.length) {\n    if (path === \".\") return this.root;\n    path = path.split(\".\");\n  } else if (!path.length) return this; // Start at root if path is absolute\n\n\n  if (path[0] === \"\") return this.root.lookup(path.slice(1), filterTypes); // Test if the first part matches any nested object, and if so, traverse if path contains more\n\n  var found = this.get(path[0]);\n\n  if (found) {\n    if (path.length === 1) {\n      if (!filterTypes || filterTypes.indexOf(found.constructor) > -1) return found;\n    } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true))) return found; // Otherwise try each nested namespace\n\n  } else for (var i = 0; i < this.nestedArray.length; ++i) if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true))) return found; // If there hasn't been a match, try again at the parent\n\n\n  if (this.parent === null || parentAlreadyChecked) return null;\n  return this.parent.lookup(path, filterTypes);\n};\n/**\n * Looks up the reflection object at the specified path, relative to this namespace.\n * @name NamespaceBase#lookup\n * @function\n * @param {string|string[]} path Path to look up\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @variation 2\n */\n// lookup(path: string, [parentAlreadyChecked: boolean])\n\n/**\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type\n * @throws {Error} If `path` does not point to a type\n */\n\n\nNamespace.prototype.lookupType = function lookupType(path) {\n  var found = this.lookup(path, [Type]);\n  if (!found) throw Error(\"no such type: \" + path);\n  return found;\n};\n/**\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Enum} Looked up enum\n * @throws {Error} If `path` does not point to an enum\n */\n\n\nNamespace.prototype.lookupEnum = function lookupEnum(path) {\n  var found = this.lookup(path, [Enum]);\n  if (!found) throw Error(\"no such Enum '\" + path + \"' in \" + this);\n  return found;\n};\n/**\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type or enum\n * @throws {Error} If `path` does not point to a type or enum\n */\n\n\nNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n  var found = this.lookup(path, [Type, Enum]);\n  if (!found) throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n  return found;\n};\n/**\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Service} Looked up service\n * @throws {Error} If `path` does not point to a service\n */\n\n\nNamespace.prototype.lookupService = function lookupService(path) {\n  var found = this.lookup(path, [Service]);\n  if (!found) throw Error(\"no such Service '\" + path + \"' in \" + this);\n  return found;\n}; // Sets up cyclic dependencies (called in index-light)\n\n\nNamespace._configure = function (Type_, Service_, Enum_) {\n  Type = Type_;\n  Service = Service_;\n  Enum = Enum_;\n};","map":{"version":3,"sources":["/Users/piyushmaheshwari/Downloads/github/Bridgeorg/node_modules/protobufjs/src/namespace.js"],"names":["module","exports","Namespace","ReflectionObject","require","prototype","Object","create","constructor","className","Field","util","Type","Service","Enum","fromJSON","name","json","options","addJSON","nested","arrayToJSON","array","toJSONOptions","length","undefined","obj","i","toJSON","isReservedId","reserved","id","isReservedName","call","_nestedArray","clearCache","namespace","defineProperty","get","toArray","toObject","nestedArray","nestedJson","ns","names","keys","add","fields","values","methods","getEnum","Error","object","extend","TypeError","prev","remove","setOptions","onAdd","parent","onRemove","define","path","isString","split","Array","isArray","ptr","part","shift","resolveAll","resolve","lookup","filterTypes","parentAlreadyChecked","root","slice","found","indexOf","lookupType","lookupEnum","lookupTypeOrEnum","lookupService","_configure","Type_","Service_","Enum_"],"mappings":"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","sourcesContent":["\"use strict\";\nmodule.exports = Namespace;\n\n// extends ReflectionObject\nvar ReflectionObject = require(\"./object\");\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\n\nvar Field    = require(\"./field\"),\n    util     = require(\"./util\");\n\nvar Type,    // cyclic\n    Service,\n    Enum;\n\n/**\n * Constructs a new namespace instance.\n * @name Namespace\n * @classdesc Reflected namespace.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n */\n\n/**\n * Constructs a namespace from JSON.\n * @memberof Namespace\n * @function\n * @param {string} name Namespace name\n * @param {Object.<string,*>} json JSON object\n * @returns {Namespace} Created namespace\n * @throws {TypeError} If arguments are invalid\n */\nNamespace.fromJSON = function fromJSON(name, json) {\n    return new Namespace(name, json.options).addJSON(json.nested);\n};\n\n/**\n * Converts an array of reflection objects to JSON.\n * @memberof Namespace\n * @param {ReflectionObject[]} array Object array\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\n */\nfunction arrayToJSON(array, toJSONOptions) {\n    if (!(array && array.length))\n        return undefined;\n    var obj = {};\n    for (var i = 0; i < array.length; ++i)\n        obj[array[i].name] = array[i].toJSON(toJSONOptions);\n    return obj;\n}\n\nNamespace.arrayToJSON = arrayToJSON;\n\n/**\n * Tests if the specified id is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedId = function isReservedId(reserved, id) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id)\n                return true;\n    return false;\n};\n\n/**\n * Tests if the specified name is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */\nNamespace.isReservedName = function isReservedName(reserved, name) {\n    if (reserved)\n        for (var i = 0; i < reserved.length; ++i)\n            if (reserved[i] === name)\n                return true;\n    return false;\n};\n\n/**\n * Not an actual constructor. Use {@link Namespace} instead.\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports NamespaceBase\n * @extends ReflectionObject\n * @abstract\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n * @see {@link Namespace}\n */\nfunction Namespace(name, options) {\n    ReflectionObject.call(this, name, options);\n\n    /**\n     * Nested objects by name.\n     * @type {Object.<string,ReflectionObject>|undefined}\n     */\n    this.nested = undefined; // toJSON\n\n    /**\n     * Cached nested objects as an array.\n     * @type {ReflectionObject[]|null}\n     * @private\n     */\n    this._nestedArray = null;\n}\n\nfunction clearCache(namespace) {\n    namespace._nestedArray = null;\n    return namespace;\n}\n\n/**\n * Nested objects of this namespace as an array for iteration.\n * @name NamespaceBase#nestedArray\n * @type {ReflectionObject[]}\n * @readonly\n */\nObject.defineProperty(Namespace.prototype, \"nestedArray\", {\n    get: function() {\n        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n    }\n});\n\n/**\n * Namespace descriptor.\n * @interface INamespace\n * @property {Object.<string,*>} [options] Namespace options\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\n */\n\n/**\n * Any extension field descriptor.\n * @typedef AnyExtensionField\n * @type {IExtensionField|IExtensionMapField}\n */\n\n/**\n * Any nested object descriptor.\n * @typedef AnyNestedObject\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace}\n */\n// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)\n\n/**\n * Converts this namespace to a namespace descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {INamespace} Namespace descriptor\n */\nNamespace.prototype.toJSON = function toJSON(toJSONOptions) {\n    return util.toObject([\n        \"options\" , this.options,\n        \"nested\"  , arrayToJSON(this.nestedArray, toJSONOptions)\n    ]);\n};\n\n/**\n * Adds nested objects to this namespace from nested object descriptors.\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\n * @returns {Namespace} `this`\n */\nNamespace.prototype.addJSON = function addJSON(nestedJson) {\n    var ns = this;\n    /* istanbul ignore else */\n    if (nestedJson) {\n        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {\n            nested = nestedJson[names[i]];\n            ns.add( // most to least likely\n                ( nested.fields !== undefined\n                ? Type.fromJSON\n                : nested.values !== undefined\n                ? Enum.fromJSON\n                : nested.methods !== undefined\n                ? Service.fromJSON\n                : nested.id !== undefined\n                ? Field.fromJSON\n                : Namespace.fromJSON )(names[i], nested)\n            );\n        }\n    }\n    return this;\n};\n\n/**\n * Gets the nested object of the specified name.\n * @param {string} name Nested object name\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\n */\nNamespace.prototype.get = function get(name) {\n    return this.nested && this.nested[name]\n        || null;\n};\n\n/**\n * Gets the values of the nested {@link Enum|enum} of the specified name.\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\n * @param {string} name Nested enum name\n * @returns {Object.<string,number>} Enum values\n * @throws {Error} If there is no such enum\n */\nNamespace.prototype.getEnum = function getEnum(name) {\n    if (this.nested && this.nested[name] instanceof Enum)\n        return this.nested[name].values;\n    throw Error(\"no such enum: \" + name);\n};\n\n/**\n * Adds a nested object to this namespace.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name\n */\nNamespace.prototype.add = function add(object) {\n\n    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace))\n        throw TypeError(\"object must be a valid nested object\");\n\n    if (!this.nested)\n        this.nested = {};\n    else {\n        var prev = this.get(object.name);\n        if (prev) {\n            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n                // replace plain namespace but keep existing nested elements and options\n                var nested = prev.nestedArray;\n                for (var i = 0; i < nested.length; ++i)\n                    object.add(nested[i]);\n                this.remove(prev);\n                if (!this.nested)\n                    this.nested = {};\n                object.setOptions(prev.options, true);\n\n            } else\n                throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n        }\n    }\n    this.nested[object.name] = object;\n    object.onAdd(this);\n    return clearCache(this);\n};\n\n/**\n * Removes a nested object from this namespace.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this namespace\n */\nNamespace.prototype.remove = function remove(object) {\n\n    if (!(object instanceof ReflectionObject))\n        throw TypeError(\"object must be a ReflectionObject\");\n    if (object.parent !== this)\n        throw Error(object + \" is not a member of \" + this);\n\n    delete this.nested[object.name];\n    if (!Object.keys(this.nested).length)\n        this.nested = undefined;\n\n    object.onRemove(this);\n    return clearCache(this);\n};\n\n/**\n * Defines additial namespaces within this one if not yet existing.\n * @param {string|string[]} path Path to create\n * @param {*} [json] Nested types to create from JSON\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\n */\nNamespace.prototype.define = function define(path, json) {\n\n    if (util.isString(path))\n        path = path.split(\".\");\n    else if (!Array.isArray(path))\n        throw TypeError(\"illegal path\");\n    if (path && path.length && path[0] === \"\")\n        throw Error(\"path must be relative\");\n\n    var ptr = this;\n    while (path.length > 0) {\n        var part = path.shift();\n        if (ptr.nested && ptr.nested[part]) {\n            ptr = ptr.nested[part];\n            if (!(ptr instanceof Namespace))\n                throw Error(\"path conflicts with non-namespace objects\");\n        } else\n            ptr.add(ptr = new Namespace(part));\n    }\n    if (json)\n        ptr.addJSON(json);\n    return ptr;\n};\n\n/**\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\n * @returns {Namespace} `this`\n */\nNamespace.prototype.resolveAll = function resolveAll() {\n    var nested = this.nestedArray, i = 0;\n    while (i < nested.length)\n        if (nested[i] instanceof Namespace)\n            nested[i++].resolveAll();\n        else\n            nested[i++].resolve();\n    return this.resolve();\n};\n\n/**\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\n * @param {string|string[]} path Path to look up\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n */\nNamespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n\n    /* istanbul ignore next */\n    if (typeof filterTypes === \"boolean\") {\n        parentAlreadyChecked = filterTypes;\n        filterTypes = undefined;\n    } else if (filterTypes && !Array.isArray(filterTypes))\n        filterTypes = [ filterTypes ];\n\n    if (util.isString(path) && path.length) {\n        if (path === \".\")\n            return this.root;\n        path = path.split(\".\");\n    } else if (!path.length)\n        return this;\n\n    // Start at root if path is absolute\n    if (path[0] === \"\")\n        return this.root.lookup(path.slice(1), filterTypes);\n\n    // Test if the first part matches any nested object, and if so, traverse if path contains more\n    var found = this.get(path[0]);\n    if (found) {\n        if (path.length === 1) {\n            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)\n                return found;\n        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))\n            return found;\n\n    // Otherwise try each nested namespace\n    } else\n        for (var i = 0; i < this.nestedArray.length; ++i)\n            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))\n                return found;\n\n    // If there hasn't been a match, try again at the parent\n    if (this.parent === null || parentAlreadyChecked)\n        return null;\n    return this.parent.lookup(path, filterTypes);\n};\n\n/**\n * Looks up the reflection object at the specified path, relative to this namespace.\n * @name NamespaceBase#lookup\n * @function\n * @param {string|string[]} path Path to look up\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @variation 2\n */\n// lookup(path: string, [parentAlreadyChecked: boolean])\n\n/**\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type\n * @throws {Error} If `path` does not point to a type\n */\nNamespace.prototype.lookupType = function lookupType(path) {\n    var found = this.lookup(path, [ Type ]);\n    if (!found)\n        throw Error(\"no such type: \" + path);\n    return found;\n};\n\n/**\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Enum} Looked up enum\n * @throws {Error} If `path` does not point to an enum\n */\nNamespace.prototype.lookupEnum = function lookupEnum(path) {\n    var found = this.lookup(path, [ Enum ]);\n    if (!found)\n        throw Error(\"no such Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type or enum\n * @throws {Error} If `path` does not point to a type or enum\n */\nNamespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n    var found = this.lookup(path, [ Type, Enum ]);\n    if (!found)\n        throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n    return found;\n};\n\n/**\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Service} Looked up service\n * @throws {Error} If `path` does not point to a service\n */\nNamespace.prototype.lookupService = function lookupService(path) {\n    var found = this.lookup(path, [ Service ]);\n    if (!found)\n        throw Error(\"no such Service '\" + path + \"' in \" + this);\n    return found;\n};\n\n// Sets up cyclic dependencies (called in index-light)\nNamespace._configure = function(Type_, Service_, Enum_) {\n    Type    = Type_;\n    Service = Service_;\n    Enum    = Enum_;\n};\n"]},"metadata":{},"sourceType":"script"}