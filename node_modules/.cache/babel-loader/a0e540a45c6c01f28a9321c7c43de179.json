{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.retryable = void 0;\n\nconst status_1 = require(\"../status\");\n\nconst googleError_1 = require(\"../googleError\");\n\nconst timeout_1 = require(\"./timeout\");\n/**\n * Creates a function equivalent to func, but that retries on certain\n * exceptions.\n *\n * @private\n *\n * @param {GRPCCall} func - A function.\n * @param {RetryOptions} retry - Configures the exceptions upon which the\n *   function eshould retry, and the parameters to the exponential backoff retry\n *   algorithm.\n * @param {GRPCCallOtherArgs} otherArgs - the additional arguments to be passed to func.\n * @return {SimpleCallbackFunction} A function that will retry.\n */\n\n\nfunction retryable(func, retry, otherArgs, apiName) {\n  const delayMult = retry.backoffSettings.retryDelayMultiplier;\n  const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n  const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n  const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n  let delay = retry.backoffSettings.initialRetryDelayMillis;\n  let timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n  /**\n   * Equivalent to ``func``, but retries upon transient failure.\n   *\n   * Retrying is done through an exponential backoff algorithm configured\n   * by the options in ``retry``.\n   * @param {RequestType} argument The request object.\n   * @param {APICallback} callback The callback.\n   * @return {GRPCCall}\n   */\n\n  return (argument, callback) => {\n    let canceller;\n    let timeoutId;\n    let now = new Date();\n    let deadline;\n\n    if (retry.backoffSettings.totalTimeoutMillis) {\n      deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n    }\n\n    let retries = 0;\n    const maxRetries = retry.backoffSettings.maxRetries; // TODO: define A/B testing values for retry behaviors.\n\n    /** Repeat the API call as long as necessary. */\n\n    function repeat() {\n      timeoutId = null;\n\n      if (deadline && now.getTime() >= deadline) {\n        const error = new googleError_1.GoogleError(`Total timeout of API ${apiName} exceeded ${retry.backoffSettings.totalTimeoutMillis} milliseconds before any response was received.`);\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        callback(error);\n        return;\n      }\n\n      if (retries && retries >= maxRetries) {\n        const error = new googleError_1.GoogleError('Exceeded maximum number of retries before any ' + 'response was received');\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        callback(error);\n        return;\n      }\n\n      retries++;\n      const toCall = timeout_1.addTimeoutArg(func, timeout, otherArgs);\n      canceller = toCall(argument, (err, response, next, rawResponse) => {\n        if (!err) {\n          callback(null, response, next, rawResponse);\n          return;\n        }\n\n        canceller = null;\n\n        if (retry.retryCodes.indexOf(err.code) < 0) {\n          err.note = 'Exception occurred in retry method that was ' + 'not classified as transient';\n          callback(err);\n        } else {\n          const toSleep = Math.random() * delay;\n          timeoutId = setTimeout(() => {\n            now = new Date();\n            delay = Math.min(delay * delayMult, maxDelay);\n            const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n            const rpcTimeout = maxTimeout ? maxTimeout : 0;\n            const newDeadline = deadline ? deadline - now.getTime() : 0;\n            timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n            repeat();\n          }, toSleep);\n        }\n      });\n    }\n\n    if (maxRetries && deadline) {\n      const error = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' + 'in backoffSettings.');\n      error.code = status_1.Status.INVALID_ARGUMENT;\n      callback(error);\n    } else {\n      repeat();\n    }\n\n    return {\n      cancel() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n\n        if (canceller) {\n          canceller.cancel();\n        } else {\n          const error = new googleError_1.GoogleError('cancelled');\n          error.code = status_1.Status.CANCELLED;\n          callback(error);\n        }\n      }\n\n    };\n  };\n}\n\nexports.retryable = retryable;","map":{"version":3,"sources":["../../../src/normalCalls/retries.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.retryable = void 0;\nconst status_1 = require(\"../status\");\nconst googleError_1 = require(\"../googleError\");\nconst timeout_1 = require(\"./timeout\");\n/**\n * Creates a function equivalent to func, but that retries on certain\n * exceptions.\n *\n * @private\n *\n * @param {GRPCCall} func - A function.\n * @param {RetryOptions} retry - Configures the exceptions upon which the\n *   function eshould retry, and the parameters to the exponential backoff retry\n *   algorithm.\n * @param {GRPCCallOtherArgs} otherArgs - the additional arguments to be passed to func.\n * @return {SimpleCallbackFunction} A function that will retry.\n */\nfunction retryable(func, retry, otherArgs, apiName) {\n    const delayMult = retry.backoffSettings.retryDelayMultiplier;\n    const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n    const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n    const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n    let delay = retry.backoffSettings.initialRetryDelayMillis;\n    let timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n    /**\n     * Equivalent to ``func``, but retries upon transient failure.\n     *\n     * Retrying is done through an exponential backoff algorithm configured\n     * by the options in ``retry``.\n     * @param {RequestType} argument The request object.\n     * @param {APICallback} callback The callback.\n     * @return {GRPCCall}\n     */\n    return (argument, callback) => {\n        let canceller;\n        let timeoutId;\n        let now = new Date();\n        let deadline;\n        if (retry.backoffSettings.totalTimeoutMillis) {\n            deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n        }\n        let retries = 0;\n        const maxRetries = retry.backoffSettings.maxRetries;\n        // TODO: define A/B testing values for retry behaviors.\n        /** Repeat the API call as long as necessary. */\n        function repeat() {\n            timeoutId = null;\n            if (deadline && now.getTime() >= deadline) {\n                const error = new googleError_1.GoogleError(`Total timeout of API ${apiName} exceeded ${retry.backoffSettings.totalTimeoutMillis} milliseconds before any response was received.`);\n                error.code = status_1.Status.DEADLINE_EXCEEDED;\n                callback(error);\n                return;\n            }\n            if (retries && retries >= maxRetries) {\n                const error = new googleError_1.GoogleError('Exceeded maximum number of retries before any ' +\n                    'response was received');\n                error.code = status_1.Status.DEADLINE_EXCEEDED;\n                callback(error);\n                return;\n            }\n            retries++;\n            const toCall = timeout_1.addTimeoutArg(func, timeout, otherArgs);\n            canceller = toCall(argument, (err, response, next, rawResponse) => {\n                if (!err) {\n                    callback(null, response, next, rawResponse);\n                    return;\n                }\n                canceller = null;\n                if (retry.retryCodes.indexOf(err.code) < 0) {\n                    err.note =\n                        'Exception occurred in retry method that was ' +\n                            'not classified as transient';\n                    callback(err);\n                }\n                else {\n                    const toSleep = Math.random() * delay;\n                    timeoutId = setTimeout(() => {\n                        now = new Date();\n                        delay = Math.min(delay * delayMult, maxDelay);\n                        const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n                        const rpcTimeout = maxTimeout ? maxTimeout : 0;\n                        const newDeadline = deadline ? deadline - now.getTime() : 0;\n                        timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n                        repeat();\n                    }, toSleep);\n                }\n            });\n        }\n        if (maxRetries && deadline) {\n            const error = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' +\n                'in backoffSettings.');\n            error.code = status_1.Status.INVALID_ARGUMENT;\n            callback(error);\n        }\n        else {\n            repeat();\n        }\n        return {\n            cancel() {\n                if (timeoutId) {\n                    clearTimeout(timeoutId);\n                }\n                if (canceller) {\n                    canceller.cancel();\n                }\n                else {\n                    const error = new googleError_1.GoogleError('cancelled');\n                    error.code = status_1.Status.CANCELLED;\n                    callback(error);\n                }\n            },\n        };\n    };\n}\nexports.retryable = retryable;\n//# sourceMappingURL=retries.js.map"]},"metadata":{},"sourceType":"script"}