{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PathTemplate = void 0;\n\nclass PathTemplate {\n  /**\n   * @param {String} data the of the template\n   *\n   * @constructor\n   */\n  constructor(data) {\n    this.bindings = {};\n    this.data = data;\n    this.segments = this.parsePathTemplate(data);\n    this.size = this.segments.length;\n  }\n  /**\n   * Matches a fully-qualified path template string.\n   *\n   * @param {String} path a fully-qualified path template string\n   * @return {Object} contains const names matched to binding values\n   * @throws {TypeError} if path can't be matched to this template\n   */\n\n\n  match(path) {\n    let pathSegments = path.split('/');\n    const bindings = {};\n\n    if (pathSegments.length !== this.segments.length) {\n      // if the path contains a wildcard, then the length may differ by 1.\n      if (!this.data.includes('**')) {\n        throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same.`);\n      } else if (pathSegments.length !== this.segments.length + 1) {\n        throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same with one wildcard.`);\n      }\n    }\n\n    for (let index = 0; index < this.segments.length && pathSegments.length > 0; index++) {\n      if (this.segments[index] !== pathSegments[0]) {\n        if (!this.segments[index].includes('*')) {\n          throw new TypeError(`segment does not match, ${this.segments[index]} and  ${pathSegments[index]}.`);\n        } else {\n          let segment = this.segments[index];\n          const variable = segment.match(/(?<={)[$0-9a-zA-Z_]+(?==.*})/g) || [];\n\n          if (segment.includes('**')) {\n            bindings[variable[0]] = pathSegments[0] + '/' + pathSegments[1];\n            pathSegments = pathSegments.slice(2);\n          } else {\n            // atomic resource\n            if (variable.length === 1) {\n              bindings[variable[0]] = pathSegments[0];\n            } else {\n              // non-slash resource\n              // segment: {blurb_id=*}.{legacy_user=*} to match pathSegments: ['bar.user2']\n              // split the match pathSegments[0] -> value: ['bar', 'user2']\n              // compare the length of two arrays, and compare array items\n              const value = pathSegments[0].split(/[-_.~]/);\n\n              if (value.length !== variable.length) {\n                throw new Error(`segment ${segment} does not match ${pathSegments[0]}`);\n              }\n\n              for (const v of variable) {\n                bindings[v] = value[0];\n                segment = segment.replace(`{${v}=*}`, `${value[0]}`);\n                value.shift();\n              } // segment: {blurb_id=*}.{legacy_user=*} matching pathSegments: ['bar~user2'] should fail\n\n\n              if (segment !== pathSegments[0]) {\n                throw new TypeError(`non slash resource pattern ${this.segments[index]} and ${pathSegments[0]} should have same separator`);\n              }\n            }\n\n            pathSegments.shift();\n          }\n        }\n      } else {\n        pathSegments.shift();\n      }\n    }\n\n    return bindings;\n  }\n  /**\n   * Renders a path template using the provided bindings.\n   *\n   * @param {Object} bindings a mapping of const names to binding strings\n   * @return {String} a rendered representation of the path template\n   * @throws {TypeError} if a key is missing, or if a sub-template cannot be\n   *   parsed\n   */\n\n\n  render(bindings) {\n    if (Object.keys(bindings).length !== Object.keys(this.bindings).length) {\n      throw new TypeError(`The number of variables ${Object.keys(bindings).length} does not match the number of needed variables ${Object.keys(this.bindings).length}`);\n    }\n\n    let path = this.inspect();\n\n    for (const key of Object.keys(bindings)) {\n      const b = bindings[key].toString();\n\n      if (!this.bindings[key]) {\n        throw new TypeError(`render fails for not matching ${bindings[key]}`);\n      }\n\n      const variable = this.bindings[key];\n\n      if (variable === '*') {\n        if (!b.match(/[^/{}]+/)) {\n          throw new TypeError(`render fails for not matching ${b}`);\n        }\n\n        path = path.replace(`{${key}=*}`, `${b}`);\n      } else if (variable === '**') {\n        if (!b.match(/[^{}]+/)) {\n          throw new TypeError(`render fails for not matching ${b}`);\n        }\n\n        path = path.replace(`{${key}=**}`, `${b}`);\n      }\n    }\n\n    return path;\n  }\n  /**\n   * Renders the path template.\n   *\n   * @return {string} contains const names matched to binding values\n   */\n\n\n  inspect() {\n    return this.segments.join('/');\n  }\n  /**\n   * Parse the path template.\n   *\n   * @return {string[]} return segments of the input path.\n   * For example: 'buckets/{hello}'' will give back ['buckets', {hello=*}]\n   */\n\n\n  parsePathTemplate(data) {\n    const pathSegments = splitPathTemplate(data);\n    let index = 0;\n    let wildCardCount = 0;\n    const segments = [];\n    pathSegments.forEach(segment => {\n      // * or ** -> segments.push('{$0=*}');\n      //         -> bindings['$0'] = '*'\n      if (segment === '*' || segment === '**') {\n        this.bindings[`$${index}`] = segment;\n        segments.push(`{$${index}=${segment}}`);\n        index = index + 1;\n\n        if (segment === '**') {\n          wildCardCount = wildCardCount + 1;\n        }\n      } // {project}~{location} -> {project=*}~{location=*}\n      else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?:}[-._~]?{)[0-9a-zA-Z-.~_]+(?=})/)) {\n        // [project, location]\n        const variable = segment.match(/(?<=\\{).*?(?=(?:=.*?)?\\})/g) || [];\n\n        for (const v of variable) {\n          this.bindings[v] = '*';\n          segment = segment.replace(v, v + '=*');\n        }\n\n        segments.push(segment);\n      } // {project} / {project=*} -> segments.push('{project=*}');\n      //           -> bindings['project'] = '*'\n      else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*)?})/)) {\n        const variable = segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*)?})/);\n        this.bindings[variable[0]] = '*';\n        segments.push(`{${variable[0]}=*}`);\n      } // {project=**} -> segments.push('{project=**}');\n      //           -> bindings['project'] = '**'\n      else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*\\*)})/)) {\n        const variable = segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*\\*)})/);\n        this.bindings[variable[0]] = '**';\n        segments.push(`{${variable[0]}=**}`);\n        wildCardCount = wildCardCount + 1;\n      } // {hello=/what} -> segments.push('{hello=/what}');\n      //              -> no binding in this case\n      else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+=[^*]+(?=})/)) {\n        segments.push(segment);\n      } // helloazAZ09-.~_what -> segments.push('helloazAZ09-.~_what');\n      //              -> no binding in this case\n      else if (segment.match(/[0-9a-zA-Z-.~_]+/)) {\n        segments.push(segment);\n      }\n\n      if (wildCardCount > 1) {\n        throw new TypeError('Can not have more than one wildcard.');\n      }\n    });\n    return segments;\n  }\n\n}\n\nexports.PathTemplate = PathTemplate;\n/**\n * Split the path template by `/`.\n * It can not be simply splitted by `/` because there might be `/` in the segments.\n * For example: 'a/b/{a=hello/world}' we do not want to break the brackets pair\n * so above path will be splitted as ['a', 'b', '{a=hello/world}']\n */\n\nfunction splitPathTemplate(data) {\n  let left = 0;\n  let right = 0;\n  let bracketCount = 0;\n  const segments = [];\n\n  while (right >= left && right < data.length) {\n    if (data.charAt(right) === '{') {\n      bracketCount = bracketCount + 1;\n    } else if (data.charAt(right) === '}') {\n      bracketCount = bracketCount - 1;\n    } else if (data.charAt(right) === '/') {\n      if (right === data.length - 1) {\n        throw new TypeError('Invalid path, it can not be ended by /');\n      }\n\n      if (bracketCount === 0) {\n        // complete bracket, to avoid the case a/b/**/*/{a=hello/world}\n        segments.push(data.substring(left, right));\n        left = right + 1;\n      }\n    }\n\n    if (right === data.length - 1) {\n      if (bracketCount !== 0) {\n        throw new TypeError('Brackets are invalid.');\n      }\n\n      segments.push(data.substring(left));\n    }\n\n    right = right + 1;\n  }\n\n  return segments;\n}","map":{"version":3,"sources":["../../src/pathTemplate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathTemplate = void 0;\nclass PathTemplate {\n    /**\n     * @param {String} data the of the template\n     *\n     * @constructor\n     */\n    constructor(data) {\n        this.bindings = {};\n        this.data = data;\n        this.segments = this.parsePathTemplate(data);\n        this.size = this.segments.length;\n    }\n    /**\n     * Matches a fully-qualified path template string.\n     *\n     * @param {String} path a fully-qualified path template string\n     * @return {Object} contains const names matched to binding values\n     * @throws {TypeError} if path can't be matched to this template\n     */\n    match(path) {\n        let pathSegments = path.split('/');\n        const bindings = {};\n        if (pathSegments.length !== this.segments.length) {\n            // if the path contains a wildcard, then the length may differ by 1.\n            if (!this.data.includes('**')) {\n                throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same.`);\n            }\n            else if (pathSegments.length !== this.segments.length + 1) {\n                throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same with one wildcard.`);\n            }\n        }\n        for (let index = 0; index < this.segments.length && pathSegments.length > 0; index++) {\n            if (this.segments[index] !== pathSegments[0]) {\n                if (!this.segments[index].includes('*')) {\n                    throw new TypeError(`segment does not match, ${this.segments[index]} and  ${pathSegments[index]}.`);\n                }\n                else {\n                    let segment = this.segments[index];\n                    const variable = segment.match(/(?<={)[$0-9a-zA-Z_]+(?==.*})/g) || [];\n                    if (segment.includes('**')) {\n                        bindings[variable[0]] = pathSegments[0] + '/' + pathSegments[1];\n                        pathSegments = pathSegments.slice(2);\n                    }\n                    else {\n                        // atomic resource\n                        if (variable.length === 1) {\n                            bindings[variable[0]] = pathSegments[0];\n                        }\n                        else {\n                            // non-slash resource\n                            // segment: {blurb_id=*}.{legacy_user=*} to match pathSegments: ['bar.user2']\n                            // split the match pathSegments[0] -> value: ['bar', 'user2']\n                            // compare the length of two arrays, and compare array items\n                            const value = pathSegments[0].split(/[-_.~]/);\n                            if (value.length !== variable.length) {\n                                throw new Error(`segment ${segment} does not match ${pathSegments[0]}`);\n                            }\n                            for (const v of variable) {\n                                bindings[v] = value[0];\n                                segment = segment.replace(`{${v}=*}`, `${value[0]}`);\n                                value.shift();\n                            }\n                            // segment: {blurb_id=*}.{legacy_user=*} matching pathSegments: ['bar~user2'] should fail\n                            if (segment !== pathSegments[0]) {\n                                throw new TypeError(`non slash resource pattern ${this.segments[index]} and ${pathSegments[0]} should have same separator`);\n                            }\n                        }\n                        pathSegments.shift();\n                    }\n                }\n            }\n            else {\n                pathSegments.shift();\n            }\n        }\n        return bindings;\n    }\n    /**\n     * Renders a path template using the provided bindings.\n     *\n     * @param {Object} bindings a mapping of const names to binding strings\n     * @return {String} a rendered representation of the path template\n     * @throws {TypeError} if a key is missing, or if a sub-template cannot be\n     *   parsed\n     */\n    render(bindings) {\n        if (Object.keys(bindings).length !== Object.keys(this.bindings).length) {\n            throw new TypeError(`The number of variables ${Object.keys(bindings).length} does not match the number of needed variables ${Object.keys(this.bindings).length}`);\n        }\n        let path = this.inspect();\n        for (const key of Object.keys(bindings)) {\n            const b = bindings[key].toString();\n            if (!this.bindings[key]) {\n                throw new TypeError(`render fails for not matching ${bindings[key]}`);\n            }\n            const variable = this.bindings[key];\n            if (variable === '*') {\n                if (!b.match(/[^/{}]+/)) {\n                    throw new TypeError(`render fails for not matching ${b}`);\n                }\n                path = path.replace(`{${key}=*}`, `${b}`);\n            }\n            else if (variable === '**') {\n                if (!b.match(/[^{}]+/)) {\n                    throw new TypeError(`render fails for not matching ${b}`);\n                }\n                path = path.replace(`{${key}=**}`, `${b}`);\n            }\n        }\n        return path;\n    }\n    /**\n     * Renders the path template.\n     *\n     * @return {string} contains const names matched to binding values\n     */\n    inspect() {\n        return this.segments.join('/');\n    }\n    /**\n     * Parse the path template.\n     *\n     * @return {string[]} return segments of the input path.\n     * For example: 'buckets/{hello}'' will give back ['buckets', {hello=*}]\n     */\n    parsePathTemplate(data) {\n        const pathSegments = splitPathTemplate(data);\n        let index = 0;\n        let wildCardCount = 0;\n        const segments = [];\n        pathSegments.forEach(segment => {\n            // * or ** -> segments.push('{$0=*}');\n            //         -> bindings['$0'] = '*'\n            if (segment === '*' || segment === '**') {\n                this.bindings[`$${index}`] = segment;\n                segments.push(`{$${index}=${segment}}`);\n                index = index + 1;\n                if (segment === '**') {\n                    wildCardCount = wildCardCount + 1;\n                }\n            }\n            // {project}~{location} -> {project=*}~{location=*}\n            else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?:}[-._~]?{)[0-9a-zA-Z-.~_]+(?=})/)) {\n                // [project, location]\n                const variable = segment.match(/(?<=\\{).*?(?=(?:=.*?)?\\})/g) || [];\n                for (const v of variable) {\n                    this.bindings[v] = '*';\n                    segment = segment.replace(v, v + '=*');\n                }\n                segments.push(segment);\n            }\n            // {project} / {project=*} -> segments.push('{project=*}');\n            //           -> bindings['project'] = '*'\n            else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*)?})/)) {\n                const variable = segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*)?})/);\n                this.bindings[variable[0]] = '*';\n                segments.push(`{${variable[0]}=*}`);\n            }\n            // {project=**} -> segments.push('{project=**}');\n            //           -> bindings['project'] = '**'\n            else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*\\*)})/)) {\n                const variable = segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*\\*)})/);\n                this.bindings[variable[0]] = '**';\n                segments.push(`{${variable[0]}=**}`);\n                wildCardCount = wildCardCount + 1;\n            }\n            // {hello=/what} -> segments.push('{hello=/what}');\n            //              -> no binding in this case\n            else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+=[^*]+(?=})/)) {\n                segments.push(segment);\n            }\n            // helloazAZ09-.~_what -> segments.push('helloazAZ09-.~_what');\n            //              -> no binding in this case\n            else if (segment.match(/[0-9a-zA-Z-.~_]+/)) {\n                segments.push(segment);\n            }\n            if (wildCardCount > 1) {\n                throw new TypeError('Can not have more than one wildcard.');\n            }\n        });\n        return segments;\n    }\n}\nexports.PathTemplate = PathTemplate;\n/**\n * Split the path template by `/`.\n * It can not be simply splitted by `/` because there might be `/` in the segments.\n * For example: 'a/b/{a=hello/world}' we do not want to break the brackets pair\n * so above path will be splitted as ['a', 'b', '{a=hello/world}']\n */\nfunction splitPathTemplate(data) {\n    let left = 0;\n    let right = 0;\n    let bracketCount = 0;\n    const segments = [];\n    while (right >= left && right < data.length) {\n        if (data.charAt(right) === '{') {\n            bracketCount = bracketCount + 1;\n        }\n        else if (data.charAt(right) === '}') {\n            bracketCount = bracketCount - 1;\n        }\n        else if (data.charAt(right) === '/') {\n            if (right === data.length - 1) {\n                throw new TypeError('Invalid path, it can not be ended by /');\n            }\n            if (bracketCount === 0) {\n                // complete bracket, to avoid the case a/b/**/*/{a=hello/world}\n                segments.push(data.substring(left, right));\n                left = right + 1;\n            }\n        }\n        if (right === data.length - 1) {\n            if (bracketCount !== 0) {\n                throw new TypeError('Brackets are invalid.');\n            }\n            segments.push(data.substring(left));\n        }\n        right = right + 1;\n    }\n    return segments;\n}\n//# sourceMappingURL=pathTemplate.js.map"]},"metadata":{},"sourceType":"script"}